/*
  @license
	Rollup.js v3.29.4
	Thu, 28 Sep 2023 04:54:30 GMT - commit 4e92d60fa90cead39481e3703d26e5d812f43bd1

	https://github.com/rollup/rollup

	Released under the MIT License.
*/
var e = '3.29.4'
'undefined' != typeof globalThis ? globalThis : 'undefined' != typeof window ? window : 'undefined' != typeof global ? global : 'undefined' != typeof self && self
function t(e) {
	return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e
}
var s = { exports: {} }
!(function (e) {
	const t = ','.charCodeAt(0),
		s = ';'.charCodeAt(0),
		i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
		n = new Uint8Array(64),
		r = new Uint8Array(128)
	for (let e = 0; e < i.length; e++) {
		const t = i.charCodeAt(e)
		;(n[e] = t), (r[t] = e)
	}
	const o =
		'undefined' != typeof TextDecoder
			? new TextDecoder()
			: 'undefined' != typeof Buffer
			? { decode: (e) => Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString() }
			: {
					decode(e) {
						let t = ''
						for (let s = 0; s < e.length; s++) t += String.fromCharCode(e[s])
						return t
					}
			  }
	function a(e) {
		const t = new Int32Array(5),
			s = []
		let i = 0
		do {
			const n = l(e, i),
				r = []
			let o = !0,
				a = 0
			t[0] = 0
			for (let s = i; s < n; s++) {
				let i
				s = c(e, s, t, 0)
				const l = t[0]
				l < a && (o = !1),
					(a = l),
					h(e, s, n) ? ((s = c(e, s, t, 1)), (s = c(e, s, t, 2)), (s = c(e, s, t, 3)), h(e, s, n) ? ((s = c(e, s, t, 4)), (i = [l, t[1], t[2], t[3], t[4]])) : (i = [l, t[1], t[2], t[3]])) : (i = [l]),
					r.push(i)
			}
			o || u(r), s.push(r), (i = n + 1)
		} while (i <= e.length)
		return s
	}
	function l(e, t) {
		const s = e.indexOf(';', t)
		return -1 === s ? e.length : s
	}
	function c(e, t, s, i) {
		let n = 0,
			o = 0,
			a = 0
		do {
			const s = e.charCodeAt(t++)
			;(a = r[s]), (n |= (31 & a) << o), (o += 5)
		} while (32 & a)
		const l = 1 & n
		return (n >>>= 1), l && (n = -2147483648 | -n), (s[i] += n), t
	}
	function h(e, s, i) {
		return !(s >= i) && e.charCodeAt(s) !== t
	}
	function u(e) {
		e.sort(d)
	}
	function d(e, t) {
		return e[0] - t[0]
	}
	function p(e) {
		const i = new Int32Array(5),
			n = 16384,
			r = n - 36,
			a = new Uint8Array(n),
			l = a.subarray(0, r)
		let c = 0,
			h = ''
		for (let u = 0; u < e.length; u++) {
			const d = e[u]
			if ((u > 0 && (c === n && ((h += o.decode(a)), (c = 0)), (a[c++] = s)), 0 !== d.length)) {
				i[0] = 0
				for (let e = 0; e < d.length; e++) {
					const s = d[e]
					c > r && ((h += o.decode(l)), a.copyWithin(0, r, c), (c -= r)),
						e > 0 && (a[c++] = t),
						(c = f(a, c, i, s, 0)),
						1 !== s.length && ((c = f(a, c, i, s, 1)), (c = f(a, c, i, s, 2)), (c = f(a, c, i, s, 3)), 4 !== s.length && (c = f(a, c, i, s, 4)))
				}
			}
		}
		return h + o.decode(a.subarray(0, c))
	}
	function f(e, t, s, i, r) {
		const o = i[r]
		let a = o - s[r]
		;(s[r] = o), (a = a < 0 ? (-a << 1) | 1 : a << 1)
		do {
			let s = 31 & a
			;(a >>>= 5), a > 0 && (s |= 32), (e[t++] = n[s])
		} while (a > 0)
		return t
	}
	;(e.decode = a), (e.encode = p), Object.defineProperty(e, '__esModule', { value: !0 })
})(s.exports)
var i = s.exports
class n {
	constructor(e) {
		this.bits = e instanceof n ? e.bits.slice() : []
	}
	add(e) {
		this.bits[e >> 5] |= 1 << (31 & e)
	}
	has(e) {
		return !!(this.bits[e >> 5] & (1 << (31 & e)))
	}
}
let r = class e {
	constructor(e, t, s) {
		;(this.start = e),
			(this.end = t),
			(this.original = s),
			(this.intro = ''),
			(this.outro = ''),
			(this.content = s),
			(this.storeName = !1),
			(this.edited = !1),
			(this.previous = null),
			(this.next = null)
	}
	appendLeft(e) {
		this.outro += e
	}
	appendRight(e) {
		this.intro = this.intro + e
	}
	clone() {
		const t = new e(this.start, this.end, this.original)
		return (t.intro = this.intro), (t.outro = this.outro), (t.content = this.content), (t.storeName = this.storeName), (t.edited = this.edited), t
	}
	contains(e) {
		return this.start < e && e < this.end
	}
	eachNext(e) {
		let t = this
		for (; t; ) e(t), (t = t.next)
	}
	eachPrevious(e) {
		let t = this
		for (; t; ) e(t), (t = t.previous)
	}
	edit(e, t, s) {
		return (this.content = e), s || ((this.intro = ''), (this.outro = '')), (this.storeName = t), (this.edited = !0), this
	}
	prependLeft(e) {
		this.outro = e + this.outro
	}
	prependRight(e) {
		this.intro = e + this.intro
	}
	split(t) {
		const s = t - this.start,
			i = this.original.slice(0, s),
			n = this.original.slice(s)
		this.original = i
		const r = new e(t, this.end, n)
		return (
			(r.outro = this.outro),
			(this.outro = ''),
			(this.end = t),
			this.edited ? (r.edit('', !1), (this.content = '')) : (this.content = i),
			(r.next = this.next),
			r.next && (r.next.previous = r),
			(r.previous = this),
			(this.next = r),
			r
		)
	}
	toString() {
		return this.intro + this.content + this.outro
	}
	trimEnd(e) {
		if (((this.outro = this.outro.replace(e, '')), this.outro.length)) return !0
		const t = this.content.replace(e, '')
		return t.length
			? (t !== this.content && (this.split(this.start + t.length).edit('', void 0, !0), this.edited && this.edit(t, this.storeName, !0)), !0)
			: (this.edit('', void 0, !0), (this.intro = this.intro.replace(e, '')), !!this.intro.length || void 0)
	}
	trimStart(e) {
		if (((this.intro = this.intro.replace(e, '')), this.intro.length)) return !0
		const t = this.content.replace(e, '')
		if (t.length) {
			if (t !== this.content) {
				const e = this.split(this.end - t.length)
				this.edited && e.edit(t, this.storeName, !0), this.edit('', void 0, !0)
			}
			return !0
		}
		return this.edit('', void 0, !0), (this.outro = this.outro.replace(e, '')), !!this.outro.length || void 0
	}
}
function o() {
	return 'undefined' != typeof window && 'function' == typeof window.btoa
		? (e) => window.btoa(unescape(encodeURIComponent(e)))
		: 'function' == typeof Buffer
		? (e) => Buffer.from(e, 'utf-8').toString('base64')
		: () => {
				throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.')
		  }
}
const a = o()
class l {
	constructor(e) {
		;(this.version = 3),
			(this.file = e.file),
			(this.sources = e.sources),
			(this.sourcesContent = e.sourcesContent),
			(this.names = e.names),
			(this.mappings = i.encode(e.mappings)),
			void 0 !== e.x_google_ignoreList && (this.x_google_ignoreList = e.x_google_ignoreList)
	}
	toString() {
		return JSON.stringify(this)
	}
	toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + a(this.toString())
	}
}
function c(e, t) {
	const s = e.split(/[/\\]/),
		i = t.split(/[/\\]/)
	for (s.pop(); s[0] === i[0]; ) s.shift(), i.shift()
	if (s.length) {
		let e = s.length
		for (; e--; ) s[e] = '..'
	}
	return s.concat(i).join('/')
}
const h = Object.prototype.toString
function u(e) {
	return '[object Object]' === h.call(e)
}
function d(e) {
	const t = e.split('\n'),
		s = []
	for (let e = 0, i = 0; e < t.length; e++) s.push(i), (i += t[e].length + 1)
	return function (e) {
		let t = 0,
			i = s.length
		for (; t < i; ) {
			const n = (t + i) >> 1
			e < s[n] ? (i = n) : (t = n + 1)
		}
		const n = t - 1
		return { line: n, column: e - s[n] }
	}
}
const p = /\w/
class f {
	constructor(e) {
		;(this.hires = e), (this.generatedCodeLine = 0), (this.generatedCodeColumn = 0), (this.raw = []), (this.rawSegments = this.raw[this.generatedCodeLine] = []), (this.pending = null)
	}
	addEdit(e, t, s, i) {
		if (t.length) {
			const t = [this.generatedCodeColumn, e, s.line, s.column]
			i >= 0 && t.push(i), this.rawSegments.push(t)
		} else this.pending && this.rawSegments.push(this.pending)
		this.advance(t), (this.pending = null)
	}
	addUneditedChunk(e, t, s, i, n) {
		let r = t.start,
			o = !0,
			a = !1
		for (; r < t.end; ) {
			if (this.hires || o || n.has(r)) {
				const t = [this.generatedCodeColumn, e, i.line, i.column]
				'boundary' === this.hires ? (p.test(s[r]) ? a || (this.rawSegments.push(t), (a = !0)) : (this.rawSegments.push(t), (a = !1))) : this.rawSegments.push(t)
			}
			'\n' === s[r]
				? ((i.line += 1), (i.column = 0), (this.generatedCodeLine += 1), (this.raw[this.generatedCodeLine] = this.rawSegments = []), (this.generatedCodeColumn = 0), (o = !0))
				: ((i.column += 1), (this.generatedCodeColumn += 1), (o = !1)),
				(r += 1)
		}
		this.pending = null
	}
	advance(e) {
		if (!e) return
		const t = e.split('\n')
		if (t.length > 1) {
			for (let e = 0; e < t.length - 1; e++) this.generatedCodeLine++, (this.raw[this.generatedCodeLine] = this.rawSegments = [])
			this.generatedCodeColumn = 0
		}
		this.generatedCodeColumn += t[t.length - 1].length
	}
}
const m = '\n',
	g = { insertLeft: !1, insertRight: !1, storeName: !1 }
class y {
	constructor(e, t = {}) {
		const s = new r(0, e.length, e)
		Object.defineProperties(this, {
			original: { writable: !0, value: e },
			outro: { writable: !0, value: '' },
			intro: { writable: !0, value: '' },
			firstChunk: { writable: !0, value: s },
			lastChunk: { writable: !0, value: s },
			lastSearchedChunk: { writable: !0, value: s },
			byStart: { writable: !0, value: {} },
			byEnd: { writable: !0, value: {} },
			filename: { writable: !0, value: t.filename },
			indentExclusionRanges: { writable: !0, value: t.indentExclusionRanges },
			sourcemapLocations: { writable: !0, value: new n() },
			storedNames: { writable: !0, value: {} },
			indentStr: { writable: !0, value: void 0 },
			ignoreList: { writable: !0, value: t.ignoreList }
		}),
			(this.byStart[0] = s),
			(this.byEnd[e.length] = s)
	}
	addSourcemapLocation(e) {
		this.sourcemapLocations.add(e)
	}
	append(e) {
		if ('string' != typeof e) throw new TypeError('outro content must be a string')
		return (this.outro += e), this
	}
	appendLeft(e, t) {
		if ('string' != typeof t) throw new TypeError('inserted content must be a string')
		this._split(e)
		const s = this.byEnd[e]
		return s ? s.appendLeft(t) : (this.intro += t), this
	}
	appendRight(e, t) {
		if ('string' != typeof t) throw new TypeError('inserted content must be a string')
		this._split(e)
		const s = this.byStart[e]
		return s ? s.appendRight(t) : (this.outro += t), this
	}
	clone() {
		const e = new y(this.original, { filename: this.filename })
		let t = this.firstChunk,
			s = (e.firstChunk = e.lastSearchedChunk = t.clone())
		for (; t; ) {
			;(e.byStart[s.start] = s), (e.byEnd[s.end] = s)
			const i = t.next,
				n = i && i.clone()
			n && ((s.next = n), (n.previous = s), (s = n)), (t = i)
		}
		return (
			(e.lastChunk = s),
			this.indentExclusionRanges && (e.indentExclusionRanges = this.indentExclusionRanges.slice()),
			(e.sourcemapLocations = new n(this.sourcemapLocations)),
			(e.intro = this.intro),
			(e.outro = this.outro),
			e
		)
	}
	generateDecodedMap(e) {
		e = e || {}
		const t = Object.keys(this.storedNames),
			s = new f(e.hires),
			i = d(this.original)
		return (
			this.intro && s.advance(this.intro),
			this.firstChunk.eachNext((e) => {
				const n = i(e.start)
				e.intro.length && s.advance(e.intro),
					e.edited ? s.addEdit(0, e.content, n, e.storeName ? t.indexOf(e.original) : -1) : s.addUneditedChunk(0, e, this.original, n, this.sourcemapLocations),
					e.outro.length && s.advance(e.outro)
			}),
			{
				file: e.file ? e.file.split(/[/\\]/).pop() : void 0,
				sources: [e.source ? c(e.file || '', e.source) : e.file || ''],
				sourcesContent: e.includeContent ? [this.original] : void 0,
				names: t,
				mappings: s.raw,
				x_google_ignoreList: this.ignoreList ? [0] : void 0
			}
		)
	}
	generateMap(e) {
		return new l(this.generateDecodedMap(e))
	}
	_ensureindentStr() {
		void 0 === this.indentStr &&
			(this.indentStr = (function (e) {
				const t = e.split('\n'),
					s = t.filter((e) => /^\t+/.test(e)),
					i = t.filter((e) => /^ {2,}/.test(e))
				if (0 === s.length && 0 === i.length) return null
				if (s.length >= i.length) return '\t'
				const n = i.reduce((e, t) => {
					const s = /^ +/.exec(t)[0].length
					return Math.min(s, e)
				}, 1 / 0)
				return new Array(n + 1).join(' ')
			})(this.original))
	}
	_getRawIndentString() {
		return this._ensureindentStr(), this.indentStr
	}
	getIndentString() {
		return this._ensureindentStr(), null === this.indentStr ? '\t' : this.indentStr
	}
	indent(e, t) {
		const s = /^[^\r\n]/gm
		if ((u(e) && ((t = e), (e = void 0)), void 0 === e && (this._ensureindentStr(), (e = this.indentStr || '\t')), '' === e)) return this
		const i = {}
		if ((t = t || {}).exclude) {
			;('number' == typeof t.exclude[0] ? [t.exclude] : t.exclude).forEach((e) => {
				for (let t = e[0]; t < e[1]; t += 1) i[t] = !0
			})
		}
		let n = !1 !== t.indentStart
		const r = (t) => (n ? `${e}${t}` : ((n = !0), t))
		this.intro = this.intro.replace(s, r)
		let o = 0,
			a = this.firstChunk
		for (; a; ) {
			const t = a.end
			if (a.edited) i[o] || ((a.content = a.content.replace(s, r)), a.content.length && (n = '\n' === a.content[a.content.length - 1]))
			else
				for (o = a.start; o < t; ) {
					if (!i[o]) {
						const t = this.original[o]
						'\n' === t ? (n = !0) : '\r' !== t && n && ((n = !1), o === a.start || (this._splitChunk(a, o), (a = a.next)), a.prependRight(e))
					}
					o += 1
				}
			;(o = a.end), (a = a.next)
		}
		return (this.outro = this.outro.replace(s, r)), this
	}
	insert() {
		throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)')
	}
	insertLeft(e, t) {
		return g.insertLeft || (console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'), (g.insertLeft = !0)), this.appendLeft(e, t)
	}
	insertRight(e, t) {
		return g.insertRight || (console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'), (g.insertRight = !0)), this.prependRight(e, t)
	}
	move(e, t, s) {
		if (s >= e && s <= t) throw new Error('Cannot move a selection inside itself')
		this._split(e), this._split(t), this._split(s)
		const i = this.byStart[e],
			n = this.byEnd[t],
			r = i.previous,
			o = n.next,
			a = this.byStart[s]
		if (!a && n === this.lastChunk) return this
		const l = a ? a.previous : this.lastChunk
		return (
			r && (r.next = o),
			o && (o.previous = r),
			l && (l.next = i),
			a && (a.previous = n),
			i.previous || (this.firstChunk = n.next),
			n.next || ((this.lastChunk = i.previous), (this.lastChunk.next = null)),
			(i.previous = l),
			(n.next = a || null),
			l || (this.firstChunk = i),
			a || (this.lastChunk = n),
			this
		)
	}
	overwrite(e, t, s, i) {
		return (i = i || {}), this.update(e, t, s, { ...i, overwrite: !i.contentOnly })
	}
	update(e, t, s, i) {
		if ('string' != typeof s) throw new TypeError('replacement content must be a string')
		for (; e < 0; ) e += this.original.length
		for (; t < 0; ) t += this.original.length
		if (t > this.original.length) throw new Error('end is out of bounds')
		if (e === t) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead')
		this._split(e),
			this._split(t),
			!0 === i &&
				(g.storeName || (console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'), (g.storeName = !0)),
				(i = { storeName: !0 }))
		const n = void 0 !== i && i.storeName,
			o = void 0 !== i && i.overwrite
		if (n) {
			const s = this.original.slice(e, t)
			Object.defineProperty(this.storedNames, s, { writable: !0, value: !0, enumerable: !0 })
		}
		const a = this.byStart[e],
			l = this.byEnd[t]
		if (a) {
			let e = a
			for (; e !== l; ) {
				if (e.next !== this.byStart[e.end]) throw new Error('Cannot overwrite across a split point')
				;(e = e.next), e.edit('', !1)
			}
			a.edit(s, n, !o)
		} else {
			const i = new r(e, t, '').edit(s, n)
			;(l.next = i), (i.previous = l)
		}
		return this
	}
	prepend(e) {
		if ('string' != typeof e) throw new TypeError('outro content must be a string')
		return (this.intro = e + this.intro), this
	}
	prependLeft(e, t) {
		if ('string' != typeof t) throw new TypeError('inserted content must be a string')
		this._split(e)
		const s = this.byEnd[e]
		return s ? s.prependLeft(t) : (this.intro = t + this.intro), this
	}
	prependRight(e, t) {
		if ('string' != typeof t) throw new TypeError('inserted content must be a string')
		this._split(e)
		const s = this.byStart[e]
		return s ? s.prependRight(t) : (this.outro = t + this.outro), this
	}
	remove(e, t) {
		for (; e < 0; ) e += this.original.length
		for (; t < 0; ) t += this.original.length
		if (e === t) return this
		if (e < 0 || t > this.original.length) throw new Error('Character is out of bounds')
		if (e > t) throw new Error('end must be greater than start')
		this._split(e), this._split(t)
		let s = this.byStart[e]
		for (; s; ) (s.intro = ''), (s.outro = ''), s.edit(''), (s = t > s.end ? this.byStart[s.end] : null)
		return this
	}
	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1]
		let e = this.lastChunk
		do {
			if (e.outro.length) return e.outro[e.outro.length - 1]
			if (e.content.length) return e.content[e.content.length - 1]
			if (e.intro.length) return e.intro[e.intro.length - 1]
		} while ((e = e.previous))
		return this.intro.length ? this.intro[this.intro.length - 1] : ''
	}
	lastLine() {
		let e = this.outro.lastIndexOf(m)
		if (-1 !== e) return this.outro.substr(e + 1)
		let t = this.outro,
			s = this.lastChunk
		do {
			if (s.outro.length > 0) {
				if (((e = s.outro.lastIndexOf(m)), -1 !== e)) return s.outro.substr(e + 1) + t
				t = s.outro + t
			}
			if (s.content.length > 0) {
				if (((e = s.content.lastIndexOf(m)), -1 !== e)) return s.content.substr(e + 1) + t
				t = s.content + t
			}
			if (s.intro.length > 0) {
				if (((e = s.intro.lastIndexOf(m)), -1 !== e)) return s.intro.substr(e + 1) + t
				t = s.intro + t
			}
		} while ((s = s.previous))
		return (e = this.intro.lastIndexOf(m)), -1 !== e ? this.intro.substr(e + 1) + t : this.intro + t
	}
	slice(e = 0, t = this.original.length) {
		for (; e < 0; ) e += this.original.length
		for (; t < 0; ) t += this.original.length
		let s = '',
			i = this.firstChunk
		for (; i && (i.start > e || i.end <= e); ) {
			if (i.start < t && i.end >= t) return s
			i = i.next
		}
		if (i && i.edited && i.start !== e) throw new Error(`Cannot use replaced character ${e} as slice start anchor.`)
		const n = i
		for (; i; ) {
			!i.intro || (n === i && i.start !== e) || (s += i.intro)
			const r = i.start < t && i.end >= t
			if (r && i.edited && i.end !== t) throw new Error(`Cannot use replaced character ${t} as slice end anchor.`)
			const o = n === i ? e - i.start : 0,
				a = r ? i.content.length + t - i.end : i.content.length
			if (((s += i.content.slice(o, a)), !i.outro || (r && i.end !== t) || (s += i.outro), r)) break
			i = i.next
		}
		return s
	}
	snip(e, t) {
		const s = this.clone()
		return s.remove(0, e), s.remove(t, s.original.length), s
	}
	_split(e) {
		if (this.byStart[e] || this.byEnd[e]) return
		let t = this.lastSearchedChunk
		const s = e > t.end
		for (; t; ) {
			if (t.contains(e)) return this._splitChunk(t, e)
			t = s ? this.byStart[t.end] : this.byEnd[t.start]
		}
	}
	_splitChunk(e, t) {
		if (e.edited && e.content.length) {
			const s = d(this.original)(t)
			throw new Error(`Cannot split a chunk that has already been edited (${s.line}:${s.column} – "${e.original}")`)
		}
		const s = e.split(t)
		return (this.byEnd[t] = e), (this.byStart[t] = s), (this.byEnd[s.end] = s), e === this.lastChunk && (this.lastChunk = s), (this.lastSearchedChunk = e), !0
	}
	toString() {
		let e = this.intro,
			t = this.firstChunk
		for (; t; ) (e += t.toString()), (t = t.next)
		return e + this.outro
	}
	isEmpty() {
		let e = this.firstChunk
		do {
			if ((e.intro.length && e.intro.trim()) || (e.content.length && e.content.trim()) || (e.outro.length && e.outro.trim())) return !1
		} while ((e = e.next))
		return !0
	}
	length() {
		let e = this.firstChunk,
			t = 0
		do {
			t += e.intro.length + e.content.length + e.outro.length
		} while ((e = e.next))
		return t
	}
	trimLines() {
		return this.trim('[\\r\\n]')
	}
	trim(e) {
		return this.trimStart(e).trimEnd(e)
	}
	trimEndAborted(e) {
		const t = new RegExp((e || '\\s') + '+$')
		if (((this.outro = this.outro.replace(t, '')), this.outro.length)) return !0
		let s = this.lastChunk
		do {
			const e = s.end,
				i = s.trimEnd(t)
			if ((s.end !== e && (this.lastChunk === s && (this.lastChunk = s.next), (this.byEnd[s.end] = s), (this.byStart[s.next.start] = s.next), (this.byEnd[s.next.end] = s.next)), i)) return !0
			s = s.previous
		} while (s)
		return !1
	}
	trimEnd(e) {
		return this.trimEndAborted(e), this
	}
	trimStartAborted(e) {
		const t = new RegExp('^' + (e || '\\s') + '+')
		if (((this.intro = this.intro.replace(t, '')), this.intro.length)) return !0
		let s = this.firstChunk
		do {
			const e = s.end,
				i = s.trimStart(t)
			if ((s.end !== e && (s === this.lastChunk && (this.lastChunk = s.next), (this.byEnd[s.end] = s), (this.byStart[s.next.start] = s.next), (this.byEnd[s.next.end] = s.next)), i)) return !0
			s = s.next
		} while (s)
		return !1
	}
	trimStart(e) {
		return this.trimStartAborted(e), this
	}
	hasChanged() {
		return this.original !== this.toString()
	}
	_replaceRegexp(e, t) {
		function s(e, s) {
			return 'string' == typeof t
				? t.replace(/\$(\$|&|\d+)/g, (t, s) => {
						if ('$' === s) return '$'
						if ('&' === s) return e[0]
						return +s < e.length ? e[+s] : `$${s}`
				  })
				: t(...e, e.index, s, e.groups)
		}
		if (e.global) {
			;(function (e, t) {
				let s
				const i = []
				for (; (s = e.exec(t)); ) i.push(s)
				return i
			})(e, this.original).forEach((e) => {
				null != e.index && this.overwrite(e.index, e.index + e[0].length, s(e, this.original))
			})
		} else {
			const t = this.original.match(e)
			t && null != t.index && this.overwrite(t.index, t.index + t[0].length, s(t, this.original))
		}
		return this
	}
	_replaceString(e, t) {
		const { original: s } = this,
			i = s.indexOf(e)
		return -1 !== i && this.overwrite(i, i + e.length, t), this
	}
	replace(e, t) {
		return 'string' == typeof e ? this._replaceString(e, t) : this._replaceRegexp(e, t)
	}
	_replaceAllString(e, t) {
		const { original: s } = this,
			i = e.length
		for (let n = s.indexOf(e); -1 !== n; n = s.indexOf(e, n + i)) this.overwrite(n, n + i, t)
		return this
	}
	replaceAll(e, t) {
		if ('string' == typeof e) return this._replaceAllString(e, t)
		if (!e.global) throw new TypeError('MagicString.prototype.replaceAll called with a non-global RegExp argument')
		return this._replaceRegexp(e, t)
	}
}
const x = Object.prototype.hasOwnProperty
let E = class e {
	constructor(e = {}) {
		;(this.intro = e.intro || ''), (this.separator = void 0 !== e.separator ? e.separator : '\n'), (this.sources = []), (this.uniqueSources = []), (this.uniqueSourceIndexByFilename = {})
	}
	addSource(e) {
		if (e instanceof y) return this.addSource({ content: e, filename: e.filename, separator: this.separator })
		if (!u(e) || !e.content) throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`')
		if (
			(['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((t) => {
				x.call(e, t) || (e[t] = e.content[t])
			}),
			void 0 === e.separator && (e.separator = this.separator),
			e.filename)
		)
			if (x.call(this.uniqueSourceIndexByFilename, e.filename)) {
				const t = this.uniqueSources[this.uniqueSourceIndexByFilename[e.filename]]
				if (e.content.original !== t.content) throw new Error(`Illegal source: same filename (${e.filename}), different contents`)
			} else (this.uniqueSourceIndexByFilename[e.filename] = this.uniqueSources.length), this.uniqueSources.push({ filename: e.filename, content: e.content.original })
		return this.sources.push(e), this
	}
	append(e, t) {
		return this.addSource({ content: new y(e), separator: (t && t.separator) || '' }), this
	}
	clone() {
		const t = new e({ intro: this.intro, separator: this.separator })
		return (
			this.sources.forEach((e) => {
				t.addSource({ filename: e.filename, content: e.content.clone(), separator: e.separator })
			}),
			t
		)
	}
	generateDecodedMap(e = {}) {
		const t = []
		let s
		this.sources.forEach((e) => {
			Object.keys(e.content.storedNames).forEach((e) => {
				~t.indexOf(e) || t.push(e)
			})
		})
		const i = new f(e.hires)
		return (
			this.intro && i.advance(this.intro),
			this.sources.forEach((e, n) => {
				n > 0 && i.advance(this.separator)
				const r = e.filename ? this.uniqueSourceIndexByFilename[e.filename] : -1,
					o = e.content,
					a = d(o.original)
				o.intro && i.advance(o.intro),
					o.firstChunk.eachNext((s) => {
						const n = a(s.start)
						s.intro.length && i.advance(s.intro),
							e.filename ? (s.edited ? i.addEdit(r, s.content, n, s.storeName ? t.indexOf(s.original) : -1) : i.addUneditedChunk(r, s, o.original, n, o.sourcemapLocations)) : i.advance(s.content),
							s.outro.length && i.advance(s.outro)
					}),
					o.outro && i.advance(o.outro),
					e.ignoreList && -1 !== r && (void 0 === s && (s = []), s.push(r))
			}),
			{
				file: e.file ? e.file.split(/[/\\]/).pop() : void 0,
				sources: this.uniqueSources.map((t) => (e.file ? c(e.file, t.filename) : t.filename)),
				sourcesContent: this.uniqueSources.map((t) => (e.includeContent ? t.content : null)),
				names: t,
				mappings: i.raw,
				x_google_ignoreList: s
			}
		)
	}
	generateMap(e) {
		return new l(this.generateDecodedMap(e))
	}
	getIndentString() {
		const e = {}
		return (
			this.sources.forEach((t) => {
				const s = t.content._getRawIndentString()
				null !== s && (e[s] || (e[s] = 0), (e[s] += 1))
			}),
			Object.keys(e).sort((t, s) => e[t] - e[s])[0] || '\t'
		)
	}
	indent(e) {
		if ((arguments.length || (e = this.getIndentString()), '' === e)) return this
		let t = !this.intro || '\n' === this.intro.slice(-1)
		return (
			this.sources.forEach((s, i) => {
				const n = void 0 !== s.separator ? s.separator : this.separator,
					r = t || (i > 0 && /\r?\n$/.test(n))
				s.content.indent(e, { exclude: s.indentExclusionRanges, indentStart: r }), (t = '\n' === s.content.lastChar())
			}),
			this.intro && (this.intro = e + this.intro.replace(/^[^\n]/gm, (t, s) => (s > 0 ? e + t : t))),
			this
		)
	}
	prepend(e) {
		return (this.intro = e + this.intro), this
	}
	toString() {
		const e = this.sources
			.map((e, t) => {
				const s = void 0 !== e.separator ? e.separator : this.separator
				return (t > 0 ? s : '') + e.content.toString()
			})
			.join('')
		return this.intro + e
	}
	isEmpty() {
		return (!this.intro.length || !this.intro.trim()) && !this.sources.some((e) => !e.content.isEmpty())
	}
	length() {
		return this.sources.reduce((e, t) => e + t.content.length(), this.intro.length)
	}
	trimLines() {
		return this.trim('[\\r\\n]')
	}
	trim(e) {
		return this.trimStart(e).trimEnd(e)
	}
	trimStart(e) {
		const t = new RegExp('^' + (e || '\\s') + '+')
		if (((this.intro = this.intro.replace(t, '')), !this.intro)) {
			let t,
				s = 0
			do {
				if (((t = this.sources[s++]), !t)) break
			} while (!t.content.trimStartAborted(e))
		}
		return this
	}
	trimEnd(e) {
		const t = new RegExp((e || '\\s') + '+$')
		let s,
			i = this.sources.length - 1
		do {
			if (((s = this.sources[i--]), !s)) {
				this.intro = this.intro.replace(t, '')
				break
			}
		} while (!s.content.trimEndAborted(e))
		return this
	}
}
const b = /^(?:\/|(?:[A-Za-z]:)?[/\\|])/,
	v = /^\.?\.\//,
	S = /\\/g,
	A = /[/\\]/,
	k = /\.[^.]+$/
function I(e) {
	return b.test(e)
}
function w(e) {
	return v.test(e)
}
function P(e) {
	return e.replace(S, '/')
}
function C(e) {
	return e.split(A).pop() || ''
}
function $(e) {
	const t = /[/\\][^/\\]*$/.exec(e)
	if (!t) return '.'
	return e.slice(0, -t[0].length) || '/'
}
function N(e) {
	const t = k.exec(C(e))
	return t ? t[0] : ''
}
function _(e, t) {
	const s = e.split(A).filter(Boolean),
		i = t.split(A).filter(Boolean)
	for ('.' === s[0] && s.shift(), '.' === i[0] && i.shift(); s[0] && i[0] && s[0] === i[0]; ) s.shift(), i.shift()
	for (; '..' === i[0] && s.length > 0; ) i.shift(), s.pop()
	for (; s.pop(); ) i.unshift('..')
	return i.join('/')
}
function R(...e) {
	const t = e.shift()
	if (!t) return '/'
	let s = t.split(A)
	for (const t of e)
		if (I(t)) s = t.split(A)
		else {
			const e = t.split(A)
			for (; '.' === e[0] || '..' === e[0]; ) {
				'..' === e.shift() && s.pop()
			}
			s.push(...e)
		}
	return s.join('/')
}
const M = /[\n\r'\\\u2028\u2029]/,
	O = /([\n\r'\u2028\u2029])/g,
	D = /\\/g
function L(e) {
	return M.test(e) ? e.replace(D, '\\\\').replace(O, '\\$1') : e
}
function T(e) {
	const t = C(e)
	return t.slice(0, Math.max(0, t.length - N(e).length))
}
function V(e) {
	return I(e) ? _(R(), e) : e
}
function B(e) {
	return '/' === e[0] || ('.' === e[0] && ('/' === e[1] || '.' === e[1])) || I(e)
}
const z = /^(\.\.\/)*\.\.$/
function F(e, t, s, i) {
	for (; t.startsWith('../'); ) (t = t.slice(3)), (e = '_/' + e)
	let n = P(_($(e), t))
	if ((s && n.endsWith('.js') && (n = n.slice(0, -3)), i)) {
		if ('' === n) return '../' + C(t)
		if (z.test(n)) return [...n.split('/'), '..', C(t)].join('/')
	}
	return n ? (n.startsWith('..') ? n : './' + n) : '.'
}
class j {
	constructor(e, t, s) {
		;(this.options = t),
			(this.inputBase = s),
			(this.defaultVariableName = ''),
			(this.namespaceVariableName = ''),
			(this.variableName = ''),
			(this.fileName = null),
			(this.importAssertions = null),
			(this.id = e.id),
			(this.moduleInfo = e.info),
			(this.renormalizeRenderPath = e.renormalizeRenderPath),
			(this.suggestedVariableName = e.suggestedVariableName)
	}
	getFileName() {
		if (this.fileName) return this.fileName
		const { paths: e } = this.options
		return (this.fileName = ('function' == typeof e ? e(this.id) : e[this.id]) || (this.renormalizeRenderPath ? P(_(this.inputBase, this.id)) : this.id))
	}
	getImportAssertions(e) {
		return (
			this.importAssertions ||
			(this.importAssertions = (function (e, { getObject: t }) {
				if (!e) return null
				const s = Object.entries(e).map(([e, t]) => [e, `'${t}'`])
				if (s.length > 0) return t(s, { lineBreakIndent: null })
				return null
			})('es' === this.options.format && this.options.externalImportAssertions && this.moduleInfo.assertions, e))
		)
	}
	getImportPath(e) {
		return L(this.renormalizeRenderPath ? F(e, this.getFileName(), 'amd' === this.options.format, !1) : this.getFileName())
	}
}
function U(e, t, s) {
	const i = e.get(t)
	if (void 0 !== i) return i
	const n = s()
	return e.set(t, n), n
}
function G() {
	return new Set()
}
function W() {
	return []
}
const q = Symbol('Unknown Key'),
	H = Symbol('Unknown Non-Accessor Key'),
	K = Symbol('Unknown Integer'),
	Y = Symbol('Symbol.toStringTag'),
	X = [],
	Q = [q],
	Z = [H],
	J = [K],
	ee = Symbol('Entities')
class te {
	constructor() {
		this.entityPaths = Object.create(null, { [ee]: { value: new Set() } })
	}
	trackEntityAtPathAndGetIfTracked(e, t) {
		const s = this.getEntities(e)
		return !!s.has(t) || (s.add(t), !1)
	}
	withTrackedEntityAtPath(e, t, s, i) {
		const n = this.getEntities(e)
		if (n.has(t)) return i
		n.add(t)
		const r = s()
		return n.delete(t), r
	}
	getEntities(e) {
		let t = this.entityPaths
		for (const s of e) t = t[s] = t[s] || Object.create(null, { [ee]: { value: new Set() } })
		return t[ee]
	}
}
const se = new te()
class ie {
	constructor() {
		this.entityPaths = Object.create(null, { [ee]: { value: new Map() } })
	}
	trackEntityAtPathAndGetIfTracked(e, t, s) {
		let i = this.entityPaths
		for (const t of e) i = i[t] = i[t] || Object.create(null, { [ee]: { value: new Map() } })
		const n = U(i[ee], t, G)
		return !!n.has(s) || (n.add(s), !1)
	}
}
const ne = Symbol('Unknown Value'),
	re = Symbol('Unknown Truthy Value')
class oe {
	constructor() {
		this.included = !1
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		ce(e)
	}
	deoptimizePath(e) {}
	getLiteralValueAtPath(e, t, s) {
		return ne
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return le
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return !0
	}
	include(e, t, s) {
		this.included = !0
	}
	includeCallArguments(e, t) {
		for (const s of t) s.include(e, !1)
	}
	shouldBeIncluded(e) {
		return !0
	}
}
const ae = new (class extends oe {})(),
	le = [ae, !1],
	ce = (e) => {
		for (const t of e.args) t?.deoptimizePath(Q)
	},
	he = { args: [null], type: 0 },
	ue = { args: [null, ae], type: 1 },
	de = { args: [null], type: 2, withNew: !1 }
class pe extends oe {
	constructor(e) {
		super(),
			(this.name = e),
			(this.alwaysRendered = !1),
			(this.forbiddenNames = null),
			(this.initReached = !1),
			(this.isId = !1),
			(this.isReassigned = !1),
			(this.kind = null),
			(this.renderBaseName = null),
			(this.renderName = null)
	}
	addReference(e) {}
	forbidName(e) {
		;(this.forbiddenNames || (this.forbiddenNames = new Set())).add(e)
	}
	getBaseVariableName() {
		return this.renderBaseName || this.renderName || this.name
	}
	getName(e, t) {
		if (t?.(this)) return this.name
		const s = this.renderName || this.name
		return this.renderBaseName ? `${this.renderBaseName}${e(s)}` : s
	}
	hasEffectsOnInteractionAtPath(e, { type: t }, s) {
		return 0 !== t || e.length > 0
	}
	include() {
		this.included = !0
	}
	markCalledFromTryStatement() {}
	setRenderNames(e, t) {
		;(this.renderBaseName = e), (this.renderName = t)
	}
}
class fe extends pe {
	constructor(e, t) {
		super(t), (this.referenced = !1), (this.module = e), (this.isNamespace = '*' === t)
	}
	addReference(e) {
		;(this.referenced = !0), ('default' !== this.name && '*' !== this.name) || this.module.suggestName(e.name)
	}
	hasEffectsOnInteractionAtPath(e, { type: t }) {
		return 0 !== t || e.length > (this.isNamespace ? 1 : 0)
	}
	include() {
		this.included || ((this.included = !0), (this.module.used = !0))
	}
}
const me = Object.freeze(Object.create(null)),
	ge = Object.freeze({}),
	ye = Object.freeze([]),
	xe = Object.freeze(
		new (class extends Set {
			add() {
				throw new Error('Cannot add to empty set')
			}
		})()
	)
var Ee = new Set([
	'await',
	'break',
	'case',
	'catch',
	'class',
	'const',
	'continue',
	'debugger',
	'default',
	'delete',
	'do',
	'else',
	'enum',
	'eval',
	'export',
	'extends',
	'false',
	'finally',
	'for',
	'function',
	'if',
	'implements',
	'import',
	'in',
	'instanceof',
	'interface',
	'let',
	'NaN',
	'new',
	'null',
	'package',
	'private',
	'protected',
	'public',
	'return',
	'static',
	'super',
	'switch',
	'this',
	'throw',
	'true',
	'try',
	'typeof',
	'undefined',
	'var',
	'void',
	'while',
	'with',
	'yield'
])
const be = /[^\w$]/g,
	ve = (e) => ((e) => /\d/.test(e[0]))(e) || Ee.has(e) || 'arguments' === e
function Se(e) {
	return (e = e.replace(/-(\w)/g, (e, t) => t.toUpperCase()).replace(be, '_')), ve(e) && (e = `_${e}`), e || '_'
}
const Ae = 'warn',
	ke = 'info',
	Ie = 'debug',
	we = { [Ie]: 0, [ke]: 1, silent: 3, [Ae]: 2 }
function Pe(e, t) {
	return e.start <= t && t < e.end
}
function Ce(e, t, s) {
	return (function (e, t = {}) {
		const { offsetLine: s = 0, offsetColumn: i = 0 } = t
		let n = 0
		const r = e.split('\n').map((e, t) => {
			const s = n + e.length + 1,
				i = { start: n, end: s, line: t }
			return (n = s), i
		})
		let o = 0
		return function (t, n) {
			if (('string' == typeof t && (t = e.indexOf(t, n ?? 0)), -1 === t)) return
			let a = r[o]
			const l = t >= a.end ? 1 : -1
			for (; a; ) {
				if (Pe(a, t)) return { line: s + a.line, column: i + t - a.start, character: t }
				;(o += l), (a = r[o])
			}
		}
	})(e, s)(t, s && s.startIndex)
}
function $e(e) {
	return e.replace(/^\t+/, (e) => e.split('\t').join('  '))
}
const Ne = 120,
	_e = 10,
	Re = '...'
function Me(e, t, s) {
	let i = e.split('\n')
	if (t > i.length) return ''
	const n = Math.max($e(i[t - 1].slice(0, s)).length + _e + Re.length, Ne),
		r = Math.max(0, t - 3)
	let o = Math.min(t + 2, i.length)
	for (i = i.slice(r, o); !/\S/.test(i[i.length - 1]); ) i.pop(), (o -= 1)
	const a = String(o).length
	return i
		.map((e, i) => {
			const o = r + i + 1 === t
			let l = String(i + r + 1)
			for (; l.length < a; ) l = ` ${l}`
			let c = $e(e)
			if ((c.length > n && (c = `${c.slice(0, n - Re.length)}${Re}`), o)) {
				const t =
					(function (e) {
						let t = ''
						for (; e--; ) t += ' '
						return t
					})(a + 2 + $e(e.slice(0, s)).length) + '^'
				return `${l}: ${c}\n${t}`
			}
			return `${l}: ${c}`
		})
		.join('\n')
}
function Oe(e, t) {
	const s = e.length <= 1,
		i = e.map((e) => `"${e}"`)
	let n = s ? i[0] : `${i.slice(0, -1).join(', ')} and ${i.slice(-1)[0]}`
	return t && (n += ` ${s ? t[0] : t[1]}`), n
}
function De(e) {
	return `https://rollupjs.org/${e}`
}
const Le = 'troubleshooting/#error-name-is-not-exported-by-module',
	Te = 'troubleshooting/#warning-sourcemap-is-likely-to-be-incorrect',
	Ve = 'configuration-options/#output-amd-id',
	Be = 'configuration-options/#output-dir',
	ze = 'configuration-options/#output-exports',
	Fe = 'configuration-options/#output-extend',
	je = 'configuration-options/#output-format',
	Ue = 'configuration-options/#output-experimentaldeepdynamicchunkoptimization',
	Ge = 'configuration-options/#output-globals',
	We = 'configuration-options/#output-inlinedynamicimports',
	qe = 'configuration-options/#output-interop',
	He = 'configuration-options/#output-manualchunks',
	Ke = 'configuration-options/#output-name',
	Ye = 'configuration-options/#output-sourcemapfile',
	Xe = 'plugin-development/#this-getmoduleinfo'
function Qe(e) {
	throw (e instanceof Error || ((e = Object.assign(new Error(e.message), e)), Object.defineProperty(e, 'name', { value: 'RollupError' })), e)
}
function Ze(e, t, s, i) {
	if ('object' == typeof t) {
		const { line: s, column: n } = t
		e.loc = { column: n, file: i, line: s }
	} else {
		e.pos = t
		const { line: n, column: r } = Ce(s, t, { offsetLine: 1 })
		e.loc = { column: r, file: i, line: n }
	}
	if (void 0 === e.frame) {
		const { line: t, column: i } = e.loc
		e.frame = Me(s, t, i)
	}
}
const Je = 'ADDON_ERROR',
	et = 'ALREADY_CLOSED',
	tt = 'ANONYMOUS_PLUGIN_CACHE',
	st = 'ASSET_NOT_FINALISED',
	it = 'CANNOT_EMIT_FROM_OPTIONS_HOOK',
	nt = 'CHUNK_NOT_GENERATED',
	rt = 'CIRCULAR_REEXPORT',
	ot = 'DEPRECATED_FEATURE',
	at = 'DUPLICATE_PLUGIN_NAME',
	lt = 'FILE_NAME_CONFLICT',
	ct = 'ILLEGAL_IDENTIFIER_AS_NAME',
	ht = 'INVALID_CHUNK',
	ut = 'INVALID_EXPORT_OPTION',
	dt = 'INVALID_LOG_POSITION',
	pt = 'INVALID_OPTION',
	ft = 'INVALID_PLUGIN_HOOK',
	mt = 'INVALID_ROLLUP_PHASE',
	gt = 'INVALID_SETASSETSOURCE',
	yt = 'MISSING_EXPORT',
	xt = 'MISSING_GLOBAL_NAME',
	Et = 'MISSING_IMPLICIT_DEPENDANT',
	bt = 'MISSING_NAME_OPTION_FOR_IIFE_EXPORT',
	vt = 'MISSING_NODE_BUILTINS',
	St = 'MISSING_OPTION',
	At = 'MIXED_EXPORTS',
	kt = 'NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE',
	It = 'OPTIMIZE_CHUNK_STATUS',
	wt = 'PLUGIN_ERROR',
	Pt = 'SOURCEMAP_BROKEN',
	Ct = 'UNEXPECTED_NAMED_IMPORT',
	$t = 'UNKNOWN_OPTION',
	Nt = 'UNRESOLVED_ENTRY',
	_t = 'UNRESOLVED_IMPORT',
	Rt = 'VALIDATION_ERROR'
function Mt() {
	return { code: et, message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.' }
}
function Ot(e) {
	return { code: 'CANNOT_CALL_NAMESPACE', message: `Cannot call a namespace ("${e}").` }
}
function Dt({ fileName: e, code: t }, s) {
	const i = { code: 'CHUNK_INVALID', message: `Chunk "${e}" is not valid JavaScript: ${s.message}.` }
	return Ze(i, s.loc, t, e), i
}
function Lt(e) {
	return { code: 'CIRCULAR_DEPENDENCY', ids: e, message: `Circular dependency: ${e.map(V).join(' -> ')}` }
}
function Tt(e, t, { line: s, column: i }) {
	return { code: 'FIRST_SIDE_EFFECT', message: `First side effect in ${V(t)} is at (${s}:${i})\n${Me(e, s, i)}` }
}
function Vt(e, t) {
	return { code: 'ILLEGAL_REASSIGNMENT', message: `Illegal reassignment of import "${e}" in "${V(t)}".` }
}
function Bt(e, t, s, i) {
	return {
		code: 'INCONSISTENT_IMPORT_ASSERTIONS',
		message: `Module "${V(i)}" tried to import "${V(s)}" with ${zt(t)} assertions, but it was already imported elsewhere with ${zt(
			e
		)} assertions. Please ensure that import assertions for the same module are always consistent.`
	}
}
const zt = (e) => {
	const t = Object.entries(e)
	return 0 === t.length ? 'no' : t.map(([e, t]) => `"${e}": "${t}"`).join(', ')
}
function Ft(e, t, s) {
	return { code: ut, message: `"${e}" was specified for "output.exports", but entry module "${V(s)}" has the following exports: ${Oe(t)}`, url: De(ze) }
}
function jt(e, t, s, i) {
	return { code: pt, message: `Invalid value ${void 0 === i ? '' : `${JSON.stringify(i)} `}for option "${e}" - ${s}.`, url: De(t) }
}
function Ut(e, t, s) {
	const i = '.json' === N(s)
	return {
		binding: e,
		code: yt,
		exporter: s,
		id: t,
		message: `"${e}" is not exported by "${V(s)}", imported by "${V(t)}".${i ? ' (Note that you need @rollup/plugin-json to import JSON files)' : ''}`,
		url: De(Le)
	}
}
function Gt(e) {
	const t = [...e.implicitlyLoadedBefore].map((e) => V(e.id)).sort()
	return {
		code: Et,
		message: `Module "${V(e.id)}" that should be implicitly loaded before ${Oe(
			t
		)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.`
	}
}
function Wt(e, t, s) {
	return { code: It, message: `${s}, there are\n${e} chunks, of which\n${t} are below minChunkSize.` }
}
function qt(e, t, { hook: s, id: i } = {}) {
	const n = e.code
	return (
		e.pluginCode || null == n || ('string' == typeof n && ('string' != typeof n || n.startsWith('PLUGIN_'))) || (e.pluginCode = n), (e.code = wt), (e.plugin = t), s && (e.hook = s), i && (e.id = i), e
	)
}
function Ht(e) {
	return { code: Pt, message: `Multiple conflicting contents for sourcemap source ${e}` }
}
function Kt(e, t, s) {
	const i = s ? 'reexport' : 'import'
	return {
		code: Ct,
		exporter: e,
		message: `The named export "${t}" was ${i}ed from the external module "${V(
			e
		)}" even though its interop type is "defaultOnly". Either remove or change this ${i} or change the value of the "output.interop" option.`,
		url: De(qe)
	}
}
function Yt(e) {
	return {
		code: Ct,
		exporter: e,
		message: `There was a namespace "*" reexport from the external module "${V(
			e
		)}" even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`,
		url: De(qe)
	}
}
function Xt(e) {
	return { code: Rt, message: e }
}
function Qt(e, t, s, i, n) {
	Zt(e, t, s, i.onLog, i.strictDeprecations, n)
}
function Zt(e, t, s, i, n, r) {
	if (s || n) {
		const s = (function (e, t, s) {
			return { code: ot, message: e, url: De(t), ...(s ? { plugin: s } : {}) }
		})(e, t, r)
		if (n) return Qe(s)
		i(Ae, s)
	}
}
class Jt {
	constructor(e, t, s, i, n, r) {
		;(this.options = e),
			(this.id = t),
			(this.renormalizeRenderPath = n),
			(this.dynamicImporters = []),
			(this.execIndex = 1 / 0),
			(this.exportedVariables = new Map()),
			(this.importers = []),
			(this.reexported = !1),
			(this.used = !1),
			(this.declarations = new Map()),
			(this.mostCommonSuggestion = 0),
			(this.nameSuggestions = new Map()),
			(this.suggestedVariableName = Se(t.split(/[/\\]/).pop()))
		const { importers: o, dynamicImporters: a } = this,
			l = (this.info = {
				assertions: r,
				ast: null,
				code: null,
				dynamicallyImportedIdResolutions: ye,
				dynamicallyImportedIds: ye,
				get dynamicImporters() {
					return a.sort()
				},
				exportedBindings: null,
				exports: null,
				hasDefaultExport: null,
				get hasModuleSideEffects() {
					return Qt('Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.', Xe, !0, e), l.moduleSideEffects
				},
				id: t,
				implicitlyLoadedAfterOneOf: ye,
				implicitlyLoadedBefore: ye,
				importedIdResolutions: ye,
				importedIds: ye,
				get importers() {
					return o.sort()
				},
				isEntry: !1,
				isExternal: !0,
				isIncluded: null,
				meta: i,
				moduleSideEffects: s,
				syntheticNamedExports: !1
			})
		Object.defineProperty(this.info, 'hasModuleSideEffects', { enumerable: !1 })
	}
	getVariableForExportName(e) {
		const t = this.declarations.get(e)
		if (t) return [t]
		const s = new fe(this, e)
		return this.declarations.set(e, s), this.exportedVariables.set(s, e), [s]
	}
	suggestName(e) {
		const t = (this.nameSuggestions.get(e) ?? 0) + 1
		this.nameSuggestions.set(e, t), t > this.mostCommonSuggestion && ((this.mostCommonSuggestion = t), (this.suggestedVariableName = e))
	}
	warnUnusedImports() {
		const e = [...this.declarations].filter(([e, t]) => '*' !== e && !t.included && !this.reexported && !t.referenced).map(([e]) => e)
		if (0 === e.length) return
		const t = new Set()
		for (const s of e) for (const e of this.declarations.get(s).module.importers) t.add(e)
		const s = [...t]
		var i, n, r
		this.options.onLog(Ae, {
			code: 'UNUSED_EXTERNAL_IMPORT',
			exporter: (i = this.id),
			ids: (r = s),
			message: `${Oe((n = e), ['is', 'are'])} imported from external module "${i}" but never used in ${Oe(r.map((e) => V(e)))}.`,
			names: n
		})
	}
}
const es = {
		ArrayPattern(e, t) {
			for (const s of t.elements) s && es[s.type](e, s)
		},
		AssignmentPattern(e, t) {
			es[t.left.type](e, t.left)
		},
		Identifier(e, t) {
			e.push(t.name)
		},
		MemberExpression() {},
		ObjectPattern(e, t) {
			for (const s of t.properties) 'RestElement' === s.type ? es.RestElement(e, s) : es[s.value.type](e, s.value)
		},
		RestElement(e, t) {
			es[t.argument.type](e, t.argument)
		}
	},
	ts = function (e) {
		const t = []
		return es[e.type](t, e), t
	}
function ss() {
	return { brokenFlow: !1, hasBreak: !1, hasContinue: !1, includedCallArguments: new Set(), includedLabels: new Set() }
}
function is() {
	return {
		accessed: new te(),
		assigned: new te(),
		brokenFlow: !1,
		called: new ie(),
		hasBreak: !1,
		hasContinue: !1,
		ignore: { breaks: !1, continues: !1, labels: new Set(), returnYield: !1, this: !1 },
		includedLabels: new Set(),
		instantiated: new ie(),
		replacedVariableInits: new Map()
	}
}
function ns(e, t = null) {
	return Object.create(t, e)
}
new Set(
	'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'.split(
		' '
	)
).add('')
const rs = new (class extends oe {
		getLiteralValueAtPath() {}
	})(),
	os = { value: { hasEffectsWhenCalled: null, returns: ae } },
	as = new (class extends oe {
		getReturnExpressionWhenCalledAtPath(e) {
			return 1 === e.length ? bs(ms, e[0]) : le
		}
		hasEffectsOnInteractionAtPath(e, t, s) {
			return 0 === t.type ? e.length > 1 : 2 !== t.type || 1 !== e.length || Es(ms, e[0], t, s)
		}
	})(),
	ls = { value: { hasEffectsWhenCalled: null, returns: as } },
	cs = new (class extends oe {
		getReturnExpressionWhenCalledAtPath(e) {
			return 1 === e.length ? bs(gs, e[0]) : le
		}
		hasEffectsOnInteractionAtPath(e, t, s) {
			return 0 === t.type ? e.length > 1 : 2 !== t.type || 1 !== e.length || Es(gs, e[0], t, s)
		}
	})(),
	hs = { value: { hasEffectsWhenCalled: null, returns: cs } },
	us = new (class extends oe {
		getReturnExpressionWhenCalledAtPath(e) {
			return 1 === e.length ? bs(xs, e[0]) : le
		}
		hasEffectsOnInteractionAtPath(e, t, s) {
			return 0 === t.type ? e.length > 1 : 2 !== t.type || 1 !== e.length || Es(xs, e[0], t, s)
		}
	})(),
	ds = { value: { hasEffectsWhenCalled: null, returns: us } },
	ps = {
		value: {
			hasEffectsWhenCalled({ args: e }, t) {
				const s = e[2]
				return e.length < 3 || ('symbol' == typeof s.getLiteralValueAtPath(X, se, { deoptimizeCache() {} }) && s.hasEffectsOnInteractionAtPath(X, de, t))
			},
			returns: us
		}
	},
	fs = ns({ hasOwnProperty: ls, isPrototypeOf: ls, propertyIsEnumerable: ls, toLocaleString: ds, toString: ds, valueOf: os }),
	ms = ns({ valueOf: ls }, fs),
	gs = ns({ toExponential: ds, toFixed: ds, toLocaleString: ds, toPrecision: ds, valueOf: hs }, fs),
	ys = ns({ exec: os, test: ls }, fs),
	xs = ns(
		{
			anchor: ds,
			at: os,
			big: ds,
			blink: ds,
			bold: ds,
			charAt: ds,
			charCodeAt: hs,
			codePointAt: os,
			concat: ds,
			endsWith: ls,
			fixed: ds,
			fontcolor: ds,
			fontsize: ds,
			includes: ls,
			indexOf: hs,
			italics: ds,
			lastIndexOf: hs,
			link: ds,
			localeCompare: hs,
			match: os,
			matchAll: os,
			normalize: ds,
			padEnd: ds,
			padStart: ds,
			repeat: ds,
			replace: ps,
			replaceAll: ps,
			search: hs,
			slice: ds,
			small: ds,
			split: os,
			startsWith: ls,
			strike: ds,
			sub: ds,
			substr: ds,
			substring: ds,
			sup: ds,
			toLocaleLowerCase: ds,
			toLocaleUpperCase: ds,
			toLowerCase: ds,
			toString: ds,
			toUpperCase: ds,
			trim: ds,
			trimEnd: ds,
			trimLeft: ds,
			trimRight: ds,
			trimStart: ds,
			valueOf: ds
		},
		fs
	)
function Es(e, t, s, i) {
	return 'string' != typeof t || !e[t] || e[t].hasEffectsWhenCalled?.(s, i) || !1
}
function bs(e, t) {
	return 'string' == typeof t && e[t] ? [e[t].returns, !1] : le
}
function vs(e, t, s) {
	s(e, t)
}
function Ss(e, t, s) {}
var As = {}
;(As.Program =
	As.BlockStatement =
	As.StaticBlock =
		function (e, t, s) {
			for (var i = 0, n = e.body; i < n.length; i += 1) {
				s(n[i], t, 'Statement')
			}
		}),
	(As.Statement = vs),
	(As.EmptyStatement = Ss),
	(As.ExpressionStatement =
		As.ParenthesizedExpression =
		As.ChainExpression =
			function (e, t, s) {
				return s(e.expression, t, 'Expression')
			}),
	(As.IfStatement = function (e, t, s) {
		s(e.test, t, 'Expression'), s(e.consequent, t, 'Statement'), e.alternate && s(e.alternate, t, 'Statement')
	}),
	(As.LabeledStatement = function (e, t, s) {
		return s(e.body, t, 'Statement')
	}),
	(As.BreakStatement = As.ContinueStatement = Ss),
	(As.WithStatement = function (e, t, s) {
		s(e.object, t, 'Expression'), s(e.body, t, 'Statement')
	}),
	(As.SwitchStatement = function (e, t, s) {
		s(e.discriminant, t, 'Expression')
		for (var i = 0, n = e.cases; i < n.length; i += 1) {
			var r = n[i]
			r.test && s(r.test, t, 'Expression')
			for (var o = 0, a = r.consequent; o < a.length; o += 1) {
				s(a[o], t, 'Statement')
			}
		}
	}),
	(As.SwitchCase = function (e, t, s) {
		e.test && s(e.test, t, 'Expression')
		for (var i = 0, n = e.consequent; i < n.length; i += 1) {
			s(n[i], t, 'Statement')
		}
	}),
	(As.ReturnStatement =
		As.YieldExpression =
		As.AwaitExpression =
			function (e, t, s) {
				e.argument && s(e.argument, t, 'Expression')
			}),
	(As.ThrowStatement = As.SpreadElement =
		function (e, t, s) {
			return s(e.argument, t, 'Expression')
		}),
	(As.TryStatement = function (e, t, s) {
		s(e.block, t, 'Statement'), e.handler && s(e.handler, t), e.finalizer && s(e.finalizer, t, 'Statement')
	}),
	(As.CatchClause = function (e, t, s) {
		e.param && s(e.param, t, 'Pattern'), s(e.body, t, 'Statement')
	}),
	(As.WhileStatement = As.DoWhileStatement =
		function (e, t, s) {
			s(e.test, t, 'Expression'), s(e.body, t, 'Statement')
		}),
	(As.ForStatement = function (e, t, s) {
		e.init && s(e.init, t, 'ForInit'), e.test && s(e.test, t, 'Expression'), e.update && s(e.update, t, 'Expression'), s(e.body, t, 'Statement')
	}),
	(As.ForInStatement = As.ForOfStatement =
		function (e, t, s) {
			s(e.left, t, 'ForInit'), s(e.right, t, 'Expression'), s(e.body, t, 'Statement')
		}),
	(As.ForInit = function (e, t, s) {
		'VariableDeclaration' === e.type ? s(e, t) : s(e, t, 'Expression')
	}),
	(As.DebuggerStatement = Ss),
	(As.FunctionDeclaration = function (e, t, s) {
		return s(e, t, 'Function')
	}),
	(As.VariableDeclaration = function (e, t, s) {
		for (var i = 0, n = e.declarations; i < n.length; i += 1) {
			s(n[i], t)
		}
	}),
	(As.VariableDeclarator = function (e, t, s) {
		s(e.id, t, 'Pattern'), e.init && s(e.init, t, 'Expression')
	}),
	(As.Function = function (e, t, s) {
		e.id && s(e.id, t, 'Pattern')
		for (var i = 0, n = e.params; i < n.length; i += 1) {
			s(n[i], t, 'Pattern')
		}
		s(e.body, t, e.expression ? 'Expression' : 'Statement')
	}),
	(As.Pattern = function (e, t, s) {
		'Identifier' === e.type ? s(e, t, 'VariablePattern') : 'MemberExpression' === e.type ? s(e, t, 'MemberPattern') : s(e, t)
	}),
	(As.VariablePattern = Ss),
	(As.MemberPattern = vs),
	(As.RestElement = function (e, t, s) {
		return s(e.argument, t, 'Pattern')
	}),
	(As.ArrayPattern = function (e, t, s) {
		for (var i = 0, n = e.elements; i < n.length; i += 1) {
			var r = n[i]
			r && s(r, t, 'Pattern')
		}
	}),
	(As.ObjectPattern = function (e, t, s) {
		for (var i = 0, n = e.properties; i < n.length; i += 1) {
			var r = n[i]
			'Property' === r.type ? (r.computed && s(r.key, t, 'Expression'), s(r.value, t, 'Pattern')) : 'RestElement' === r.type && s(r.argument, t, 'Pattern')
		}
	}),
	(As.Expression = vs),
	(As.ThisExpression = As.Super = As.MetaProperty = Ss),
	(As.ArrayExpression = function (e, t, s) {
		for (var i = 0, n = e.elements; i < n.length; i += 1) {
			var r = n[i]
			r && s(r, t, 'Expression')
		}
	}),
	(As.ObjectExpression = function (e, t, s) {
		for (var i = 0, n = e.properties; i < n.length; i += 1) {
			s(n[i], t)
		}
	}),
	(As.FunctionExpression = As.ArrowFunctionExpression = As.FunctionDeclaration),
	(As.SequenceExpression = function (e, t, s) {
		for (var i = 0, n = e.expressions; i < n.length; i += 1) {
			s(n[i], t, 'Expression')
		}
	}),
	(As.TemplateLiteral = function (e, t, s) {
		for (var i = 0, n = e.quasis; i < n.length; i += 1) {
			s(n[i], t)
		}
		for (var r = 0, o = e.expressions; r < o.length; r += 1) {
			s(o[r], t, 'Expression')
		}
	}),
	(As.TemplateElement = Ss),
	(As.UnaryExpression = As.UpdateExpression =
		function (e, t, s) {
			s(e.argument, t, 'Expression')
		}),
	(As.BinaryExpression = As.LogicalExpression =
		function (e, t, s) {
			s(e.left, t, 'Expression'), s(e.right, t, 'Expression')
		}),
	(As.AssignmentExpression = As.AssignmentPattern =
		function (e, t, s) {
			s(e.left, t, 'Pattern'), s(e.right, t, 'Expression')
		}),
	(As.ConditionalExpression = function (e, t, s) {
		s(e.test, t, 'Expression'), s(e.consequent, t, 'Expression'), s(e.alternate, t, 'Expression')
	}),
	(As.NewExpression = As.CallExpression =
		function (e, t, s) {
			if ((s(e.callee, t, 'Expression'), e.arguments))
				for (var i = 0, n = e.arguments; i < n.length; i += 1) {
					s(n[i], t, 'Expression')
				}
		}),
	(As.MemberExpression = function (e, t, s) {
		s(e.object, t, 'Expression'), e.computed && s(e.property, t, 'Expression')
	}),
	(As.ExportNamedDeclaration = As.ExportDefaultDeclaration =
		function (e, t, s) {
			e.declaration && s(e.declaration, t, 'ExportNamedDeclaration' === e.type || e.declaration.id ? 'Statement' : 'Expression'), e.source && s(e.source, t, 'Expression')
		}),
	(As.ExportAllDeclaration = function (e, t, s) {
		e.exported && s(e.exported, t), s(e.source, t, 'Expression')
	}),
	(As.ImportDeclaration = function (e, t, s) {
		for (var i = 0, n = e.specifiers; i < n.length; i += 1) {
			s(n[i], t)
		}
		s(e.source, t, 'Expression')
	}),
	(As.ImportExpression = function (e, t, s) {
		s(e.source, t, 'Expression')
	}),
	(As.ImportSpecifier = As.ImportDefaultSpecifier = As.ImportNamespaceSpecifier = As.Identifier = As.PrivateIdentifier = As.Literal = Ss),
	(As.TaggedTemplateExpression = function (e, t, s) {
		s(e.tag, t, 'Expression'), s(e.quasi, t, 'Expression')
	}),
	(As.ClassDeclaration = As.ClassExpression =
		function (e, t, s) {
			return s(e, t, 'Class')
		}),
	(As.Class = function (e, t, s) {
		e.id && s(e.id, t, 'Pattern'), e.superClass && s(e.superClass, t, 'Expression'), s(e.body, t)
	}),
	(As.ClassBody = function (e, t, s) {
		for (var i = 0, n = e.body; i < n.length; i += 1) {
			s(n[i], t)
		}
	}),
	(As.MethodDefinition =
		As.PropertyDefinition =
		As.Property =
			function (e, t, s) {
				e.computed && s(e.key, t, 'Expression'), e.value && s(e.value, t, 'Expression')
			})
const ks = 'ArrowFunctionExpression',
	Is = 'BinaryExpression',
	ws = 'BlockStatement',
	Ps = 'CallExpression',
	Cs = 'ChainExpression',
	$s = 'ConditionalExpression',
	Ns = 'ExportDefaultDeclaration',
	_s = 'ExportNamedDeclaration',
	Rs = 'ExpressionStatement',
	Ms = 'FunctionDeclaration',
	Os = 'Identifier',
	Ds = 'LogicalExpression',
	Ls = 'NewExpression',
	Ts = 'Program',
	Vs = 'SequenceExpression',
	Bs = 'VariableDeclarator',
	zs = 'VariableDeclaration'
let Fs = 'sourceMa'
Fs += 'ppingURL'
const js = new RegExp(`^#[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+${Fs}=.+`),
	Us = '_rollupAnnotations',
	Gs = '_rollupRemoved'
function Ws(e, t, s = e.type) {
	const { annotations: i, code: n } = t
	let r = i[t.annotationIndex]
	for (; r && e.start >= r.end; ) Ks(e, r, n), (r = i[++t.annotationIndex])
	if (r && r.end <= e.end) for (As[s](e, t, Ws); (r = i[t.annotationIndex]) && r.end <= e.end; ) ++t.annotationIndex, Qs(e, r, !1)
}
const qs = /[^\s(]/g,
	Hs = /\S/g
function Ks(e, t, s) {
	const i = []
	let n
	if (Ys(s.slice(t.end, e.start), qs)) {
		const t = e.start
		for (;;) {
			switch ((i.push(e), e.type)) {
				case Rs:
				case Cs:
					e = e.expression
					continue
				case Vs:
					if (Ys(s.slice(t, e.start), Hs)) {
						e = e.expressions[0]
						continue
					}
					n = !0
					break
				case $s:
					if (Ys(s.slice(t, e.start), Hs)) {
						e = e.test
						continue
					}
					n = !0
					break
				case Ds:
				case Is:
					if (Ys(s.slice(t, e.start), Hs)) {
						e = e.left
						continue
					}
					n = !0
					break
				case _s:
				case Ns:
					e = e.declaration
					continue
				case zs: {
					const t = e
					if ('const' === t.kind) {
						e = t.declarations[0].init
						continue
					}
					n = !0
					break
				}
				case Bs:
					e = e.init
					continue
				case Ms:
				case ks:
				case Ps:
				case Ls:
					break
				default:
					n = !0
			}
			break
		}
	} else n = !0
	if (n) Qs(e, t, !1)
	else for (const e of i) Qs(e, t, !0)
}
function Ys(e, t) {
	let s
	for (; null !== (s = t.exec(e)); ) {
		if ('/' === s[0]) {
			const s = e.charCodeAt(t.lastIndex)
			if (42 === s) {
				t.lastIndex = e.indexOf('*/', t.lastIndex + 1) + 2
				continue
			}
			if (47 === s) {
				t.lastIndex = e.indexOf('\n', t.lastIndex + 1) + 1
				continue
			}
		}
		return (t.lastIndex = 0), !1
	}
	return !0
}
const Xs = [
	['pure', /[#@]__PURE__/],
	['noSideEffects', /[#@]__NO_SIDE_EFFECTS__/]
]
function Qs(e, t, s) {
	const i = s ? Us : Gs,
		n = e[i]
	n ? n.push(t) : (e[i] = [t])
}
const Zs = { ImportExpression: ['arguments'], Literal: [], Program: ['body'] }
const Js = 'variables'
class ei extends oe {
	constructor(e, t, s, i = !1) {
		super(),
			(this.deoptimized = !1),
			(this.esTreeNode = i ? e : null),
			(this.keys =
				Zs[e.type] ||
				(function (e) {
					return (Zs[e.type] = Object.keys(e).filter((t) => 'object' == typeof e[t] && 95 !== t.charCodeAt(0))), Zs[e.type]
				})(e)),
			(this.parent = t),
			(this.context = t.context),
			this.createScope(s),
			this.parseNode(e),
			this.initialise(),
			this.context.magicString.addSourcemapLocation(this.start),
			this.context.magicString.addSourcemapLocation(this.end)
	}
	addExportedVariables(e, t) {}
	bind() {
		for (const e of this.keys) {
			const t = this[e]
			if (Array.isArray(t)) for (const e of t) e?.bind()
			else t && t.bind()
		}
	}
	createScope(e) {
		this.scope = e
	}
	hasEffects(e) {
		this.deoptimized || this.applyDeoptimizations()
		for (const t of this.keys) {
			const s = this[t]
			if (null !== s)
				if (Array.isArray(s)) {
					for (const t of s) if (t?.hasEffects(e)) return !0
				} else if (s.hasEffects(e)) return !0
		}
		return !1
	}
	hasEffectsAsAssignmentTarget(e, t) {
		return this.hasEffects(e) || this.hasEffectsOnInteractionAtPath(X, this.assignmentInteraction, e)
	}
	include(e, t, s) {
		this.deoptimized || this.applyDeoptimizations(), (this.included = !0)
		for (const s of this.keys) {
			const i = this[s]
			if (null !== i)
				if (Array.isArray(i)) for (const s of i) s?.include(e, t)
				else i.include(e, t)
		}
	}
	includeAsAssignmentTarget(e, t, s) {
		this.include(e, t)
	}
	initialise() {}
	insertSemicolon(e) {
		';' !== e.original[this.end - 1] && e.appendLeft(this.end, ';')
	}
	parseNode(e, t) {
		for (const [s, i] of Object.entries(e))
			if (!this.hasOwnProperty(s))
				if (95 === s.charCodeAt(0)) {
					if (s === Us) {
						const e = i
						;(this.annotations = e),
							this.context.options.treeshake.annotations &&
								((this.annotationNoSideEffects = e.some((e) => 'noSideEffects' === e.annotationType)), (this.annotationPure = e.some((e) => 'pure' === e.annotationType)))
					} else if (s === Gs) for (const { start: e, end: t } of i) this.context.magicString.remove(e, t)
				} else if ('object' != typeof i || null === i) this[s] = i
				else if (Array.isArray(i)) {
					this[s] = []
					for (const e of i) this[s].push(null === e ? null : new (this.context.getNodeConstructor(e.type))(e, this, this.scope, t?.includes(s)))
				} else this[s] = new (this.context.getNodeConstructor(i.type))(i, this, this.scope, t?.includes(s))
	}
	render(e, t) {
		for (const s of this.keys) {
			const i = this[s]
			if (null !== i)
				if (Array.isArray(i)) for (const s of i) s?.render(e, t)
				else i.render(e, t)
		}
	}
	setAssignedValue(e) {
		this.assignmentInteraction = { args: [null, e], type: 1 }
	}
	shouldBeIncluded(e) {
		return this.included || (!e.brokenFlow && this.hasEffects(is()))
	}
	applyDeoptimizations() {
		this.deoptimized = !0
		for (const e of this.keys) {
			const t = this[e]
			if (null !== t)
				if (Array.isArray(t)) for (const e of t) e?.deoptimizePath(Q)
				else t.deoptimizePath(Q)
		}
		this.context.requestTreeshakingPass()
	}
}
class ti extends ei {
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		t.length > 0 && this.argument.deoptimizeArgumentsOnInteractionAtPath(e, [q, ...t], s)
	}
	hasEffects(e) {
		this.deoptimized || this.applyDeoptimizations()
		const { propertyReadSideEffects: t } = this.context.options.treeshake
		return this.argument.hasEffects(e) || (t && ('always' === t || this.argument.hasEffectsOnInteractionAtPath(Q, he, e)))
	}
	applyDeoptimizations() {
		;(this.deoptimized = !0), this.argument.deoptimizePath([q, q]), this.context.requestTreeshakingPass()
	}
}
class si extends oe {
	constructor(e) {
		super(), (this.description = e)
	}
	deoptimizeArgumentsOnInteractionAtPath({ args: e, type: t }, s) {
		2 === t && 0 === s.length && this.description.mutatesSelfAsArray && e[0]?.deoptimizePath(J)
	}
	getReturnExpressionWhenCalledAtPath(e, { args: t }) {
		return e.length > 0 ? le : [this.description.returnsPrimitive || ('self' === this.description.returns ? t[0] || ae : this.description.returns()), !1]
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		const { type: i } = t
		if (e.length > (0 === i ? 1 : 0)) return !0
		if (2 === i) {
			const { args: e } = t
			if (!0 === this.description.mutatesSelfAsArray && e[0]?.hasEffectsOnInteractionAtPath(J, ue, s)) return !0
			if (this.description.callsArgs) for (const t of this.description.callsArgs) if (e[t + 1]?.hasEffectsOnInteractionAtPath(X, de, s)) return !0
		}
		return !1
	}
}
const ii = [new si({ callsArgs: null, mutatesSelfAsArray: !1, returns: null, returnsPrimitive: as })],
	ni = [new si({ callsArgs: null, mutatesSelfAsArray: !1, returns: null, returnsPrimitive: us })],
	ri = [new si({ callsArgs: null, mutatesSelfAsArray: !1, returns: null, returnsPrimitive: cs })],
	oi = [new si({ callsArgs: null, mutatesSelfAsArray: !1, returns: null, returnsPrimitive: ae })],
	ai = /^\d+$/
class li extends oe {
	constructor(e, t, s = !1) {
		if (
			(super(),
			(this.prototypeExpression = t),
			(this.immutable = s),
			(this.additionalExpressionsToBeDeoptimized = new Set()),
			(this.allProperties = []),
			(this.deoptimizedPaths = Object.create(null)),
			(this.expressionsToBeDeoptimizedByKey = Object.create(null)),
			(this.gettersByKey = Object.create(null)),
			(this.hasLostTrack = !1),
			(this.hasUnknownDeoptimizedInteger = !1),
			(this.hasUnknownDeoptimizedProperty = !1),
			(this.propertiesAndGettersByKey = Object.create(null)),
			(this.propertiesAndSettersByKey = Object.create(null)),
			(this.settersByKey = Object.create(null)),
			(this.unknownIntegerProps = []),
			(this.unmatchableGetters = []),
			(this.unmatchablePropertiesAndGetters = []),
			(this.unmatchableSetters = []),
			Array.isArray(e))
		)
			this.buildPropertyMaps(e)
		else {
			this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = e
			for (const t of Object.values(e)) this.allProperties.push(...t)
		}
	}
	deoptimizeAllProperties(e) {
		const t = this.hasLostTrack || this.hasUnknownDeoptimizedProperty
		if ((e ? (this.hasUnknownDeoptimizedProperty = !0) : (this.hasLostTrack = !0), !t)) {
			for (const e of [...Object.values(this.propertiesAndGettersByKey), ...Object.values(this.settersByKey)]) for (const t of e) t.deoptimizePath(Q)
			this.prototypeExpression?.deoptimizePath([q, q]), this.deoptimizeCachedEntities()
		}
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		const [i, ...n] = t,
			{ args: r, type: o } = e
		if (this.hasLostTrack || ((2 === o || t.length > 1) && (this.hasUnknownDeoptimizedProperty || ('string' == typeof i && this.deoptimizedPaths[i])))) return void ce(e)
		const [a, l, c] =
			2 === o || t.length > 1
				? [this.propertiesAndGettersByKey, this.propertiesAndGettersByKey, this.unmatchablePropertiesAndGetters]
				: 0 === o
				? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]
				: [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters]
		if ('string' == typeof i) {
			if (a[i]) {
				const t = l[i]
				if (t) for (const i of t) i.deoptimizeArgumentsOnInteractionAtPath(e, n, s)
				if (!this.immutable) for (const e of r) e && this.additionalExpressionsToBeDeoptimized.add(e)
				return
			}
			for (const t of c) t.deoptimizeArgumentsOnInteractionAtPath(e, n, s)
			if (ai.test(i)) for (const t of this.unknownIntegerProps) t.deoptimizeArgumentsOnInteractionAtPath(e, n, s)
		} else {
			for (const t of [...Object.values(l), c]) for (const i of t) i.deoptimizeArgumentsOnInteractionAtPath(e, n, s)
			for (const t of this.unknownIntegerProps) t.deoptimizeArgumentsOnInteractionAtPath(e, n, s)
		}
		if (!this.immutable) for (const e of r) e && this.additionalExpressionsToBeDeoptimized.add(e)
		this.prototypeExpression?.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
	}
	deoptimizeIntegerProperties() {
		if (!(this.hasLostTrack || this.hasUnknownDeoptimizedProperty || this.hasUnknownDeoptimizedInteger)) {
			this.hasUnknownDeoptimizedInteger = !0
			for (const [e, t] of Object.entries(this.propertiesAndGettersByKey)) if (ai.test(e)) for (const e of t) e.deoptimizePath(Q)
			this.deoptimizeCachedIntegerEntities()
		}
	}
	deoptimizePath(e) {
		if (this.hasLostTrack || this.immutable) return
		const t = e[0]
		if (1 === e.length) {
			if ('string' != typeof t) return t === K ? this.deoptimizeIntegerProperties() : this.deoptimizeAllProperties(t === H)
			if (!this.deoptimizedPaths[t]) {
				this.deoptimizedPaths[t] = !0
				const e = this.expressionsToBeDeoptimizedByKey[t]
				if (e) for (const t of e) t.deoptimizeCache()
			}
		}
		const s = 1 === e.length ? Q : e.slice(1)
		for (const e of 'string' == typeof t ? [...(this.propertiesAndGettersByKey[t] || this.unmatchablePropertiesAndGetters), ...(this.settersByKey[t] || this.unmatchableSetters)] : this.allProperties)
			e.deoptimizePath(s)
		this.prototypeExpression?.deoptimizePath(1 === e.length ? [...e, q] : e)
	}
	getLiteralValueAtPath(e, t, s) {
		if (0 === e.length) return re
		const i = e[0],
			n = this.getMemberExpressionAndTrackDeopt(i, s)
		return n ? n.getLiteralValueAtPath(e.slice(1), t, s) : this.prototypeExpression ? this.prototypeExpression.getLiteralValueAtPath(e, t, s) : 1 !== e.length ? ne : void 0
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		if (0 === e.length) return le
		const [n, ...r] = e,
			o = this.getMemberExpressionAndTrackDeopt(n, i)
		return o ? o.getReturnExpressionWhenCalledAtPath(r, t, s, i) : this.prototypeExpression ? this.prototypeExpression.getReturnExpressionWhenCalledAtPath(e, t, s, i) : le
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		const [i, ...n] = e
		if (n.length > 0 || 2 === t.type) {
			const r = this.getMemberExpression(i)
			return r ? r.hasEffectsOnInteractionAtPath(n, t, s) : !this.prototypeExpression || this.prototypeExpression.hasEffectsOnInteractionAtPath(e, t, s)
		}
		if (i === H) return !1
		if (this.hasLostTrack) return !0
		const [r, o, a] = 0 === t.type ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters] : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters]
		if ('string' == typeof i) {
			if (r[i]) {
				const e = o[i]
				if (e) for (const i of e) if (i.hasEffectsOnInteractionAtPath(n, t, s)) return !0
				return !1
			}
			for (const e of a) if (e.hasEffectsOnInteractionAtPath(n, t, s)) return !0
		} else for (const e of [...Object.values(o), a]) for (const i of e) if (i.hasEffectsOnInteractionAtPath(n, t, s)) return !0
		return !!this.prototypeExpression && this.prototypeExpression.hasEffectsOnInteractionAtPath(e, t, s)
	}
	buildPropertyMaps(e) {
		const {
				allProperties: t,
				propertiesAndGettersByKey: s,
				propertiesAndSettersByKey: i,
				settersByKey: n,
				gettersByKey: r,
				unknownIntegerProps: o,
				unmatchablePropertiesAndGetters: a,
				unmatchableGetters: l,
				unmatchableSetters: c
			} = this,
			h = []
		for (let u = e.length - 1; u >= 0; u--) {
			const { key: d, kind: p, property: f } = e[u]
			if ((t.push(f), 'string' == typeof d))
				'set' === p ? i[d] || ((i[d] = [f, ...h]), (n[d] = [f, ...c])) : 'get' === p ? s[d] || ((s[d] = [f, ...a]), (r[d] = [f, ...l])) : (i[d] || (i[d] = [f, ...h]), s[d] || (s[d] = [f, ...a]))
			else {
				if (d === K) {
					o.push(f)
					continue
				}
				'set' === p && c.push(f), 'get' === p && l.push(f), 'get' !== p && h.push(f), 'set' !== p && a.push(f)
			}
		}
	}
	deoptimizeCachedEntities() {
		for (const e of Object.values(this.expressionsToBeDeoptimizedByKey)) for (const t of e) t.deoptimizeCache()
		for (const e of this.additionalExpressionsToBeDeoptimized) e.deoptimizePath(Q)
	}
	deoptimizeCachedIntegerEntities() {
		for (const [e, t] of Object.entries(this.expressionsToBeDeoptimizedByKey)) if (ai.test(e)) for (const e of t) e.deoptimizeCache()
		for (const e of this.additionalExpressionsToBeDeoptimized) e.deoptimizePath(J)
	}
	getMemberExpression(e) {
		if (this.hasLostTrack || this.hasUnknownDeoptimizedProperty || 'string' != typeof e || (this.hasUnknownDeoptimizedInteger && ai.test(e)) || this.deoptimizedPaths[e]) return ae
		const t = this.propertiesAndGettersByKey[e]
		return 1 === t?.length ? t[0] : t || this.unmatchablePropertiesAndGetters.length > 0 || (this.unknownIntegerProps.length > 0 && ai.test(e)) ? ae : null
	}
	getMemberExpressionAndTrackDeopt(e, t) {
		if ('string' != typeof e) return ae
		const s = this.getMemberExpression(e)
		if (s !== ae && !this.immutable) {
			;(this.expressionsToBeDeoptimizedByKey[e] = this.expressionsToBeDeoptimizedByKey[e] || []).push(t)
		}
		return s
	}
}
const ci = (e) => 'string' == typeof e && /^\d+$/.test(e),
	hi = new (class extends oe {
		deoptimizeArgumentsOnInteractionAtPath(e, t) {
			2 !== e.type || 1 !== t.length || ci(t[0]) || ce(e)
		}
		getLiteralValueAtPath(e) {
			return 1 === e.length && ci(e[0]) ? void 0 : ne
		}
		hasEffectsOnInteractionAtPath(e, { type: t }) {
			return e.length > 1 || 2 === t
		}
	})(),
	ui = new li({ __proto__: null, hasOwnProperty: ii, isPrototypeOf: ii, propertyIsEnumerable: ii, toLocaleString: ni, toString: ni, valueOf: oi }, hi, !0),
	di = [
		{ key: K, kind: 'init', property: ae },
		{ key: 'length', kind: 'init', property: cs }
	],
	pi = [new si({ callsArgs: [0], mutatesSelfAsArray: 'deopt-only', returns: null, returnsPrimitive: as })],
	fi = [new si({ callsArgs: [0], mutatesSelfAsArray: 'deopt-only', returns: null, returnsPrimitive: cs })],
	mi = [new si({ callsArgs: null, mutatesSelfAsArray: !0, returns: () => new li(di, ki), returnsPrimitive: null })],
	gi = [new si({ callsArgs: null, mutatesSelfAsArray: 'deopt-only', returns: () => new li(di, ki), returnsPrimitive: null })],
	yi = [new si({ callsArgs: [0], mutatesSelfAsArray: 'deopt-only', returns: () => new li(di, ki), returnsPrimitive: null })],
	xi = [new si({ callsArgs: null, mutatesSelfAsArray: !0, returns: null, returnsPrimitive: cs })],
	Ei = [new si({ callsArgs: null, mutatesSelfAsArray: !0, returns: null, returnsPrimitive: ae })],
	bi = [new si({ callsArgs: null, mutatesSelfAsArray: 'deopt-only', returns: null, returnsPrimitive: ae })],
	vi = [new si({ callsArgs: [0], mutatesSelfAsArray: 'deopt-only', returns: null, returnsPrimitive: ae })],
	Si = [new si({ callsArgs: null, mutatesSelfAsArray: !0, returns: 'self', returnsPrimitive: null })],
	Ai = [new si({ callsArgs: [0], mutatesSelfAsArray: !0, returns: 'self', returnsPrimitive: null })],
	ki = new li(
		{
			__proto__: null,
			at: bi,
			concat: gi,
			copyWithin: Si,
			entries: gi,
			every: pi,
			fill: Si,
			filter: yi,
			find: vi,
			findIndex: fi,
			findLast: vi,
			findLastIndex: fi,
			flat: gi,
			flatMap: yi,
			forEach: vi,
			includes: ii,
			indexOf: ri,
			join: ni,
			keys: oi,
			lastIndexOf: ri,
			map: yi,
			pop: Ei,
			push: xi,
			reduce: vi,
			reduceRight: vi,
			reverse: Si,
			shift: Ei,
			slice: gi,
			some: pi,
			sort: Ai,
			splice: mi,
			toLocaleString: ni,
			toString: ni,
			unshift: xi,
			values: bi
		},
		ui,
		!0
	)
class Ii extends ei {
	constructor() {
		super(...arguments), (this.objectEntity = null)
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(e, t, s)
	}
	deoptimizePath(e) {
		this.getObjectEntity().deoptimizePath(e)
	}
	getLiteralValueAtPath(e, t, s) {
		return this.getObjectEntity().getLiteralValueAtPath(e, t, s)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e, t, s, i)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return this.getObjectEntity().hasEffectsOnInteractionAtPath(e, t, s)
	}
	applyDeoptimizations() {
		this.deoptimized = !0
		let e = !1
		for (let t = 0; t < this.elements.length; t++) {
			const s = this.elements[t]
			s && (e || s instanceof ti) && ((e = !0), s.deoptimizePath(Q))
		}
		this.context.requestTreeshakingPass()
	}
	getObjectEntity() {
		if (null !== this.objectEntity) return this.objectEntity
		const e = [{ key: 'length', kind: 'init', property: cs }]
		let t = !1
		for (let s = 0; s < this.elements.length; s++) {
			const i = this.elements[s]
			t || i instanceof ti
				? i && ((t = !0), e.unshift({ key: K, kind: 'init', property: i }))
				: i
				? e.push({ key: String(s), kind: 'init', property: i })
				: e.push({ key: String(s), kind: 'init', property: rs })
		}
		return (this.objectEntity = new li(e, ki))
	}
}
class wi extends ei {
	addExportedVariables(e, t) {
		for (const s of this.elements) s?.addExportedVariables(e, t)
	}
	declare(e) {
		const t = []
		for (const s of this.elements) null !== s && t.push(...s.declare(e, ae))
		return t
	}
	deoptimizePath() {
		for (const e of this.elements) e?.deoptimizePath(X)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		for (const e of this.elements) if (e?.hasEffectsOnInteractionAtPath(X, t, s)) return !0
		return !1
	}
	markDeclarationReached() {
		for (const e of this.elements) e?.markDeclarationReached()
	}
}
class Pi extends pe {
	constructor(e, t, s, i) {
		super(e),
			(this.init = s),
			(this.calledFromTryStatement = !1),
			(this.additionalInitializers = null),
			(this.expressionsToBeDeoptimized = []),
			(this.declarations = t ? [t] : []),
			(this.deoptimizationTracker = i.deoptimizationTracker),
			(this.module = i.module)
	}
	addDeclaration(e, t) {
		this.declarations.push(e), this.markInitializersForDeoptimization().push(t)
	}
	consolidateInitializers() {
		if (this.additionalInitializers) {
			for (const e of this.additionalInitializers) e.deoptimizePath(Q)
			this.additionalInitializers = null
		}
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		this.isReassigned ? ce(e) : s.withTrackedEntityAtPath(t, this.init, () => this.init.deoptimizeArgumentsOnInteractionAtPath(e, t, s), void 0)
	}
	deoptimizePath(e) {
		if (!this.isReassigned && !this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e, this))
			if (0 === e.length) {
				if (!this.isReassigned) {
					this.isReassigned = !0
					const e = this.expressionsToBeDeoptimized
					this.expressionsToBeDeoptimized = ye
					for (const t of e) t.deoptimizeCache()
					this.init.deoptimizePath(Q)
				}
			} else this.init.deoptimizePath(e)
	}
	getLiteralValueAtPath(e, t, s) {
		return this.isReassigned ? ne : t.withTrackedEntityAtPath(e, this.init, () => (this.expressionsToBeDeoptimized.push(s), this.init.getLiteralValueAtPath(e, t, s)), ne)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return this.isReassigned ? le : s.withTrackedEntityAtPath(e, this.init, () => (this.expressionsToBeDeoptimized.push(i), this.init.getReturnExpressionWhenCalledAtPath(e, t, s, i)), le)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		switch (t.type) {
			case 0:
				return !!this.isReassigned || (!s.accessed.trackEntityAtPathAndGetIfTracked(e, this) && this.init.hasEffectsOnInteractionAtPath(e, t, s))
			case 1:
				return !!this.included || (0 !== e.length && (!!this.isReassigned || (!s.assigned.trackEntityAtPathAndGetIfTracked(e, this) && this.init.hasEffectsOnInteractionAtPath(e, t, s))))
			case 2:
				return !!this.isReassigned || (!(t.withNew ? s.instantiated : s.called).trackEntityAtPathAndGetIfTracked(e, t.args, this) && this.init.hasEffectsOnInteractionAtPath(e, t, s))
		}
	}
	include() {
		if (!this.included) {
			this.included = !0
			for (const e of this.declarations) {
				e.included || e.include(ss(), !1)
				let t = e.parent
				for (; !t.included && ((t.included = !0), t.type !== Ts); ) t = t.parent
			}
		}
	}
	includeCallArguments(e, t) {
		if (this.isReassigned || e.includedCallArguments.has(this.init)) for (const s of t) s.include(e, !1)
		else e.includedCallArguments.add(this.init), this.init.includeCallArguments(e, t), e.includedCallArguments.delete(this.init)
	}
	markCalledFromTryStatement() {
		this.calledFromTryStatement = !0
	}
	markInitializersForDeoptimization() {
		return null === this.additionalInitializers && ((this.additionalInitializers = [this.init]), (this.init = ae), (this.isReassigned = !0)), this.additionalInitializers
	}
	mergeDeclarations(e) {
		const { declarations: t } = this
		for (const s of e.declarations) t.push(s)
		const s = this.markInitializersForDeoptimization()
		if ((s.push(e.init), e.additionalInitializers)) for (const t of e.additionalInitializers) s.push(t)
	}
}
const Ci = ye,
	$i = new Set([q]),
	Ni = new te(),
	_i = new Set([ae])
class Ri extends Pi {
	constructor(e, t, s) {
		super(e, t, ae, s), (this.deoptimizationInteractions = []), (this.deoptimizations = new te()), (this.deoptimizedFields = new Set()), (this.entitiesToBeDeoptimized = new Set())
	}
	addEntityToBeDeoptimized(e) {
		if (e === ae) {
			if (!this.entitiesToBeDeoptimized.has(ae)) {
				this.entitiesToBeDeoptimized.add(ae)
				for (const { interaction: e } of this.deoptimizationInteractions) ce(e)
				this.deoptimizationInteractions = Ci
			}
		} else if (this.deoptimizedFields.has(q)) e.deoptimizePath(Q)
		else if (!this.entitiesToBeDeoptimized.has(e)) {
			this.entitiesToBeDeoptimized.add(e)
			for (const t of this.deoptimizedFields) e.deoptimizePath([t])
			for (const { interaction: t, path: s } of this.deoptimizationInteractions) e.deoptimizeArgumentsOnInteractionAtPath(t, s, se)
		}
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t) {
		if (
			t.length >= 2 ||
			this.entitiesToBeDeoptimized.has(ae) ||
			this.deoptimizationInteractions.length >= 20 ||
			(1 === t.length && (this.deoptimizedFields.has(q) || (2 === e.type && this.deoptimizedFields.has(t[0]))))
		)
			ce(e)
		else if (!this.deoptimizations.trackEntityAtPathAndGetIfTracked(t, e.args)) {
			for (const s of this.entitiesToBeDeoptimized) s.deoptimizeArgumentsOnInteractionAtPath(e, t, se)
			this.entitiesToBeDeoptimized.has(ae) || this.deoptimizationInteractions.push({ interaction: e, path: t })
		}
	}
	deoptimizePath(e) {
		if (0 === e.length || this.deoptimizedFields.has(q)) return
		const t = e[0]
		if (!this.deoptimizedFields.has(t)) {
			this.deoptimizedFields.add(t)
			for (const e of this.entitiesToBeDeoptimized) e.deoptimizePath([t])
			t === q && ((this.deoptimizationInteractions = Ci), (this.deoptimizations = Ni), (this.deoptimizedFields = $i), (this.entitiesToBeDeoptimized = _i))
		}
	}
	getReturnExpressionWhenCalledAtPath(e) {
		return 0 === e.length ? this.deoptimizePath(Q) : this.deoptimizedFields.has(e[0]) || this.deoptimizePath([e[0]]), le
	}
}
const Mi = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$',
	Oi = 64
function Di(e) {
	let t = ''
	do {
		const s = e % Oi
		;(e = (e / Oi) | 0), (t = Mi[s] + t)
	} while (0 !== e)
	return t
}
function Li(e, t, s) {
	let i = e,
		n = 1
	for (; t.has(i) || Ee.has(i) || s?.has(i); ) i = `${e}$${Di(n++)}`
	return t.add(i), i
}
let Ti = class {
	constructor() {
		;(this.children = []), (this.variables = new Map())
	}
	addDeclaration(e, t, s, i) {
		const n = e.name
		let r = this.variables.get(n)
		return r ? r.addDeclaration(e, s) : ((r = new Pi(e.name, e, s || rs, t)), this.variables.set(n, r)), r
	}
	contains(e) {
		return this.variables.has(e)
	}
	findVariable(e) {
		throw new Error('Internal Error: findVariable needs to be implemented by a subclass')
	}
}
class Vi extends Ti {
	constructor(e) {
		super(), (this.accessedOutsideVariables = new Map()), (this.parent = e), e.children.push(this)
	}
	addAccessedDynamicImport(e) {
		;(this.accessedDynamicImports || (this.accessedDynamicImports = new Set())).add(e), this.parent instanceof Vi && this.parent.addAccessedDynamicImport(e)
	}
	addAccessedGlobals(e, t) {
		const s = t.get(this) || new Set()
		for (const t of e) s.add(t)
		t.set(this, s), this.parent instanceof Vi && this.parent.addAccessedGlobals(e, t)
	}
	addNamespaceMemberAccess(e, t) {
		this.accessedOutsideVariables.set(e, t), this.parent.addNamespaceMemberAccess(e, t)
	}
	addReturnExpression(e) {
		this.parent instanceof Vi && this.parent.addReturnExpression(e)
	}
	addUsedOutsideNames(e, t, s, i) {
		for (const i of this.accessedOutsideVariables.values()) i.included && (e.add(i.getBaseVariableName()), 'system' === t && s.has(i) && e.add('exports'))
		const n = i.get(this)
		if (n) for (const t of n) e.add(t)
	}
	contains(e) {
		return this.variables.has(e) || this.parent.contains(e)
	}
	deconflict(e, t, s) {
		const i = new Set()
		if ((this.addUsedOutsideNames(i, e, t, s), this.accessedDynamicImports)) for (const e of this.accessedDynamicImports) e.inlineNamespace && i.add(e.inlineNamespace.getBaseVariableName())
		for (const [e, t] of this.variables) (t.included || t.alwaysRendered) && t.setRenderNames(null, Li(e, i, t.forbiddenNames))
		for (const i of this.children) i.deconflict(e, t, s)
	}
	findLexicalBoundary() {
		return this.parent.findLexicalBoundary()
	}
	findVariable(e) {
		const t = this.variables.get(e) || this.accessedOutsideVariables.get(e)
		if (t) return t
		const s = this.parent.findVariable(e)
		return this.accessedOutsideVariables.set(e, s), s
	}
}
class Bi extends Vi {
	constructor(e, t) {
		super(e), (this.parameters = []), (this.hasRest = !1), (this.context = t), (this.hoistedBodyVarScope = new Vi(this))
	}
	addParameterDeclaration(e) {
		const { name: t } = e,
			s = new Ri(t, e, this.context),
			i = this.hoistedBodyVarScope.variables.get(t)
		return i && (this.hoistedBodyVarScope.variables.set(t, s), s.mergeDeclarations(i)), this.variables.set(t, s), s
	}
	addParameterVariables(e, t) {
		this.parameters = e
		for (const t of e) for (const e of t) e.alwaysRendered = !0
		this.hasRest = t
	}
	includeCallArguments(e, t) {
		let s = !1,
			i = !1
		const n = this.hasRest && this.parameters[this.parameters.length - 1]
		for (const s of t)
			if (s instanceof ti) {
				for (const s of t) s.include(e, !1)
				break
			}
		for (let r = t.length - 1; r >= 0; r--) {
			const o = this.parameters[r] || n,
				a = t[r]
			if (o)
				if (((s = !1), 0 === o.length)) i = !0
				else for (const e of o) e.included && (i = !0), e.calledFromTryStatement && (s = !0)
			!i && a.shouldBeIncluded(e) && (i = !0), i && a.include(e, s)
		}
	}
}
class zi extends Bi {
	constructor() {
		super(...arguments), (this.returnExpression = null), (this.returnExpressions = [])
	}
	addReturnExpression(e) {
		this.returnExpressions.push(e)
	}
	getReturnExpression() {
		return null === this.returnExpression && this.updateReturnExpression(), this.returnExpression
	}
	updateReturnExpression() {
		if (1 === this.returnExpressions.length) this.returnExpression = this.returnExpressions[0]
		else {
			this.returnExpression = ae
			for (const e of this.returnExpressions) e.deoptimizePath(Q)
		}
	}
}
function Fi(e, t) {
	if ('MemberExpression' === e.type) return !e.computed && Fi(e.object, e)
	if ('Identifier' === e.type) {
		if (!t) return !0
		switch (t.type) {
			case 'MemberExpression':
				return t.computed || e === t.object
			case 'MethodDefinition':
				return t.computed
			case 'PropertyDefinition':
			case 'Property':
				return t.computed || e === t.value
			case 'ExportSpecifier':
			case 'ImportSpecifier':
				return e === t.local
			case 'LabeledStatement':
			case 'BreakStatement':
			case 'ContinueStatement':
				return !1
			default:
				return !0
		}
	}
	return !1
}
const ji = Symbol('PureFunction'),
	Ui = () => {},
	Gi = Symbol('Value Properties'),
	Wi = () => re,
	qi = () => !1,
	Hi = () => !0,
	Ki = { deoptimizeArgumentsOnCall: Ui, getLiteralValue: Wi, hasEffectsWhenCalled: qi },
	Yi = { deoptimizeArgumentsOnCall: Ui, getLiteralValue: Wi, hasEffectsWhenCalled: Hi },
	Xi = { __proto__: null, [Gi]: Yi },
	Qi = { __proto__: null, [Gi]: Ki },
	Zi = {
		__proto__: null,
		[Gi]: {
			deoptimizeArgumentsOnCall: Ui,
			getLiteralValue: Wi,
			hasEffectsWhenCalled({ args: e }, t) {
				const [s, i] = e
				return !(i instanceof oe) || i.hasEffectsOnInteractionAtPath(Q, he, t)
			}
		}
	},
	Ji = {
		__proto__: null,
		[Gi]: {
			deoptimizeArgumentsOnCall({ args: [, e] }) {
				e?.deoptimizePath(Q)
			},
			getLiteralValue: Wi,
			hasEffectsWhenCalled: ({ args: e }, t) => e.length <= 1 || e[1].hasEffectsOnInteractionAtPath(Z, ue, t)
		}
	},
	en = { __proto__: null, [Gi]: Yi, prototype: Xi },
	tn = { __proto__: null, [Gi]: Ki, prototype: Xi },
	sn = { __proto__: null, [Gi]: { deoptimizeArgumentsOnCall: Ui, getLiteralValue: Wi, hasEffectsWhenCalled: ({ args: e }) => e.length > 1 && !(e[1] instanceof Ii) }, prototype: Xi },
	nn = { __proto__: null, [Gi]: Ki, from: Xi, of: Qi, prototype: Xi },
	rn = { __proto__: null, [Gi]: Ki, supportedLocalesOf: tn },
	on = {
		global: Xi,
		globalThis: Xi,
		self: Xi,
		window: Xi,
		__proto__: null,
		[Gi]: Yi,
		Array: { __proto__: null, [Gi]: Yi, from: Xi, isArray: Qi, of: Qi, prototype: Xi },
		ArrayBuffer: { __proto__: null, [Gi]: Ki, isView: Qi, prototype: Xi },
		Atomics: Xi,
		BigInt: en,
		BigInt64Array: en,
		BigUint64Array: en,
		Boolean: tn,
		constructor: en,
		DataView: tn,
		Date: { __proto__: null, [Gi]: Ki, now: Qi, parse: Qi, prototype: Xi, UTC: Qi },
		decodeURI: Qi,
		decodeURIComponent: Qi,
		encodeURI: Qi,
		encodeURIComponent: Qi,
		Error: tn,
		escape: Qi,
		eval: Xi,
		EvalError: tn,
		Float32Array: nn,
		Float64Array: nn,
		Function: en,
		hasOwnProperty: Xi,
		Infinity: Xi,
		Int16Array: nn,
		Int32Array: nn,
		Int8Array: nn,
		isFinite: Qi,
		isNaN: Qi,
		isPrototypeOf: Xi,
		JSON: Xi,
		Map: sn,
		Math: {
			__proto__: null,
			[Gi]: Yi,
			abs: Qi,
			acos: Qi,
			acosh: Qi,
			asin: Qi,
			asinh: Qi,
			atan: Qi,
			atan2: Qi,
			atanh: Qi,
			cbrt: Qi,
			ceil: Qi,
			clz32: Qi,
			cos: Qi,
			cosh: Qi,
			exp: Qi,
			expm1: Qi,
			floor: Qi,
			fround: Qi,
			hypot: Qi,
			imul: Qi,
			log: Qi,
			log10: Qi,
			log1p: Qi,
			log2: Qi,
			max: Qi,
			min: Qi,
			pow: Qi,
			random: Qi,
			round: Qi,
			sign: Qi,
			sin: Qi,
			sinh: Qi,
			sqrt: Qi,
			tan: Qi,
			tanh: Qi,
			trunc: Qi
		},
		NaN: Xi,
		Number: { __proto__: null, [Gi]: Ki, isFinite: Qi, isInteger: Qi, isNaN: Qi, isSafeInteger: Qi, parseFloat: Qi, parseInt: Qi, prototype: Xi },
		Object: {
			__proto__: null,
			[Gi]: Ki,
			create: Qi,
			defineProperty: Ji,
			defineProperties: Ji,
			freeze: Ji,
			getOwnPropertyDescriptor: Qi,
			getOwnPropertyDescriptors: Qi,
			getOwnPropertyNames: Qi,
			getOwnPropertySymbols: Qi,
			getPrototypeOf: Qi,
			hasOwn: Qi,
			is: Qi,
			isExtensible: Qi,
			isFrozen: Qi,
			isSealed: Qi,
			keys: Qi,
			fromEntries: Xi,
			entries: Zi,
			values: Zi,
			prototype: Xi
		},
		parseFloat: Qi,
		parseInt: Qi,
		Promise: { __proto__: null, [Gi]: Yi, all: Xi, allSettled: Xi, any: Xi, prototype: Xi, race: Xi, reject: Xi, resolve: Xi },
		propertyIsEnumerable: Xi,
		Proxy: Xi,
		RangeError: tn,
		ReferenceError: tn,
		Reflect: Xi,
		RegExp: tn,
		Set: sn,
		SharedArrayBuffer: en,
		String: { __proto__: null, [Gi]: Ki, fromCharCode: Qi, fromCodePoint: Qi, prototype: Xi, raw: Qi },
		Symbol: {
			__proto__: null,
			[Gi]: Ki,
			for: Qi,
			keyFor: Qi,
			prototype: Xi,
			toStringTag: { __proto__: null, [Gi]: { deoptimizeArgumentsOnCall: Ui, getLiteralValue: () => Y, hasEffectsWhenCalled: Hi } }
		},
		SyntaxError: tn,
		toLocaleString: Xi,
		toString: Xi,
		TypeError: tn,
		Uint16Array: nn,
		Uint32Array: nn,
		Uint8Array: nn,
		Uint8ClampedArray: nn,
		unescape: Qi,
		URIError: tn,
		valueOf: Xi,
		WeakMap: sn,
		WeakSet: sn,
		clearInterval: en,
		clearTimeout: en,
		console: {
			__proto__: null,
			[Gi]: Yi,
			assert: en,
			clear: en,
			count: en,
			countReset: en,
			debug: en,
			dir: en,
			dirxml: en,
			error: en,
			exception: en,
			group: en,
			groupCollapsed: en,
			groupEnd: en,
			info: en,
			log: en,
			table: en,
			time: en,
			timeEnd: en,
			timeLog: en,
			trace: en,
			warn: en
		},
		Intl: { __proto__: null, [Gi]: Yi, Collator: rn, DateTimeFormat: rn, DisplayNames: rn, ListFormat: rn, Locale: rn, NumberFormat: rn, PluralRules: rn, RelativeTimeFormat: rn, Segmenter: rn },
		setInterval: en,
		setTimeout: en,
		TextDecoder: en,
		TextEncoder: en,
		URL: { __proto__: null, [Gi]: Yi, prototype: Xi, canParse: Qi },
		URLSearchParams: en,
		AbortController: en,
		AbortSignal: en,
		addEventListener: Xi,
		alert: Xi,
		AnalyserNode: en,
		Animation: en,
		AnimationEvent: en,
		applicationCache: Xi,
		ApplicationCache: en,
		ApplicationCacheErrorEvent: en,
		atob: Xi,
		Attr: en,
		Audio: en,
		AudioBuffer: en,
		AudioBufferSourceNode: en,
		AudioContext: en,
		AudioDestinationNode: en,
		AudioListener: en,
		AudioNode: en,
		AudioParam: en,
		AudioProcessingEvent: en,
		AudioScheduledSourceNode: en,
		AudioWorkletNode: en,
		BarProp: en,
		BaseAudioContext: en,
		BatteryManager: en,
		BeforeUnloadEvent: en,
		BiquadFilterNode: en,
		Blob: en,
		BlobEvent: en,
		blur: Xi,
		BroadcastChannel: en,
		btoa: Xi,
		ByteLengthQueuingStrategy: en,
		Cache: en,
		caches: Xi,
		CacheStorage: en,
		cancelAnimationFrame: Xi,
		cancelIdleCallback: Xi,
		CanvasCaptureMediaStreamTrack: en,
		CanvasGradient: en,
		CanvasPattern: en,
		CanvasRenderingContext2D: en,
		ChannelMergerNode: en,
		ChannelSplitterNode: en,
		CharacterData: en,
		clientInformation: Xi,
		ClipboardEvent: en,
		close: Xi,
		closed: Xi,
		CloseEvent: en,
		Comment: en,
		CompositionEvent: en,
		confirm: Xi,
		ConstantSourceNode: en,
		ConvolverNode: en,
		CountQueuingStrategy: en,
		createImageBitmap: Xi,
		Credential: en,
		CredentialsContainer: en,
		crypto: Xi,
		Crypto: en,
		CryptoKey: en,
		CSS: en,
		CSSConditionRule: en,
		CSSFontFaceRule: en,
		CSSGroupingRule: en,
		CSSImportRule: en,
		CSSKeyframeRule: en,
		CSSKeyframesRule: en,
		CSSMediaRule: en,
		CSSNamespaceRule: en,
		CSSPageRule: en,
		CSSRule: en,
		CSSRuleList: en,
		CSSStyleDeclaration: en,
		CSSStyleRule: en,
		CSSStyleSheet: en,
		CSSSupportsRule: en,
		CustomElementRegistry: en,
		customElements: Xi,
		CustomEvent: {
			__proto__: null,
			[Gi]: {
				deoptimizeArgumentsOnCall({ args: e }) {
					e[2]?.deoptimizePath(['detail'])
				},
				getLiteralValue: Wi,
				hasEffectsWhenCalled: qi
			},
			prototype: Xi
		},
		DataTransfer: en,
		DataTransferItem: en,
		DataTransferItemList: en,
		defaultstatus: Xi,
		defaultStatus: Xi,
		DelayNode: en,
		DeviceMotionEvent: en,
		DeviceOrientationEvent: en,
		devicePixelRatio: Xi,
		dispatchEvent: Xi,
		document: Xi,
		Document: en,
		DocumentFragment: en,
		DocumentType: en,
		DOMError: en,
		DOMException: en,
		DOMImplementation: en,
		DOMMatrix: en,
		DOMMatrixReadOnly: en,
		DOMParser: en,
		DOMPoint: en,
		DOMPointReadOnly: en,
		DOMQuad: en,
		DOMRect: en,
		DOMRectReadOnly: en,
		DOMStringList: en,
		DOMStringMap: en,
		DOMTokenList: en,
		DragEvent: en,
		DynamicsCompressorNode: en,
		Element: en,
		ErrorEvent: en,
		Event: en,
		EventSource: en,
		EventTarget: en,
		external: Xi,
		fetch: Xi,
		File: en,
		FileList: en,
		FileReader: en,
		find: Xi,
		focus: Xi,
		FocusEvent: en,
		FontFace: en,
		FontFaceSetLoadEvent: en,
		FormData: en,
		frames: Xi,
		GainNode: en,
		Gamepad: en,
		GamepadButton: en,
		GamepadEvent: en,
		getComputedStyle: Xi,
		getSelection: Xi,
		HashChangeEvent: en,
		Headers: en,
		history: Xi,
		History: en,
		HTMLAllCollection: en,
		HTMLAnchorElement: en,
		HTMLAreaElement: en,
		HTMLAudioElement: en,
		HTMLBaseElement: en,
		HTMLBodyElement: en,
		HTMLBRElement: en,
		HTMLButtonElement: en,
		HTMLCanvasElement: en,
		HTMLCollection: en,
		HTMLContentElement: en,
		HTMLDataElement: en,
		HTMLDataListElement: en,
		HTMLDetailsElement: en,
		HTMLDialogElement: en,
		HTMLDirectoryElement: en,
		HTMLDivElement: en,
		HTMLDListElement: en,
		HTMLDocument: en,
		HTMLElement: en,
		HTMLEmbedElement: en,
		HTMLFieldSetElement: en,
		HTMLFontElement: en,
		HTMLFormControlsCollection: en,
		HTMLFormElement: en,
		HTMLFrameElement: en,
		HTMLFrameSetElement: en,
		HTMLHeadElement: en,
		HTMLHeadingElement: en,
		HTMLHRElement: en,
		HTMLHtmlElement: en,
		HTMLIFrameElement: en,
		HTMLImageElement: en,
		HTMLInputElement: en,
		HTMLLabelElement: en,
		HTMLLegendElement: en,
		HTMLLIElement: en,
		HTMLLinkElement: en,
		HTMLMapElement: en,
		HTMLMarqueeElement: en,
		HTMLMediaElement: en,
		HTMLMenuElement: en,
		HTMLMetaElement: en,
		HTMLMeterElement: en,
		HTMLModElement: en,
		HTMLObjectElement: en,
		HTMLOListElement: en,
		HTMLOptGroupElement: en,
		HTMLOptionElement: en,
		HTMLOptionsCollection: en,
		HTMLOutputElement: en,
		HTMLParagraphElement: en,
		HTMLParamElement: en,
		HTMLPictureElement: en,
		HTMLPreElement: en,
		HTMLProgressElement: en,
		HTMLQuoteElement: en,
		HTMLScriptElement: en,
		HTMLSelectElement: en,
		HTMLShadowElement: en,
		HTMLSlotElement: en,
		HTMLSourceElement: en,
		HTMLSpanElement: en,
		HTMLStyleElement: en,
		HTMLTableCaptionElement: en,
		HTMLTableCellElement: en,
		HTMLTableColElement: en,
		HTMLTableElement: en,
		HTMLTableRowElement: en,
		HTMLTableSectionElement: en,
		HTMLTemplateElement: en,
		HTMLTextAreaElement: en,
		HTMLTimeElement: en,
		HTMLTitleElement: en,
		HTMLTrackElement: en,
		HTMLUListElement: en,
		HTMLUnknownElement: en,
		HTMLVideoElement: en,
		IDBCursor: en,
		IDBCursorWithValue: en,
		IDBDatabase: en,
		IDBFactory: en,
		IDBIndex: en,
		IDBKeyRange: en,
		IDBObjectStore: en,
		IDBOpenDBRequest: en,
		IDBRequest: en,
		IDBTransaction: en,
		IDBVersionChangeEvent: en,
		IdleDeadline: en,
		IIRFilterNode: en,
		Image: en,
		ImageBitmap: en,
		ImageBitmapRenderingContext: en,
		ImageCapture: en,
		ImageData: en,
		indexedDB: Xi,
		innerHeight: Xi,
		innerWidth: Xi,
		InputEvent: en,
		IntersectionObserver: en,
		IntersectionObserverEntry: en,
		isSecureContext: Xi,
		KeyboardEvent: en,
		KeyframeEffect: en,
		length: Xi,
		localStorage: Xi,
		location: Xi,
		Location: en,
		locationbar: Xi,
		matchMedia: Xi,
		MediaDeviceInfo: en,
		MediaDevices: en,
		MediaElementAudioSourceNode: en,
		MediaEncryptedEvent: en,
		MediaError: en,
		MediaKeyMessageEvent: en,
		MediaKeySession: en,
		MediaKeyStatusMap: en,
		MediaKeySystemAccess: en,
		MediaList: en,
		MediaQueryList: en,
		MediaQueryListEvent: en,
		MediaRecorder: en,
		MediaSettingsRange: en,
		MediaSource: en,
		MediaStream: en,
		MediaStreamAudioDestinationNode: en,
		MediaStreamAudioSourceNode: en,
		MediaStreamEvent: en,
		MediaStreamTrack: en,
		MediaStreamTrackEvent: en,
		menubar: Xi,
		MessageChannel: en,
		MessageEvent: en,
		MessagePort: en,
		MIDIAccess: en,
		MIDIConnectionEvent: en,
		MIDIInput: en,
		MIDIInputMap: en,
		MIDIMessageEvent: en,
		MIDIOutput: en,
		MIDIOutputMap: en,
		MIDIPort: en,
		MimeType: en,
		MimeTypeArray: en,
		MouseEvent: en,
		moveBy: Xi,
		moveTo: Xi,
		MutationEvent: en,
		MutationObserver: en,
		MutationRecord: en,
		name: Xi,
		NamedNodeMap: en,
		NavigationPreloadManager: en,
		navigator: Xi,
		Navigator: en,
		NetworkInformation: en,
		Node: en,
		NodeFilter: Xi,
		NodeIterator: en,
		NodeList: en,
		Notification: en,
		OfflineAudioCompletionEvent: en,
		OfflineAudioContext: en,
		offscreenBuffering: Xi,
		OffscreenCanvas: en,
		open: Xi,
		openDatabase: Xi,
		Option: en,
		origin: Xi,
		OscillatorNode: en,
		outerHeight: Xi,
		outerWidth: Xi,
		PageTransitionEvent: en,
		pageXOffset: Xi,
		pageYOffset: Xi,
		PannerNode: en,
		parent: Xi,
		Path2D: en,
		PaymentAddress: en,
		PaymentRequest: en,
		PaymentRequestUpdateEvent: en,
		PaymentResponse: en,
		performance: Xi,
		Performance: en,
		PerformanceEntry: en,
		PerformanceLongTaskTiming: en,
		PerformanceMark: en,
		PerformanceMeasure: en,
		PerformanceNavigation: en,
		PerformanceNavigationTiming: en,
		PerformanceObserver: en,
		PerformanceObserverEntryList: en,
		PerformancePaintTiming: en,
		PerformanceResourceTiming: en,
		PerformanceTiming: en,
		PeriodicWave: en,
		Permissions: en,
		PermissionStatus: en,
		personalbar: Xi,
		PhotoCapabilities: en,
		Plugin: en,
		PluginArray: en,
		PointerEvent: en,
		PopStateEvent: en,
		postMessage: Xi,
		Presentation: en,
		PresentationAvailability: en,
		PresentationConnection: en,
		PresentationConnectionAvailableEvent: en,
		PresentationConnectionCloseEvent: en,
		PresentationConnectionList: en,
		PresentationReceiver: en,
		PresentationRequest: en,
		print: Xi,
		ProcessingInstruction: en,
		ProgressEvent: en,
		PromiseRejectionEvent: en,
		prompt: Xi,
		PushManager: en,
		PushSubscription: en,
		PushSubscriptionOptions: en,
		queueMicrotask: Xi,
		RadioNodeList: en,
		Range: en,
		ReadableStream: en,
		RemotePlayback: en,
		removeEventListener: Xi,
		Request: en,
		requestAnimationFrame: Xi,
		requestIdleCallback: Xi,
		resizeBy: Xi,
		ResizeObserver: en,
		ResizeObserverEntry: en,
		resizeTo: Xi,
		Response: en,
		RTCCertificate: en,
		RTCDataChannel: en,
		RTCDataChannelEvent: en,
		RTCDtlsTransport: en,
		RTCIceCandidate: en,
		RTCIceTransport: en,
		RTCPeerConnection: en,
		RTCPeerConnectionIceEvent: en,
		RTCRtpReceiver: en,
		RTCRtpSender: en,
		RTCSctpTransport: en,
		RTCSessionDescription: en,
		RTCStatsReport: en,
		RTCTrackEvent: en,
		screen: Xi,
		Screen: en,
		screenLeft: Xi,
		ScreenOrientation: en,
		screenTop: Xi,
		screenX: Xi,
		screenY: Xi,
		ScriptProcessorNode: en,
		scroll: Xi,
		scrollbars: Xi,
		scrollBy: Xi,
		scrollTo: Xi,
		scrollX: Xi,
		scrollY: Xi,
		SecurityPolicyViolationEvent: en,
		Selection: en,
		ServiceWorker: en,
		ServiceWorkerContainer: en,
		ServiceWorkerRegistration: en,
		sessionStorage: Xi,
		ShadowRoot: en,
		SharedWorker: en,
		SourceBuffer: en,
		SourceBufferList: en,
		speechSynthesis: Xi,
		SpeechSynthesisEvent: en,
		SpeechSynthesisUtterance: en,
		StaticRange: en,
		status: Xi,
		statusbar: Xi,
		StereoPannerNode: en,
		stop: Xi,
		Storage: en,
		StorageEvent: en,
		StorageManager: en,
		styleMedia: Xi,
		StyleSheet: en,
		StyleSheetList: en,
		SubtleCrypto: en,
		SVGAElement: en,
		SVGAngle: en,
		SVGAnimatedAngle: en,
		SVGAnimatedBoolean: en,
		SVGAnimatedEnumeration: en,
		SVGAnimatedInteger: en,
		SVGAnimatedLength: en,
		SVGAnimatedLengthList: en,
		SVGAnimatedNumber: en,
		SVGAnimatedNumberList: en,
		SVGAnimatedPreserveAspectRatio: en,
		SVGAnimatedRect: en,
		SVGAnimatedString: en,
		SVGAnimatedTransformList: en,
		SVGAnimateElement: en,
		SVGAnimateMotionElement: en,
		SVGAnimateTransformElement: en,
		SVGAnimationElement: en,
		SVGCircleElement: en,
		SVGClipPathElement: en,
		SVGComponentTransferFunctionElement: en,
		SVGDefsElement: en,
		SVGDescElement: en,
		SVGDiscardElement: en,
		SVGElement: en,
		SVGEllipseElement: en,
		SVGFEBlendElement: en,
		SVGFEColorMatrixElement: en,
		SVGFEComponentTransferElement: en,
		SVGFECompositeElement: en,
		SVGFEConvolveMatrixElement: en,
		SVGFEDiffuseLightingElement: en,
		SVGFEDisplacementMapElement: en,
		SVGFEDistantLightElement: en,
		SVGFEDropShadowElement: en,
		SVGFEFloodElement: en,
		SVGFEFuncAElement: en,
		SVGFEFuncBElement: en,
		SVGFEFuncGElement: en,
		SVGFEFuncRElement: en,
		SVGFEGaussianBlurElement: en,
		SVGFEImageElement: en,
		SVGFEMergeElement: en,
		SVGFEMergeNodeElement: en,
		SVGFEMorphologyElement: en,
		SVGFEOffsetElement: en,
		SVGFEPointLightElement: en,
		SVGFESpecularLightingElement: en,
		SVGFESpotLightElement: en,
		SVGFETileElement: en,
		SVGFETurbulenceElement: en,
		SVGFilterElement: en,
		SVGForeignObjectElement: en,
		SVGGElement: en,
		SVGGeometryElement: en,
		SVGGradientElement: en,
		SVGGraphicsElement: en,
		SVGImageElement: en,
		SVGLength: en,
		SVGLengthList: en,
		SVGLinearGradientElement: en,
		SVGLineElement: en,
		SVGMarkerElement: en,
		SVGMaskElement: en,
		SVGMatrix: en,
		SVGMetadataElement: en,
		SVGMPathElement: en,
		SVGNumber: en,
		SVGNumberList: en,
		SVGPathElement: en,
		SVGPatternElement: en,
		SVGPoint: en,
		SVGPointList: en,
		SVGPolygonElement: en,
		SVGPolylineElement: en,
		SVGPreserveAspectRatio: en,
		SVGRadialGradientElement: en,
		SVGRect: en,
		SVGRectElement: en,
		SVGScriptElement: en,
		SVGSetElement: en,
		SVGStopElement: en,
		SVGStringList: en,
		SVGStyleElement: en,
		SVGSVGElement: en,
		SVGSwitchElement: en,
		SVGSymbolElement: en,
		SVGTextContentElement: en,
		SVGTextElement: en,
		SVGTextPathElement: en,
		SVGTextPositioningElement: en,
		SVGTitleElement: en,
		SVGTransform: en,
		SVGTransformList: en,
		SVGTSpanElement: en,
		SVGUnitTypes: en,
		SVGUseElement: en,
		SVGViewElement: en,
		TaskAttributionTiming: en,
		Text: en,
		TextEvent: en,
		TextMetrics: en,
		TextTrack: en,
		TextTrackCue: en,
		TextTrackCueList: en,
		TextTrackList: en,
		TimeRanges: en,
		toolbar: Xi,
		top: Xi,
		Touch: en,
		TouchEvent: en,
		TouchList: en,
		TrackEvent: en,
		TransitionEvent: en,
		TreeWalker: en,
		UIEvent: en,
		ValidityState: en,
		visualViewport: Xi,
		VisualViewport: en,
		VTTCue: en,
		WaveShaperNode: en,
		WebAssembly: Xi,
		WebGL2RenderingContext: en,
		WebGLActiveInfo: en,
		WebGLBuffer: en,
		WebGLContextEvent: en,
		WebGLFramebuffer: en,
		WebGLProgram: en,
		WebGLQuery: en,
		WebGLRenderbuffer: en,
		WebGLRenderingContext: en,
		WebGLSampler: en,
		WebGLShader: en,
		WebGLShaderPrecisionFormat: en,
		WebGLSync: en,
		WebGLTexture: en,
		WebGLTransformFeedback: en,
		WebGLUniformLocation: en,
		WebGLVertexArrayObject: en,
		WebSocket: en,
		WheelEvent: en,
		Window: en,
		Worker: en,
		WritableStream: en,
		XMLDocument: en,
		XMLHttpRequest: en,
		XMLHttpRequestEventTarget: en,
		XMLHttpRequestUpload: en,
		XMLSerializer: en,
		XPathEvaluator: en,
		XPathExpression: en,
		XPathResult: en,
		XSLTProcessor: en
	}
for (const e of ['window', 'global', 'self', 'globalThis']) on[e] = on
function an(e) {
	let t = on
	for (const s of e) {
		if ('string' != typeof s) return null
		if (((t = t[s]), !t)) return null
	}
	return t[Gi]
}
class ln extends pe {
	constructor() {
		super(...arguments), (this.isReassigned = !0)
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		switch (e.type) {
			case 0:
			case 1:
				return void (an([this.name, ...t].slice(0, -1)) || super.deoptimizeArgumentsOnInteractionAtPath(e, t, s))
			case 2: {
				const i = an([this.name, ...t])
				return void (i ? i.deoptimizeArgumentsOnCall(e) : super.deoptimizeArgumentsOnInteractionAtPath(e, t, s))
			}
		}
	}
	getLiteralValueAtPath(e, t, s) {
		const i = an([this.name, ...e])
		return i ? i.getLiteralValue() : ne
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		switch (t.type) {
			case 0:
				return 0 === e.length ? 'undefined' !== this.name && !an([this.name]) : !an([this.name, ...e].slice(0, -1))
			case 1:
				return !0
			case 2: {
				const i = an([this.name, ...e])
				return !i || i.hasEffectsWhenCalled(t, s)
			}
		}
	}
}
const cn = { __proto__: null, class: !0, const: !0, let: !0, var: !0 }
class hn extends ei {
	constructor() {
		super(...arguments), (this.variable = null), (this.isTDZAccess = null)
	}
	addExportedVariables(e, t) {
		t.has(this.variable) && e.push(this.variable)
	}
	bind() {
		!this.variable && Fi(this, this.parent) && ((this.variable = this.scope.findVariable(this.name)), this.variable.addReference(this))
	}
	declare(e, t) {
		let s
		const { treeshake: i } = this.context.options
		switch (e) {
			case 'var':
				;(s = this.scope.addDeclaration(this, this.context, t, !0)), i && i.correctVarValueBeforeDeclaration && s.markInitializersForDeoptimization()
				break
			case 'function':
			case 'let':
			case 'const':
			case 'class':
				s = this.scope.addDeclaration(this, this.context, t, !1)
				break
			case 'parameter':
				s = this.scope.addParameterDeclaration(this)
				break
			default:
				throw new Error(`Internal Error: Unexpected identifier kind ${e}.`)
		}
		return (s.kind = e), [(this.variable = s)]
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		this.variable.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
	}
	deoptimizePath(e) {
		0 !== e.length || this.scope.contains(this.name) || this.disallowImportReassignment(), this.variable?.deoptimizePath(e)
	}
	getLiteralValueAtPath(e, t, s) {
		return this.getVariableRespectingTDZ().getLiteralValueAtPath(e, t, s)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		const [n, r] = this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(e, t, s, i)
		return [n, r || this.isPureFunction(e)]
	}
	hasEffects(e) {
		return (
			this.deoptimized || this.applyDeoptimizations(),
			!(!this.isPossibleTDZ() || 'var' === this.variable.kind) ||
				(this.context.options.treeshake.unknownGlobalSideEffects && this.variable instanceof ln && !this.isPureFunction(X) && this.variable.hasEffectsOnInteractionAtPath(X, he, e))
		)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		switch (t.type) {
			case 0:
				return null !== this.variable && !this.isPureFunction(e) && this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(e, t, s)
			case 1:
				return (e.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsOnInteractionAtPath(e, t, s)
			case 2:
				return !this.isPureFunction(e) && this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(e, t, s)
		}
	}
	include() {
		this.deoptimized || this.applyDeoptimizations(), this.included || ((this.included = !0), null !== this.variable && this.context.includeVariableInModule(this.variable))
	}
	includeCallArguments(e, t) {
		this.variable.includeCallArguments(e, t)
	}
	isPossibleTDZ() {
		if (null !== this.isTDZAccess) return this.isTDZAccess
		if (!(this.variable instanceof Pi && this.variable.kind && this.variable.kind in cn && this.variable.module === this.context.module)) return (this.isTDZAccess = !1)
		let e
		return this.variable.declarations && 1 === this.variable.declarations.length && (e = this.variable.declarations[0]) && this.start < e.start && un(this) === un(e)
			? (this.isTDZAccess = !0)
			: this.variable.initReached
			? (this.isTDZAccess = !1)
			: (this.isTDZAccess = !0)
	}
	markDeclarationReached() {
		this.variable.initReached = !0
	}
	render(e, { snippets: { getPropertyAccess: t }, useOriginalName: s }, { renderedParentType: i, isCalleeOfRenderedParent: n, isShorthandProperty: r } = me) {
		if (this.variable) {
			const o = this.variable.getName(t, s)
			o !== this.name && (e.overwrite(this.start, this.end, o, { contentOnly: !0, storeName: !0 }), r && e.prependRight(this.start, `${this.name}: `)),
				'eval' === o && i === Ps && n && e.appendRight(this.start, '0, ')
		}
	}
	applyDeoptimizations() {
		;(this.deoptimized = !0), this.variable instanceof Pi && (this.variable.consolidateInitializers(), this.context.requestTreeshakingPass())
	}
	disallowImportReassignment() {
		return this.context.error(Vt(this.name, this.context.module.id), this.start)
	}
	getVariableRespectingTDZ() {
		return this.isPossibleTDZ() ? ae : this.variable
	}
	isPureFunction(e) {
		let t = this.context.manualPureFunctions[this.name]
		for (const s of e) {
			if (!t) return !1
			if (t[ji]) return !0
			t = t[s]
		}
		return t?.[ji]
	}
}
function un(e) {
	for (; e && !/^Program|Function/.test(e.type); ) e = e.parent
	return e
}
function dn(e, t, s, i) {
	if ((t.remove(s, i), e.annotations))
		for (const i of e.annotations) {
			if (!(i.start < s)) return
			t.remove(i.start, i.end)
		}
}
function pn(e, t) {
	if ((e.annotations || e.parent.type !== Rs || (e = e.parent), e.annotations)) for (const s of e.annotations) t.remove(s.start, s.end)
}
const fn = { isNoStatement: !0 }
function mn(e, t, s = 0) {
	let i, n
	for (i = e.indexOf(t, s); ; ) {
		if (-1 === (s = e.indexOf('/', s)) || s >= i) return i
		;(n = e.charCodeAt(++s)), ++s, (s = 47 === n ? e.indexOf('\n', s) + 1 : e.indexOf('*/', s) + 2) > i && (i = e.indexOf(t, s))
	}
}
const gn = /\S/g
function yn(e, t) {
	gn.lastIndex = t
	return gn.exec(e).index
}
function xn(e) {
	let t,
		s,
		i = 0
	for (t = e.indexOf('\n', i); ; ) {
		if (((i = e.indexOf('/', i)), -1 === i || i > t)) return [t, t + 1]
		if (((s = e.charCodeAt(i + 1)), 47 === s)) return [i, t + 1]
		;(i = e.indexOf('*/', i + 3) + 2), i > t && (t = e.indexOf('\n', i))
	}
}
function En(e, t, s, i, n) {
	let r,
		o,
		a,
		l,
		c = e[0],
		h = !c.included || c.needsBoundaries
	h && (l = s + xn(t.original.slice(s, c.start))[1])
	for (let s = 1; s <= e.length; s++)
		(r = c),
			(o = l),
			(a = h),
			(c = e[s]),
			(h = void 0 !== c && (!c.included || c.needsBoundaries)),
			a || h ? ((l = r.end + xn(t.original.slice(r.end, void 0 === c ? i : c.start))[1]), r.included ? (a ? r.render(t, n, { end: l, start: o }) : r.render(t, n)) : dn(r, t, o, l)) : r.render(t, n)
}
function bn(e, t, s, i) {
	const n = []
	let r,
		o,
		a,
		l,
		c = s - 1
	for (const i of e) {
		for (
			void 0 !== r && (c = r.end + mn(t.original.slice(r.end, i.start), ',')), o = a = c + 1 + xn(t.original.slice(c + 1, i.start))[1];
			(l = t.original.charCodeAt(o)), 32 === l || 9 === l || 10 === l || 13 === l;

		)
			o++
		void 0 !== r && n.push({ contentEnd: a, end: o, node: r, separator: c, start: s }), (r = i), (s = o)
	}
	return n.push({ contentEnd: i, end: i, node: r, separator: null, start: s }), n
}
function vn(e, t, s) {
	for (;;) {
		const [i, n] = xn(e.original.slice(t, s))
		if (-1 === i) break
		e.remove(t + i, (t += n))
	}
}
class Sn extends Vi {
	addDeclaration(e, t, s, i) {
		if (i) {
			const n = this.parent.addDeclaration(e, t, s, i)
			return n.markInitializersForDeoptimization(), n
		}
		return super.addDeclaration(e, t, s, !1)
	}
}
class An extends ei {
	initialise() {
		var e, t
		this.directive &&
			'use strict' !== this.directive &&
			this.parent.type === Ts &&
			this.context.log(
				Ae,
				((e = this.directive), { code: 'MODULE_LEVEL_DIRECTIVE', id: (t = this.context.module.id), message: `Module level directives cause errors when bundled, "${e}" in "${V(t)}" was ignored.` }),
				this.start
			)
	}
	render(e, t) {
		super.render(e, t), this.included && this.insertSemicolon(e)
	}
	shouldBeIncluded(e) {
		return this.directive && 'use strict' !== this.directive ? this.parent.type !== Ts : super.shouldBeIncluded(e)
	}
	applyDeoptimizations() {}
}
class kn extends ei {
	constructor() {
		super(...arguments), (this.directlyIncluded = !1)
	}
	addImplicitReturnExpressionToScope() {
		const e = this.body[this.body.length - 1]
		;(e && 'ReturnStatement' === e.type) || this.scope.addReturnExpression(ae)
	}
	createScope(e) {
		this.scope = this.parent.preventChildBlockScope ? e : new Sn(e)
	}
	hasEffects(e) {
		if (this.deoptimizeBody) return !0
		for (const t of this.body) {
			if (e.brokenFlow) break
			if (t.hasEffects(e)) return !0
		}
		return !1
	}
	include(e, t) {
		if (!this.deoptimizeBody || !this.directlyIncluded) {
			;(this.included = !0), (this.directlyIncluded = !0), this.deoptimizeBody && (t = !0)
			for (const s of this.body) (t || s.shouldBeIncluded(e)) && s.include(e, t)
		}
	}
	initialise() {
		const e = this.body[0]
		this.deoptimizeBody = e instanceof An && 'use asm' === e.directive
	}
	render(e, t) {
		this.body.length > 0 ? En(this.body, e, this.start + 1, this.end - 1, t) : super.render(e, t)
	}
}
class In extends ei {
	constructor() {
		super(...arguments), (this.declarationInit = null)
	}
	addExportedVariables(e, t) {
		this.argument.addExportedVariables(e, t)
	}
	declare(e, t) {
		return (this.declarationInit = t), this.argument.declare(e, ae)
	}
	deoptimizePath(e) {
		0 === e.length && this.argument.deoptimizePath(X)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return e.length > 0 || this.argument.hasEffectsOnInteractionAtPath(X, t, s)
	}
	markDeclarationReached() {
		this.argument.markDeclarationReached()
	}
	applyDeoptimizations() {
		;(this.deoptimized = !0), null !== this.declarationInit && (this.declarationInit.deoptimizePath([q, q]), this.context.requestTreeshakingPass())
	}
}
class wn extends ei {
	constructor() {
		super(...arguments), (this.objectEntity = null), (this.deoptimizedReturn = !1)
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		if (2 === e.type) {
			const { parameters: t } = this.scope,
				{ args: s } = e
			let i = !1
			for (let e = 0; e < s.length - 1; e++) {
				const n = this.params[e],
					r = s[e + 1]
				i || n instanceof In
					? ((i = !0), r.deoptimizePath(Q))
					: n instanceof hn
					? (t[e][0].addEntityToBeDeoptimized(r), this.addArgumentToBeDeoptimized(r))
					: n
					? r.deoptimizePath(Q)
					: this.addArgumentToBeDeoptimized(r)
			}
		} else this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(e, t, s)
	}
	deoptimizePath(e) {
		if ((this.getObjectEntity().deoptimizePath(e), 1 === e.length && e[0] === q)) {
			this.scope.getReturnExpression().deoptimizePath(Q)
			for (const e of this.scope.parameters) for (const t of e) t.deoptimizePath(Q)
		}
	}
	getLiteralValueAtPath(e, t, s) {
		return this.getObjectEntity().getLiteralValueAtPath(e, t, s)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return e.length > 0
			? this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e, t, s, i)
			: this.async
			? (this.deoptimizedReturn || ((this.deoptimizedReturn = !0), this.scope.getReturnExpression().deoptimizePath(Q), this.context.requestTreeshakingPass()), le)
			: [this.scope.getReturnExpression(), !1]
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		if (e.length > 0 || 2 !== t.type) return this.getObjectEntity().hasEffectsOnInteractionAtPath(e, t, s)
		if (this.annotationNoSideEffects) return !1
		if (this.async) {
			const { propertyReadSideEffects: e } = this.context.options.treeshake,
				t = this.scope.getReturnExpression()
			if (t.hasEffectsOnInteractionAtPath(['then'], de, s) || (e && ('always' === e || t.hasEffectsOnInteractionAtPath(['then'], he, s)))) return !0
		}
		for (const e of this.params) if (e.hasEffects(s)) return !0
		return !1
	}
	include(e, t) {
		this.deoptimized || this.applyDeoptimizations(), (this.included = !0)
		const { brokenFlow: s } = e
		;(e.brokenFlow = !1), this.body.include(e, t), (e.brokenFlow = s)
	}
	includeCallArguments(e, t) {
		this.scope.includeCallArguments(e, t)
	}
	initialise() {
		this.scope.addParameterVariables(
			this.params.map((e) => e.declare('parameter', ae)),
			this.params[this.params.length - 1] instanceof In
		),
			this.body instanceof kn ? this.body.addImplicitReturnExpressionToScope() : this.scope.addReturnExpression(this.body)
	}
	parseNode(e) {
		e.body.type === ws && (this.body = new kn(e.body, this, this.scope.hoistedBodyVarScope)), super.parseNode(e)
	}
	addArgumentToBeDeoptimized(e) {}
	applyDeoptimizations() {}
}
wn.prototype.preventChildBlockScope = !0
class Pn extends wn {
	constructor() {
		super(...arguments), (this.objectEntity = null)
	}
	createScope(e) {
		this.scope = new zi(e, this.context)
	}
	hasEffects() {
		return this.deoptimized || this.applyDeoptimizations(), !1
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		if (super.hasEffectsOnInteractionAtPath(e, t, s)) return !0
		if (this.annotationNoSideEffects) return !1
		if (2 === t.type) {
			const { ignore: e, brokenFlow: t } = s
			if (((s.ignore = { breaks: !1, continues: !1, labels: new Set(), returnYield: !0, this: !1 }), this.body.hasEffects(s))) return !0
			;(s.ignore = e), (s.brokenFlow = t)
		}
		return !1
	}
	include(e, t) {
		super.include(e, t)
		for (const s of this.params) s instanceof hn || s.include(e, t)
	}
	getObjectEntity() {
		return null !== this.objectEntity ? this.objectEntity : (this.objectEntity = new li([], ui))
	}
}
function Cn(e, { exportNamesByVariable: t, snippets: { _: s, getObject: i, getPropertyAccess: n } }, r = '') {
	if (1 === e.length && 1 === t.get(e[0]).length) {
		const i = e[0]
		return `exports('${t.get(i)}',${s}${i.getName(n)}${r})`
	}
	{
		const s = []
		for (const i of e) for (const e of t.get(i)) s.push([e, i.getName(n) + r])
		return `exports(${i(s, { lineBreakIndent: null })})`
	}
}
function $n(e, t, s, i, { exportNamesByVariable: n, snippets: { _: r } }) {
	i.prependRight(t, `exports('${n.get(e)}',${r}`), i.appendLeft(s, ')')
}
function Nn(e, t, s, i, n, r) {
	const { _: o, getPropertyAccess: a } = r.snippets
	n.appendLeft(s, `,${o}${Cn([e], r)},${o}${e.getName(a)}`), i && (n.prependRight(t, '('), n.appendLeft(s, ')'))
}
class _n extends ei {
	addExportedVariables(e, t) {
		for (const s of this.properties) 'Property' === s.type ? s.value.addExportedVariables(e, t) : s.argument.addExportedVariables(e, t)
	}
	declare(e, t) {
		const s = []
		for (const i of this.properties) s.push(...i.declare(e, t))
		return s
	}
	deoptimizePath(e) {
		if (0 === e.length) for (const t of this.properties) t.deoptimizePath(e)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		for (const e of this.properties) if (e.hasEffectsOnInteractionAtPath(X, t, s)) return !0
		return !1
	}
	markDeclarationReached() {
		for (const e of this.properties) e.markDeclarationReached()
	}
}
class Rn extends Pi {
	constructor(e) {
		super('arguments', null, ae, e), (this.deoptimizedArguments = [])
	}
	addArgumentToBeDeoptimized(e) {
		this.included ? e.deoptimizePath(Q) : this.deoptimizedArguments.push(e)
	}
	hasEffectsOnInteractionAtPath(e, { type: t }) {
		return 0 !== t || e.length > 1
	}
	include() {
		super.include()
		for (const e of this.deoptimizedArguments) e.deoptimizePath(Q)
		this.deoptimizedArguments.length = 0
	}
}
class Mn extends Ri {
	constructor(e) {
		super('this', null, e)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return (s.replacedVariableInits.get(this) || ae).hasEffectsOnInteractionAtPath(e, t, s)
	}
}
class On extends zi {
	constructor(e, t) {
		super(e, t), this.variables.set('arguments', (this.argumentsVariable = new Rn(t))), this.variables.set('this', (this.thisVariable = new Mn(t)))
	}
	findLexicalBoundary() {
		return this
	}
	includeCallArguments(e, t) {
		if ((super.includeCallArguments(e, t), this.argumentsVariable.included)) for (const s of t) s.included || s.include(e, !1)
	}
}
class Dn extends wn {
	constructor() {
		super(...arguments), (this.objectEntity = null)
	}
	createScope(e) {
		;(this.scope = new On(e, this.context)), (this.constructedEntity = new li(Object.create(null), ui)), this.scope.thisVariable.addEntityToBeDeoptimized(this.constructedEntity)
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		super.deoptimizeArgumentsOnInteractionAtPath(e, t, s), 2 === e.type && 0 === t.length && e.args[0] && this.scope.thisVariable.addEntityToBeDeoptimized(e.args[0])
	}
	hasEffects(e) {
		return this.deoptimized || this.applyDeoptimizations(), !this.annotationNoSideEffects && !!this.id?.hasEffects(e)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		if (super.hasEffectsOnInteractionAtPath(e, t, s)) return !0
		if (this.annotationNoSideEffects) return !1
		if (2 === t.type) {
			const e = s.replacedVariableInits.get(this.scope.thisVariable)
			s.replacedVariableInits.set(this.scope.thisVariable, t.withNew ? this.constructedEntity : ae)
			const { brokenFlow: i, ignore: n, replacedVariableInits: r } = s
			if (((s.ignore = { breaks: !1, continues: !1, labels: new Set(), returnYield: !0, this: t.withNew }), this.body.hasEffects(s))) return !0
			;(s.brokenFlow = i), e ? r.set(this.scope.thisVariable, e) : r.delete(this.scope.thisVariable), (s.ignore = n)
		}
		return !1
	}
	include(e, t) {
		super.include(e, t), this.id?.include()
		const s = this.scope.argumentsVariable.included
		for (const i of this.params) (i instanceof hn && !s) || i.include(e, t)
	}
	initialise() {
		super.initialise(), this.id?.declare('function', this)
	}
	addArgumentToBeDeoptimized(e) {
		this.scope.argumentsVariable.addArgumentToBeDeoptimized(e)
	}
	getObjectEntity() {
		return null !== this.objectEntity ? this.objectEntity : (this.objectEntity = new li([{ key: 'prototype', kind: 'init', property: new li([], ui) }], ui))
	}
}
class Ln extends ei {
	hasEffects() {
		return this.deoptimized || this.applyDeoptimizations(), !0
	}
	include(e, t) {
		if ((this.deoptimized || this.applyDeoptimizations(), !this.included)) {
			this.included = !0
			e: if (!this.context.usesTopLevelAwait) {
				let e = this.parent
				do {
					if (e instanceof Dn || e instanceof Pn) break e
				} while ((e = e.parent))
				this.context.usesTopLevelAwait = !0
			}
		}
		this.argument.include(e, t)
	}
}
const Tn = {
	'!=': (e, t) => e != t,
	'!==': (e, t) => e !== t,
	'%': (e, t) => e % t,
	'&': (e, t) => e & t,
	'*': (e, t) => e * t,
	'**': (e, t) => e ** t,
	'+': (e, t) => e + t,
	'-': (e, t) => e - t,
	'/': (e, t) => e / t,
	'<': (e, t) => e < t,
	'<<': (e, t) => e << t,
	'<=': (e, t) => e <= t,
	'==': (e, t) => e == t,
	'===': (e, t) => e === t,
	'>': (e, t) => e > t,
	'>=': (e, t) => e >= t,
	'>>': (e, t) => e >> t,
	'>>>': (e, t) => e >>> t,
	'^': (e, t) => e ^ t,
	'|': (e, t) => e | t
}
function Vn(e, t, s) {
	if (s.arguments.length > 0)
		if (s.arguments[s.arguments.length - 1].included) for (const i of s.arguments) i.render(e, t)
		else {
			let i = s.arguments.length - 2
			for (; i >= 0 && !s.arguments[i].included; ) i--
			if (i >= 0) {
				for (let n = 0; n <= i; n++) s.arguments[n].render(e, t)
				e.remove(mn(e.original, ',', s.arguments[i].end), s.end - 1)
			} else e.remove(mn(e.original, '(', s.callee.end) + 1, s.end - 1)
		}
}
class Bn extends ei {
	deoptimizeArgumentsOnInteractionAtPath() {}
	getLiteralValueAtPath(e) {
		return e.length > 0 || (null === this.value && 110 !== this.context.code.charCodeAt(this.start)) || 'bigint' == typeof this.value || 47 === this.context.code.charCodeAt(this.start)
			? ne
			: this.value
	}
	getReturnExpressionWhenCalledAtPath(e) {
		return 1 !== e.length ? le : bs(this.members, e[0])
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		switch (t.type) {
			case 0:
				return e.length > (null === this.value ? 0 : 1)
			case 1:
				return !0
			case 2:
				return !!(this.included && this.value instanceof RegExp && (this.value.global || this.value.sticky)) || 1 !== e.length || Es(this.members, e[0], t, s)
		}
	}
	initialise() {
		this.members = (function (e) {
			if (e instanceof RegExp) return ys
			switch (typeof e) {
				case 'boolean':
					return ms
				case 'number':
					return gs
				case 'string':
					return xs
			}
			return Object.create(null)
		})(this.value)
	}
	parseNode(e) {
		;(this.value = e.value), (this.regex = e.regex), super.parseNode(e)
	}
	render(e) {
		'string' == typeof this.value && e.indentExclusionRanges.push([this.start + 1, this.end - 1])
	}
}
function zn(e) {
	return e.computed
		? (function (e) {
				if (e instanceof Bn) return String(e.value)
				return null
		  })(e.property)
		: e.property.name
}
function Fn(e) {
	const t = e.propertyKey,
		s = e.object
	if ('string' == typeof t) {
		if (s instanceof hn)
			return [
				{ key: s.name, pos: s.start },
				{ key: t, pos: e.property.start }
			]
		if (s instanceof jn) {
			const i = Fn(s)
			return i && [...i, { key: t, pos: e.property.start }]
		}
	}
	return null
}
class jn extends ei {
	constructor() {
		super(...arguments), (this.variable = null), (this.assignmentDeoptimized = !1), (this.bound = !1), (this.expressionsToBeDeoptimized = []), (this.isUndefined = !1)
	}
	bind() {
		this.bound = !0
		const e = Fn(this),
			t = e && this.scope.findVariable(e[0].key)
		if (t?.isNamespace) {
			const s = Un(t, e.slice(1), this.context)
			s
				? 'undefined' === s
					? (this.isUndefined = !0)
					: ((this.variable = s),
					  this.scope.addNamespaceMemberAccess(
							(function (e) {
								let t = e[0].key
								for (let s = 1; s < e.length; s++) t += '.' + e[s].key
								return t
							})(e),
							s
					  ))
				: super.bind()
		} else super.bind()
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		this.variable
			? this.variable.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
			: this.isUndefined || (t.length < 7 ? this.object.deoptimizeArgumentsOnInteractionAtPath(e, [this.getPropertyKey(), ...t], s) : ce(e))
	}
	deoptimizeCache() {
		const { expressionsToBeDeoptimized: e, object: t } = this
		;(this.expressionsToBeDeoptimized = ye), (this.propertyKey = q), t.deoptimizePath(Q)
		for (const t of e) t.deoptimizeCache()
	}
	deoptimizePath(e) {
		if ((0 === e.length && this.disallowNamespaceReassignment(), this.variable)) this.variable.deoptimizePath(e)
		else if (!this.isUndefined && e.length < 7) {
			const t = this.getPropertyKey()
			this.object.deoptimizePath([t === q ? H : t, ...e])
		}
	}
	getLiteralValueAtPath(e, t, s) {
		return this.variable
			? this.variable.getLiteralValueAtPath(e, t, s)
			: this.isUndefined
			? void 0
			: this.propertyKey !== q && e.length < 7
			? (this.expressionsToBeDeoptimized.push(s), this.object.getLiteralValueAtPath([this.getPropertyKey(), ...e], t, s))
			: ne
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return this.variable
			? this.variable.getReturnExpressionWhenCalledAtPath(e, t, s, i)
			: this.isUndefined
			? [rs, !1]
			: this.propertyKey !== q && e.length < 7
			? (this.expressionsToBeDeoptimized.push(i), this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...e], t, s, i))
			: le
	}
	hasEffects(e) {
		return this.deoptimized || this.applyDeoptimizations(), this.property.hasEffects(e) || this.object.hasEffects(e) || this.hasAccessEffect(e)
	}
	hasEffectsAsAssignmentTarget(e, t) {
		return (
			t && !this.deoptimized && this.applyDeoptimizations(),
			this.assignmentDeoptimized || this.applyAssignmentDeoptimization(),
			this.property.hasEffects(e) || this.object.hasEffects(e) || (t && this.hasAccessEffect(e)) || this.hasEffectsOnInteractionAtPath(X, this.assignmentInteraction, e)
		)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return this.variable
			? this.variable.hasEffectsOnInteractionAtPath(e, t, s)
			: !!this.isUndefined || !(e.length < 7) || this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey(), ...e], t, s)
	}
	include(e, t) {
		this.deoptimized || this.applyDeoptimizations(), this.includeProperties(e, t)
	}
	includeAsAssignmentTarget(e, t, s) {
		this.assignmentDeoptimized || this.applyAssignmentDeoptimization(), s ? this.include(e, t) : this.includeProperties(e, t)
	}
	includeCallArguments(e, t) {
		this.variable ? this.variable.includeCallArguments(e, t) : super.includeCallArguments(e, t)
	}
	initialise() {
		;(this.propertyKey = zn(this)), (this.accessInteraction = { args: [this.object], type: 0 })
	}
	isSkippedAsOptional(e) {
		return !this.variable && !this.isUndefined && (this.object.isSkippedAsOptional?.(e) || (this.optional && null == this.object.getLiteralValueAtPath(X, se, e)))
	}
	render(e, t, { renderedParentType: s, isCalleeOfRenderedParent: i, renderedSurroundingElement: n } = me) {
		if (this.variable || this.isUndefined) {
			const {
				snippets: { getPropertyAccess: n }
			} = t
			let r = this.variable ? this.variable.getName(n) : 'undefined'
			s && i && (r = '0, ' + r), e.overwrite(this.start, this.end, r, { contentOnly: !0, storeName: !0 })
		} else s && i && e.appendRight(this.start, '0, '), this.object.render(e, t, { renderedSurroundingElement: n }), this.property.render(e, t)
	}
	setAssignedValue(e) {
		this.assignmentInteraction = { args: [this.object, e], type: 1 }
	}
	applyDeoptimizations() {
		this.deoptimized = !0
		const { propertyReadSideEffects: e } = this.context.options.treeshake
		if (this.bound && e && !this.variable && !this.isUndefined) {
			const e = this.getPropertyKey()
			this.object.deoptimizeArgumentsOnInteractionAtPath(this.accessInteraction, [e], se), this.context.requestTreeshakingPass()
		}
	}
	applyAssignmentDeoptimization() {
		this.assignmentDeoptimized = !0
		const { propertyReadSideEffects: e } = this.context.options.treeshake
		this.bound &&
			e &&
			!this.variable &&
			!this.isUndefined &&
			(this.object.deoptimizeArgumentsOnInteractionAtPath(this.assignmentInteraction, [this.getPropertyKey()], se), this.context.requestTreeshakingPass())
	}
	disallowNamespaceReassignment() {
		if (this.object instanceof hn) {
			this.scope.findVariable(this.object.name).isNamespace &&
				(this.variable && this.context.includeVariableInModule(this.variable), this.context.log(Ae, Vt(this.object.name, this.context.module.id), this.start))
		}
	}
	getPropertyKey() {
		if (null === this.propertyKey) {
			this.propertyKey = q
			const e = this.property.getLiteralValueAtPath(X, se, this)
			return (this.propertyKey = e === Y ? e : 'symbol' == typeof e ? q : String(e))
		}
		return this.propertyKey
	}
	hasAccessEffect(e) {
		const { propertyReadSideEffects: t } = this.context.options.treeshake
		return !(this.variable || this.isUndefined) && t && ('always' === t || this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey()], this.accessInteraction, e))
	}
	includeProperties(e, t) {
		this.included || ((this.included = !0), this.variable && this.context.includeVariableInModule(this.variable)), this.object.include(e, t), this.property.include(e, t)
	}
}
function Un(e, t, s) {
	if (0 === t.length) return e
	if (!e.isNamespace || e instanceof fe) return null
	const i = t[0].key,
		n = e.context.traceExport(i)
	if (!n) {
		if (1 === t.length) {
			const n = e.context.fileName
			return s.log(Ae, Ut(i, s.module.id, n), t[0].pos), 'undefined'
		}
		return null
	}
	return Un(n, t.slice(1), s)
}
class Gn extends ei {
	constructor() {
		super(...arguments), (this.returnExpression = null), (this.deoptimizableDependentExpressions = []), (this.expressionsToBeDeoptimized = new Set())
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		const { args: i } = e,
			[n, r] = this.getReturnExpression(s)
		if (r) return
		const o = i.filter((e) => !!e && e !== ae)
		if (0 !== o.length)
			if (n === ae) for (const e of o) e.deoptimizePath(Q)
			else
				s.withTrackedEntityAtPath(
					t,
					n,
					() => {
						for (const e of o) this.expressionsToBeDeoptimized.add(e)
						n.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
					},
					null
				)
	}
	deoptimizeCache() {
		if (this.returnExpression?.[0] !== ae) {
			this.returnExpression = le
			const { deoptimizableDependentExpressions: e, expressionsToBeDeoptimized: t } = this
			;(this.expressionsToBeDeoptimized = xe), (this.deoptimizableDependentExpressions = ye)
			for (const t of e) t.deoptimizeCache()
			for (const e of t) e.deoptimizePath(Q)
		}
	}
	deoptimizePath(e) {
		if (0 === e.length || this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e, this)) return
		const [t] = this.getReturnExpression()
		t !== ae && t.deoptimizePath(e)
	}
	getLiteralValueAtPath(e, t, s) {
		const [i] = this.getReturnExpression(t)
		return i === ae ? ne : t.withTrackedEntityAtPath(e, i, () => (this.deoptimizableDependentExpressions.push(s), i.getLiteralValueAtPath(e, t, s)), ne)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		const n = this.getReturnExpression(s)
		return n[0] === ae
			? n
			: s.withTrackedEntityAtPath(
					e,
					n,
					() => {
						this.deoptimizableDependentExpressions.push(i)
						const [r, o] = n[0].getReturnExpressionWhenCalledAtPath(e, t, s, i)
						return [r, o || n[1]]
					},
					le
			  )
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		const { type: i } = t
		if (2 === i) {
			const { args: i, withNew: n } = t
			if ((n ? s.instantiated : s.called).trackEntityAtPathAndGetIfTracked(e, i, this)) return !1
		} else if ((1 === i ? s.assigned : s.accessed).trackEntityAtPathAndGetIfTracked(e, this)) return !1
		const [n, r] = this.getReturnExpression()
		return (1 === i || !r) && n.hasEffectsOnInteractionAtPath(e, t, s)
	}
}
class Wn extends Gn {
	bind() {
		if ((super.bind(), this.callee instanceof hn)) {
			this.scope.findVariable(this.callee.name).isNamespace && this.context.log(Ae, Ot(this.callee.name), this.start),
				'eval' === this.callee.name &&
					this.context.log(
						Ae,
						{
							code: 'EVAL',
							id: (e = this.context.module.id),
							message: `Use of eval in "${V(e)}" is strongly discouraged as it poses security risks and may cause issues with minification.`,
							url: De('troubleshooting/#avoiding-eval')
						},
						this.start
					)
		}
		var e
		this.interaction = { args: [this.callee instanceof jn && !this.callee.variable ? this.callee.object : null, ...this.arguments], type: 2, withNew: !1 }
	}
	hasEffects(e) {
		try {
			for (const t of this.arguments) if (t.hasEffects(e)) return !0
			return !this.annotationPure && (this.callee.hasEffects(e) || this.callee.hasEffectsOnInteractionAtPath(X, this.interaction, e))
		} finally {
			this.deoptimized || this.applyDeoptimizations()
		}
	}
	include(e, t) {
		this.deoptimized || this.applyDeoptimizations(),
			t
				? (super.include(e, t), t === Js && this.callee instanceof hn && this.callee.variable && this.callee.variable.markCalledFromTryStatement())
				: ((this.included = !0), this.callee.include(e, !1)),
			this.callee.includeCallArguments(e, this.arguments)
	}
	isSkippedAsOptional(e) {
		return this.callee.isSkippedAsOptional?.(e) || (this.optional && null == this.callee.getLiteralValueAtPath(X, se, e))
	}
	render(e, t, { renderedSurroundingElement: s } = me) {
		this.callee.render(e, t, { isCalleeOfRenderedParent: !0, renderedSurroundingElement: s }), Vn(e, t, this)
	}
	applyDeoptimizations() {
		;(this.deoptimized = !0), this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction, X, se), this.context.requestTreeshakingPass()
	}
	getReturnExpression(e = se) {
		return null === this.returnExpression
			? ((this.returnExpression = le), (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(X, this.interaction, e, this)))
			: this.returnExpression
	}
}
class qn extends Bi {
	addDeclaration(e, t, s, i) {
		const n = this.variables.get(e.name)
		return n ? (this.parent.addDeclaration(e, t, rs, i), n.addDeclaration(e, s), n) : this.parent.addDeclaration(e, t, s, i)
	}
}
class Hn extends Vi {
	constructor(e, t, s) {
		super(e), this.variables.set('this', (this.thisVariable = new Pi('this', null, t, s))), (this.instanceScope = new Vi(this)), this.instanceScope.variables.set('this', new Mn(s))
	}
	findLexicalBoundary() {
		return this
	}
}
class Kn extends ei {
	constructor() {
		super(...arguments), (this.accessedValue = null)
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		return (0 === e.type && 'get' === this.kind && 0 === t.length) || (1 === e.type && 'set' === this.kind && 0 === t.length)
			? this.value.deoptimizeArgumentsOnInteractionAtPath({ args: e.args, type: 2, withNew: !1 }, X, s)
			: void this.getAccessedValue()[0].deoptimizeArgumentsOnInteractionAtPath(e, t, s)
	}
	deoptimizeCache() {}
	deoptimizePath(e) {
		this.getAccessedValue()[0].deoptimizePath(e)
	}
	getLiteralValueAtPath(e, t, s) {
		return this.getAccessedValue()[0].getLiteralValueAtPath(e, t, s)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return this.getAccessedValue()[0].getReturnExpressionWhenCalledAtPath(e, t, s, i)
	}
	hasEffects(e) {
		return this.key.hasEffects(e)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return ('get' === this.kind && 0 === t.type && 0 === e.length) || ('set' === this.kind && 1 === t.type)
			? this.value.hasEffectsOnInteractionAtPath(X, { args: t.args, type: 2, withNew: !1 }, s)
			: this.getAccessedValue()[0].hasEffectsOnInteractionAtPath(e, t, s)
	}
	applyDeoptimizations() {}
	getAccessedValue() {
		return null === this.accessedValue
			? 'get' === this.kind
				? ((this.accessedValue = le), (this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(X, de, se, this)))
				: (this.accessedValue = [this.value, !1])
			: this.accessedValue
	}
}
class Yn extends Kn {
	applyDeoptimizations() {}
}
class Xn extends oe {
	constructor(e, t) {
		super(), (this.object = e), (this.key = t)
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		this.object.deoptimizeArgumentsOnInteractionAtPath(e, [this.key, ...t], s)
	}
	deoptimizePath(e) {
		this.object.deoptimizePath([this.key, ...e])
	}
	getLiteralValueAtPath(e, t, s) {
		return this.object.getLiteralValueAtPath([this.key, ...e], t, s)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...e], t, s, i)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return this.object.hasEffectsOnInteractionAtPath([this.key, ...e], t, s)
	}
}
class Qn extends ei {
	constructor() {
		super(...arguments), (this.objectEntity = null)
	}
	createScope(e) {
		this.scope = new Vi(e)
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(e, t, s)
	}
	deoptimizeCache() {
		this.getObjectEntity().deoptimizeAllProperties()
	}
	deoptimizePath(e) {
		this.getObjectEntity().deoptimizePath(e)
	}
	getLiteralValueAtPath(e, t, s) {
		return this.getObjectEntity().getLiteralValueAtPath(e, t, s)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e, t, s, i)
	}
	hasEffects(e) {
		this.deoptimized || this.applyDeoptimizations()
		const t = this.superClass?.hasEffects(e) || this.body.hasEffects(e)
		return this.id?.markDeclarationReached(), t || super.hasEffects(e)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return 2 === t.type && 0 === e.length
			? !t.withNew || (null === this.classConstructor ? this.superClass?.hasEffectsOnInteractionAtPath(e, t, s) : this.classConstructor.hasEffectsOnInteractionAtPath(e, t, s)) || !1
			: this.getObjectEntity().hasEffectsOnInteractionAtPath(e, t, s)
	}
	include(e, t) {
		this.deoptimized || this.applyDeoptimizations(), (this.included = !0), this.superClass?.include(e, t), this.body.include(e, t), this.id && (this.id.markDeclarationReached(), this.id.include())
	}
	initialise() {
		this.id?.declare('class', this)
		for (const e of this.body.body) if (e instanceof Yn && 'constructor' === e.kind) return void (this.classConstructor = e)
		this.classConstructor = null
	}
	applyDeoptimizations() {
		this.deoptimized = !0
		for (const e of this.body.body) e.static || (e instanceof Yn && 'constructor' === e.kind) || e.deoptimizePath(Q)
		this.context.requestTreeshakingPass()
	}
	getObjectEntity() {
		if (null !== this.objectEntity) return this.objectEntity
		const e = [],
			t = []
		for (const s of this.body.body) {
			const i = s.static ? e : t,
				n = s.kind
			if (i === t && !n) continue
			const r = 'set' === n || 'get' === n ? n : 'init'
			let o
			if (s.computed) {
				const e = s.key.getLiteralValueAtPath(X, se, this)
				if ('symbol' == typeof e) {
					i.push({ key: q, kind: r, property: s })
					continue
				}
				o = String(e)
			} else o = s.key instanceof hn ? s.key.name : String(s.key.value)
			i.push({ key: o, kind: r, property: s })
		}
		return e.unshift({ key: 'prototype', kind: 'init', property: new li(t, this.superClass ? new Xn(this.superClass, 'prototype') : ui) }), (this.objectEntity = new li(e, this.superClass || ui))
	}
}
class Zn extends Qn {
	initialise() {
		super.initialise(), null !== this.id && (this.id.variable.isId = !0)
	}
	parseNode(e) {
		null !== e.id && (this.id = new hn(e.id, this, this.scope.parent)), super.parseNode(e)
	}
	render(e, t) {
		const {
			exportNamesByVariable: s,
			format: i,
			snippets: { _: n, getPropertyAccess: r }
		} = t
		if (this.id) {
			const { variable: o, name: a } = this.id
			'system' === i && s.has(o) && e.appendLeft(this.end, `${n}${Cn([o], t)};`)
			const l = o.getName(r)
			if (l !== a)
				return this.superClass?.render(e, t), this.body.render(e, { ...t, useOriginalName: (e) => e === o }), e.prependRight(this.start, `let ${l}${n}=${n}`), void e.prependLeft(this.end, ';')
		}
		super.render(e, t)
	}
	applyDeoptimizations() {
		super.applyDeoptimizations()
		const { id: e, scope: t } = this
		if (e) {
			const { name: s, variable: i } = e
			for (const e of t.accessedOutsideVariables.values()) e !== i && e.forbidName(s)
		}
	}
}
class Jn extends Qn {
	render(e, t, { renderedSurroundingElement: s } = me) {
		super.render(e, t), s === Rs && (e.appendRight(this.start, '('), e.prependLeft(this.end, ')'))
	}
}
class er extends oe {
	constructor(e) {
		super(), (this.expressions = e), (this.included = !1)
	}
	deoptimizePath(e) {
		for (const t of this.expressions) t.deoptimizePath(e)
	}
	getReturnExpressionWhenCalledAtPath(e, t, s, i) {
		return [new er(this.expressions.map((n) => n.getReturnExpressionWhenCalledAtPath(e, t, s, i)[0])), !1]
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		for (const i of this.expressions) if (i.hasEffectsOnInteractionAtPath(e, t, s)) return !0
		return !1
	}
}
function tr(e, t) {
	const { brokenFlow: s, hasBreak: i, hasContinue: n, ignore: r } = e,
		{ breaks: o, continues: a } = r
	return (
		(r.breaks = !0),
		(r.continues = !0),
		(e.hasBreak = !1),
		(e.hasContinue = !1),
		!!t.hasEffects(e) || ((r.breaks = o), (r.continues = a), (e.hasBreak = i), (e.hasContinue = n), (e.brokenFlow = s), !1)
	)
}
function sr(e, t, s) {
	const { brokenFlow: i, hasBreak: n, hasContinue: r } = e
	;(e.hasBreak = !1), (e.hasContinue = !1), t.include(e, s, { asSingleStatement: !0 }), (e.hasBreak = n), (e.hasContinue = r), (e.brokenFlow = i)
}
class ir extends ei {
	hasEffects() {
		return !1
	}
	initialise() {
		this.context.addExport(this)
	}
	render(e, t, s) {
		e.remove(s.start, s.end)
	}
	applyDeoptimizations() {}
}
ir.prototype.needsBoundaries = !0
class nr extends Dn {
	initialise() {
		super.initialise(), null !== this.id && (this.id.variable.isId = !0)
	}
	parseNode(e) {
		null !== e.id && (this.id = new hn(e.id, this, this.scope.parent)), super.parseNode(e)
	}
}
class rr extends ei {
	include(e, t) {
		super.include(e, t), t && this.context.includeVariableInModule(this.variable)
	}
	initialise() {
		const e = this.declaration
		;(this.declarationName = (e.id && e.id.name) || this.declaration.name),
			(this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context)),
			this.context.addExport(this)
	}
	render(e, t, s) {
		const { start: i, end: n } = s,
			r = (function (e, t) {
				return yn(e, mn(e, 'default', t) + 7)
			})(e.original, this.start)
		if (this.declaration instanceof nr)
			this.renderNamedDeclaration(
				e,
				r,
				null === this.declaration.id
					? (function (e, t) {
							const s = mn(e, 'function', t) + 8
							e = e.slice(s, mn(e, '(', s))
							const i = mn(e, '*')
							return -1 === i ? s : s + i + 1
					  })(e.original, r)
					: null,
				t
			)
		else if (this.declaration instanceof Zn) this.renderNamedDeclaration(e, r, null === this.declaration.id ? mn(e.original, 'class', i) + 5 : null, t)
		else {
			if (this.variable.getOriginalVariable() !== this.variable) return void dn(this, e, i, n)
			if (!this.variable.included)
				return e.remove(this.start, r), this.declaration.render(e, t, { renderedSurroundingElement: Rs }), void (';' !== e.original[this.end - 1] && e.appendLeft(this.end, ';'))
			this.renderVariableDeclaration(e, r, t)
		}
		this.declaration.render(e, t)
	}
	applyDeoptimizations() {}
	renderNamedDeclaration(e, t, s, i) {
		const {
				exportNamesByVariable: n,
				format: r,
				snippets: { getPropertyAccess: o }
			} = i,
			a = this.variable.getName(o)
		e.remove(this.start, t), null !== s && e.appendLeft(s, ` ${a}`), 'system' === r && this.declaration instanceof Zn && n.has(this.variable) && e.appendLeft(this.end, ` ${Cn([this.variable], i)};`)
	}
	renderVariableDeclaration(e, t, { format: s, exportNamesByVariable: i, snippets: { cnst: n, getPropertyAccess: r } }) {
		const o = 59 === e.original.charCodeAt(this.end - 1),
			a = 'system' === s && i.get(this.variable)
		a
			? (e.overwrite(this.start, t, `${n} ${this.variable.getName(r)} = exports('${a[0]}', `), e.appendRight(o ? this.end - 1 : this.end, ')' + (o ? '' : ';')))
			: (e.overwrite(this.start, t, `${n} ${this.variable.getName(r)} = `), o || e.appendLeft(this.end, ';'))
	}
}
rr.prototype.needsBoundaries = !0
class or extends ei {
	bind() {
		this.declaration?.bind()
	}
	hasEffects(e) {
		return !!this.declaration?.hasEffects(e)
	}
	initialise() {
		this.context.addExport(this)
	}
	render(e, t, s) {
		const { start: i, end: n } = s
		null === this.declaration ? e.remove(i, n) : (e.remove(this.start, this.declaration.start), this.declaration.render(e, t, { end: n, start: i }))
	}
	applyDeoptimizations() {}
}
or.prototype.needsBoundaries = !0
class ar extends Dn {
	render(e, t, { renderedSurroundingElement: s } = me) {
		super.render(e, t), s === Rs && (e.appendRight(this.start, '('), e.prependLeft(this.end, ')'))
	}
}
class lr extends Sn {
	constructor() {
		super(...arguments), (this.hoistedDeclarations = [])
	}
	addDeclaration(e, t, s, i) {
		return this.hoistedDeclarations.push(e), super.addDeclaration(e, t, s, i)
	}
}
const cr = Symbol('unset')
class hr extends ei {
	constructor() {
		super(...arguments), (this.testValue = cr)
	}
	deoptimizeCache() {
		this.testValue = ne
	}
	hasEffects(e) {
		if (this.test.hasEffects(e)) return !0
		const t = this.getTestValue()
		if ('symbol' == typeof t) {
			const { brokenFlow: t } = e
			if (this.consequent.hasEffects(e)) return !0
			const s = e.brokenFlow
			return (e.brokenFlow = t), null === this.alternate ? !1 : !!this.alternate.hasEffects(e) || ((e.brokenFlow = e.brokenFlow && s), !1)
		}
		return t ? this.consequent.hasEffects(e) : !!this.alternate?.hasEffects(e)
	}
	include(e, t) {
		if (((this.included = !0), t)) this.includeRecursively(t, e)
		else {
			const t = this.getTestValue()
			'symbol' == typeof t ? this.includeUnknownTest(e) : this.includeKnownTest(e, t)
		}
	}
	parseNode(e) {
		;(this.consequentScope = new lr(this.scope)),
			(this.consequent = new (this.context.getNodeConstructor(e.consequent.type))(e.consequent, this, this.consequentScope)),
			e.alternate && ((this.alternateScope = new lr(this.scope)), (this.alternate = new (this.context.getNodeConstructor(e.alternate.type))(e.alternate, this, this.alternateScope))),
			super.parseNode(e)
	}
	render(e, t) {
		const {
				snippets: { getPropertyAccess: s }
			} = t,
			i = this.getTestValue(),
			n = [],
			r = this.test.included,
			o = !this.context.options.treeshake
		r ? this.test.render(e, t) : e.remove(this.start, this.consequent.start),
			this.consequent.included && (o || 'symbol' == typeof i || i)
				? this.consequent.render(e, t)
				: (e.overwrite(this.consequent.start, this.consequent.end, r ? ';' : ''), n.push(...this.consequentScope.hoistedDeclarations)),
			this.alternate &&
				(!this.alternate.included || (!o && 'symbol' != typeof i && i)
					? (r && this.shouldKeepAlternateBranch() ? e.overwrite(this.alternate.start, this.end, ';') : e.remove(this.consequent.end, this.end), n.push(...this.alternateScope.hoistedDeclarations))
					: (r ? 101 === e.original.charCodeAt(this.alternate.start - 1) && e.prependLeft(this.alternate.start, ' ') : e.remove(this.consequent.end, this.alternate.start),
					  this.alternate.render(e, t))),
			this.renderHoistedDeclarations(n, e, s)
	}
	applyDeoptimizations() {}
	getTestValue() {
		return this.testValue === cr ? (this.testValue = this.test.getLiteralValueAtPath(X, se, this)) : this.testValue
	}
	includeKnownTest(e, t) {
		this.test.shouldBeIncluded(e) && this.test.include(e, !1),
			t && this.consequent.shouldBeIncluded(e) && this.consequent.include(e, !1, { asSingleStatement: !0 }),
			!t && this.alternate?.shouldBeIncluded(e) && this.alternate.include(e, !1, { asSingleStatement: !0 })
	}
	includeRecursively(e, t) {
		this.test.include(t, e), this.consequent.include(t, e), this.alternate?.include(t, e)
	}
	includeUnknownTest(e) {
		this.test.include(e, !1)
		const { brokenFlow: t } = e
		let s = !1
		this.consequent.shouldBeIncluded(e) && (this.consequent.include(e, !1, { asSingleStatement: !0 }), (s = e.brokenFlow), (e.brokenFlow = t)),
			this.alternate?.shouldBeIncluded(e) && (this.alternate.include(e, !1, { asSingleStatement: !0 }), (e.brokenFlow = e.brokenFlow && s))
	}
	renderHoistedDeclarations(e, t, s) {
		const i = [
			...new Set(
				e.map((e) => {
					const t = e.variable
					return t.included ? t.getName(s) : ''
				})
			)
		]
			.filter(Boolean)
			.join(', ')
		if (i) {
			const e = this.parent.type,
				s = e !== Ts && e !== ws
			t.prependRight(this.start, `${s ? '{ ' : ''}var ${i}; `), s && t.appendLeft(this.end, ' }')
		}
	}
	shouldKeepAlternateBranch() {
		let e = this.parent
		do {
			if (e instanceof hr && e.alternate) return !0
			if (e instanceof kn) return !1
			e = e.parent
		} while (e)
		return !1
	}
}
class ur extends ei {
	bind() {}
	hasEffects() {
		return !1
	}
	initialise() {
		this.context.addImport(this)
	}
	render(e, t, s) {
		e.remove(s.start, s.end)
	}
	applyDeoptimizations() {}
}
ur.prototype.needsBoundaries = !0
class dr extends ei {
	applyDeoptimizations() {}
}
const pr = '_interopDefault',
	fr = '_interopDefaultCompat',
	mr = '_interopNamespace',
	gr = '_interopNamespaceCompat',
	yr = '_interopNamespaceDefault',
	xr = '_interopNamespaceDefaultOnly',
	Er = '_mergeNamespaces',
	br = '_documentCurrentScript',
	vr = { auto: pr, compat: fr, default: null, defaultOnly: null, esModule: null },
	Sr = (e, t) => 'esModule' === e || (t && ('auto' === e || 'compat' === e)),
	Ar = { auto: mr, compat: gr, default: yr, defaultOnly: xr, esModule: null },
	kr = (e, t) => 'esModule' !== e && Sr(e, t),
	Ir = (e, t, s, i, n, r, o) => {
		const a = new Set(e)
		for (const e of Br) t.has(e) && a.add(e)
		return Br.map((e) => (a.has(e) ? wr[e](s, i, n, r, o, a) : '')).join('')
	},
	wr = {
		[br]: (e, { _: t, n: s }) => `var${t}${br}${t}=${t}typeof${t}document${t}!==${t}'undefined'${t}?${t}document.currentScript${t}:${t}null;${s}`,
		[fr](e, t, s) {
			const { _: i, getDirectReturnFunction: n, n: r } = t,
				[o, a] = n(['e'], { functionReturn: !0, lineBreakIndent: null, name: fr })
			return `${o}${$r(t)}${i}?${i}${s ? Pr(t) : Cr(t)}${a}${r}${r}`
		},
		[pr](e, t, s) {
			const { _: i, getDirectReturnFunction: n, n: r } = t,
				[o, a] = n(['e'], { functionReturn: !0, lineBreakIndent: null, name: pr })
			return `${o}e${i}&&${i}e.__esModule${i}?${i}${s ? Pr(t) : Cr(t)}${a}${r}${r}`
		},
		[gr](e, t, s, i, n, r) {
			const { _: o, getDirectReturnFunction: a, n: l } = t
			if (r.has(yr)) {
				const [e, s] = a(['e'], { functionReturn: !0, lineBreakIndent: null, name: gr })
				return `${e}${$r(t)}${o}?${o}e${o}:${o}${yr}(e)${s}${l}${l}`
			}
			return `function ${gr}(e)${o}{${l}${e}if${o}(${$r(t)})${o}return e;${l}` + Nr(e, e, t, s, i, n) + `}${l}${l}`
		},
		[xr](e, t, s, i, n) {
			const { getDirectReturnFunction: r, getObject: o, n: a } = t,
				[l, c] = r(['e'], { functionReturn: !0, lineBreakIndent: null, name: xr })
			return `${l}${Tr(
				i,
				Vr(
					n,
					o(
						[
							['__proto__', 'null'],
							['default', 'e']
						],
						{ lineBreakIndent: null }
					),
					t
				)
			)}${c}${a}${a}`
		},
		[yr](e, t, s, i, n) {
			const { _: r, n: o } = t
			return `function ${yr}(e)${r}{${o}` + Nr(e, e, t, s, i, n) + `}${o}${o}`
		},
		[mr](e, t, s, i, n, r) {
			const { _: o, getDirectReturnFunction: a, n: l } = t
			if (r.has(yr)) {
				const [e, t] = a(['e'], { functionReturn: !0, lineBreakIndent: null, name: mr })
				return `${e}e${o}&&${o}e.__esModule${o}?${o}e${o}:${o}${yr}(e)${t}${l}${l}`
			}
			return `function ${mr}(e)${o}{${l}${e}if${o}(e${o}&&${o}e.__esModule)${o}return e;${l}` + Nr(e, e, t, s, i, n) + `}${l}${l}`
		},
		[Er](e, t, s, i, n) {
			const { _: r, cnst: o, n: a } = t,
				l = 'var' === o && s
			return `function ${Er}(n, m)${r}{${a}${e}${Rr(
				`{${a}${e}${e}${e}if${r}(k${r}!==${r}'default'${r}&&${r}!(k in n))${r}{${a}` + (s ? (l ? Or : Dr) : Lr)(e, e + e + e + e, t) + `${e}${e}${e}}${a}` + `${e}${e}}`,
				l,
				e,
				t
			)}${a}${e}return ${Tr(i, Vr(n, 'n', t))};${a}}${a}${a}`
		}
	},
	Pr = ({ _: e, getObject: t }) => `e${e}:${e}${t([['default', 'e']], { lineBreakIndent: null })}`,
	Cr = ({ _: e, getPropertyAccess: t }) => `e${t('default')}${e}:${e}e`,
	$r = ({ _: e }) => `e${e}&&${e}typeof e${e}===${e}'object'${e}&&${e}'default'${e}in e`,
	Nr = (e, t, s, i, n, r) => {
		const { _: o, cnst: a, getObject: l, getPropertyAccess: c, n: h, s: u } = s,
			d = `{${h}` + (i ? Mr : Lr)(e, t + e + e, s) + `${t}${e}}`
		return `${t}${a} n${o}=${o}Object.create(null${r ? `,${o}{${o}[Symbol.toStringTag]:${o}${zr(l)}${o}}` : ''});${h}${t}if${o}(e)${o}{${h}${t}${e}${_r(d, !i, s)}${h}${t}}${h}${t}n${c(
			'default'
		)}${o}=${o}e;${h}${t}return ${Tr(n, 'n')}${u}${h}`
	},
	_r = (e, t, { _: s, cnst: i, getFunctionIntro: n, s: r }) => ('var' !== i || t ? `for${s}(${i} k in e)${s}${e}` : `Object.keys(e).forEach(${n(['k'], { isAsync: !1, name: null })}${e})${r}`),
	Rr = (e, t, s, { _: i, cnst: n, getDirectReturnFunction: r, getFunctionIntro: o, n: a }) => {
		if (t) {
			const [t, n] = r(['e'], { functionReturn: !1, lineBreakIndent: { base: s, t: s }, name: null })
			return `m.forEach(${t}e${i}&&${i}typeof e${i}!==${i}'string'${i}&&${i}!Array.isArray(e)${i}&&${i}Object.keys(e).forEach(${o(['k'], { isAsync: !1, name: null })}${e})${n});`
		}
		return `for${i}(var i${i}=${i}0;${i}i${i}<${i}m.length;${i}i++)${i}{${a}${s}${s}${n} e${i}=${i}m[i];${a}${s}${s}if${i}(typeof e${i}!==${i}'string'${i}&&${i}!Array.isArray(e))${i}{${i}for${i}(${n} k in e)${i}${e}${i}}${a}${s}}`
	},
	Mr = (e, t, s) => {
		const { _: i, n: n } = s
		return `${t}if${i}(k${i}!==${i}'default')${i}{${n}` + Or(e, t + e, s) + `${t}}${n}`
	},
	Or = (e, t, { _: s, cnst: i, getDirectReturnFunction: n, n: r }) => {
		const [o, a] = n([], { functionReturn: !0, lineBreakIndent: null, name: null })
		return `${t}${i} d${s}=${s}Object.getOwnPropertyDescriptor(e,${s}k);${r}${t}Object.defineProperty(n,${s}k,${s}d.get${s}?${s}d${s}:${s}{${r}${t}${e}enumerable:${s}true,${r}${t}${e}get:${s}${o}e[k]${a}${r}${t}});${r}`
	},
	Dr = (e, t, { _: s, cnst: i, getDirectReturnFunction: n, n: r }) => {
		const [o, a] = n([], { functionReturn: !0, lineBreakIndent: null, name: null })
		return `${t}${i} d${s}=${s}Object.getOwnPropertyDescriptor(e,${s}k);${r}${t}if${s}(d)${s}{${r}${t}${e}Object.defineProperty(n,${s}k,${s}d.get${s}?${s}d${s}:${s}{${r}${t}${e}${e}enumerable:${s}true,${r}${t}${e}${e}get:${s}${o}e[k]${a}${r}${t}${e}});${r}${t}}${r}`
	},
	Lr = (e, t, { _: s, n: i }) => `${t}n[k]${s}=${s}e[k];${i}`,
	Tr = (e, t) => (e ? `Object.freeze(${t})` : t),
	Vr = (e, t, { _: s, getObject: i }) => (e ? `Object.defineProperty(${t},${s}Symbol.toStringTag,${s}${zr(i)})` : t),
	Br = Object.keys(wr)
function zr(e) {
	return e([['value', "'Module'"]], { lineBreakIndent: null })
}
function Fr(e, t) {
	return null !== e.renderBaseName && t.has(e) && e.isReassigned
}
class jr extends ei {
	declareDeclarator(e) {
		this.id.declare(e, this.init || rs)
	}
	deoptimizePath(e) {
		this.id.deoptimizePath(e)
	}
	hasEffects(e) {
		this.deoptimized || this.applyDeoptimizations()
		const t = this.init?.hasEffects(e)
		return this.id.markDeclarationReached(), t || this.id.hasEffects(e)
	}
	include(e, t) {
		const { deoptimized: s, id: i, init: n } = this
		s || this.applyDeoptimizations(), (this.included = !0), n?.include(e, t), i.markDeclarationReached(), (t || i.shouldBeIncluded(e)) && i.include(e, t)
	}
	render(e, t) {
		const {
				exportNamesByVariable: s,
				snippets: { _: i, getPropertyAccess: n }
			} = t,
			{ end: r, id: o, init: a, start: l } = this,
			c = o.included
		if (c) o.render(e, t)
		else {
			const t = mn(e.original, '=', o.end)
			e.remove(l, yn(e.original, t + 1))
		}
		if (a) {
			if (o instanceof hn && a instanceof Jn && !a.id) {
				o.variable.getName(n) !== o.name && e.appendLeft(a.start + 5, ` ${o.name}`)
			}
			a.render(e, t, c ? me : { renderedSurroundingElement: Rs })
		} else o instanceof hn && Fr(o.variable, s) && e.appendLeft(r, `${i}=${i}void 0`)
	}
	applyDeoptimizations() {
		this.deoptimized = !0
		const { id: e, init: t } = this
		if (t && e instanceof hn && t instanceof Jn && !t.id) {
			const { name: s, variable: i } = e
			for (const e of t.scope.accessedOutsideVariables.values()) e !== i && e.forbidName(s)
		}
	}
}
function Ur(e, t, s) {
	return 'external' === t ? Ar[s(e instanceof Jt ? e.id : null)] : 'default' === t ? xr : null
}
const Gr = { amd: ['require'], cjs: ['require'], system: ['module'] }
function Wr(e) {
	const t = []
	for (const s of e.properties) {
		if ('RestElement' === s.type || s.computed || 'Identifier' !== s.key.type) return
		t.push(s.key.name)
	}
	return t
}
class qr extends ei {
	applyDeoptimizations() {}
}
const Hr = 'ROLLUP_FILE_URL_',
	Kr = 'import'
const Yr = ['cjs', 'iife', 'umd'],
	Xr = { amd: ['document', 'module', 'URL'], cjs: ['document', 'require', 'URL', br], es: [], iife: ['document', 'URL', br], system: ['module'], umd: ['document', 'require', 'URL', br] },
	Qr = { amd: ['document', 'require', 'URL'], cjs: ['document', 'require', 'URL'], es: [], iife: ['document', 'URL'], system: ['module', 'URL'], umd: ['document', 'require', 'URL'] },
	Zr = (e, t = 'URL') => `new ${t}(${e}).href`,
	Jr = (e, t = !1) => Zr(`'${L(e)}', ${t ? "typeof document === 'undefined' ? location.href : " : ''}document.currentScript && document.currentScript.src || document.baseURI`),
	eo =
		(e) =>
		(t, { chunkId: s }) => {
			const i = e(s)
			return null === t ? `({ url: ${i} })` : 'url' === t ? i : 'undefined'
		},
	to = (e) => `require('u' + 'rl').pathToFileURL(${e}).href`,
	so = (e) => to(`__dirname + '/${e}'`),
	io = (e, t = !1) => `${t ? "typeof document === 'undefined' ? location.href : " : ''}(${br} && ${br}.src || new URL('${L(e)}', document.baseURI).href)`,
	no = {
		amd: (e) => ('.' !== e[0] && (e = './' + e), Zr(`require.toUrl('${e}'), document.baseURI`)),
		cjs: (e) => `(typeof document === 'undefined' ? ${so(e)} : ${Jr(e)})`,
		es: (e) => Zr(`'${e}', import.meta.url`),
		iife: (e) => Jr(e),
		system: (e) => Zr(`'${e}', module.meta.url`),
		umd: (e) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${so(e)} : ${Jr(e, !0)})`
	},
	ro = {
		amd: eo(() => Zr('module.uri, document.baseURI')),
		cjs: eo((e) => `(typeof document === 'undefined' ? ${to('__filename')} : ${io(e)})`),
		iife: eo((e) => io(e)),
		system: (e, { snippets: { getPropertyAccess: t } }) => (null === e ? 'module.meta' : `module.meta${t(e)}`),
		umd: eo((e) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${to('__filename')} : ${io(e, !0)})`)
	}
class oo extends ei {
	constructor() {
		super(...arguments), (this.hasCachedEffect = null), (this.hasLoggedEffect = !1)
	}
	hasCachedEffects() {
		return !!this.included && (null === this.hasCachedEffect ? (this.hasCachedEffect = this.hasEffects(is())) : this.hasCachedEffect)
	}
	hasEffects(e) {
		for (const t of this.body)
			if (t.hasEffects(e)) {
				if (this.context.options.experimentalLogSideEffects && !this.hasLoggedEffect) {
					this.hasLoggedEffect = !0
					const { code: e, log: s, module: i } = this.context
					s(ke, Tt(e, i.id, Ce(e, t.start, { offsetLine: 1 })), t.start)
				}
				return (this.hasCachedEffect = !0)
			}
		return !1
	}
	include(e, t) {
		this.included = !0
		for (const s of this.body) (t || s.shouldBeIncluded(e)) && s.include(e, t)
	}
	render(e, t) {
		let s = this.start
		if ((e.original.startsWith('#!') && ((s = Math.min(e.original.indexOf('\n') + 1, this.end)), e.remove(0, s)), this.body.length > 0)) {
			for (; '/' === e.original[s] && /[*/]/.test(e.original[s + 1]); ) {
				const t = xn(e.original.slice(s, this.body[0].start))
				if (-1 === t[0]) break
				s += t[1]
			}
			En(this.body, e, s, this.end, t)
		} else super.render(e, t)
	}
	applyDeoptimizations() {}
}
class ao extends ei {
	hasEffects(e) {
		if (this.test?.hasEffects(e)) return !0
		for (const t of this.consequent) {
			if (e.brokenFlow) break
			if (t.hasEffects(e)) return !0
		}
		return !1
	}
	include(e, t) {
		;(this.included = !0), this.test?.include(e, t)
		for (const s of this.consequent) (t || s.shouldBeIncluded(e)) && s.include(e, t)
	}
	render(e, t, s) {
		if (this.consequent.length > 0) {
			this.test && this.test.render(e, t)
			const i = this.test ? this.test.end : mn(e.original, 'default', this.start) + 7,
				n = mn(e.original, ':', i) + 1
			En(this.consequent, e, n, s.end, t)
		} else super.render(e, t)
	}
}
ao.prototype.needsBoundaries = !0
class lo extends ei {
	deoptimizeArgumentsOnInteractionAtPath() {}
	getLiteralValueAtPath(e) {
		return e.length > 0 || 1 !== this.quasis.length ? ne : this.quasis[0].value.cooked
	}
	getReturnExpressionWhenCalledAtPath(e) {
		return 1 !== e.length ? le : bs(xs, e[0])
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		return 0 === t.type ? e.length > 1 : 2 !== t.type || 1 !== e.length || Es(xs, e[0], t, s)
	}
	render(e, t) {
		e.indentExclusionRanges.push([this.start, this.end]), super.render(e, t)
	}
}
class co extends pe {
	constructor() {
		super('undefined')
	}
	getLiteralValueAtPath() {}
}
class ho extends Pi {
	constructor(e, t, s) {
		super(e, t, t.declaration, s), (this.hasId = !1), (this.originalId = null), (this.originalVariable = null)
		const i = t.declaration
		;(i instanceof nr || i instanceof Zn) && i.id ? ((this.hasId = !0), (this.originalId = i.id)) : i instanceof hn && (this.originalId = i)
	}
	addReference(e) {
		this.hasId || (this.name = e.name)
	}
	forbidName(e) {
		const t = this.getOriginalVariable()
		t === this ? super.forbidName(e) : t.forbidName(e)
	}
	getAssignedVariableName() {
		return (this.originalId && this.originalId.name) || null
	}
	getBaseVariableName() {
		const e = this.getOriginalVariable()
		return e === this ? super.getBaseVariableName() : e.getBaseVariableName()
	}
	getDirectOriginalVariable() {
		return !this.originalId ||
			(!this.hasId && (this.originalId.isPossibleTDZ() || this.originalId.variable.isReassigned || this.originalId.variable instanceof co || 'syntheticNamespace' in this.originalId.variable))
			? null
			: this.originalId.variable
	}
	getName(e) {
		const t = this.getOriginalVariable()
		return t === this ? super.getName(e) : t.getName(e)
	}
	getOriginalVariable() {
		if (this.originalVariable) return this.originalVariable
		let e,
			t = this
		const s = new Set()
		do {
			s.add(t), (e = t), (t = e.getDirectOriginalVariable())
		} while (t instanceof ho && !s.has(t))
		return (this.originalVariable = t || e)
	}
}
class uo extends Vi {
	constructor(e, t) {
		super(e), (this.context = t), this.variables.set('this', new Pi('this', null, rs, t))
	}
	addExportDefaultDeclaration(e, t, s) {
		const i = new ho(e, t, s)
		return this.variables.set('default', i), i
	}
	addNamespaceMemberAccess() {}
	deconflict(e, t, s) {
		for (const i of this.children) i.deconflict(e, t, s)
	}
	findLexicalBoundary() {
		return this
	}
	findVariable(e) {
		const t = this.variables.get(e) || this.accessedOutsideVariables.get(e)
		if (t) return t
		const s = this.context.traceVariable(e) || this.parent.findVariable(e)
		return s instanceof ln && this.accessedOutsideVariables.set(e, s), s
	}
}
const po = { '!': (e) => !e, '+': (e) => +e, '-': (e) => -e, delete: () => ne, typeof: (e) => typeof e, void: () => {}, '~': (e) => ~e }
class fo extends ei {
	deoptimizePath() {
		for (const e of this.declarations) e.deoptimizePath(X)
	}
	hasEffectsOnInteractionAtPath() {
		return !1
	}
	include(e, t, { asSingleStatement: s } = me) {
		this.included = !0
		for (const i of this.declarations) {
			;(t || i.shouldBeIncluded(e)) && i.include(e, t)
			const { id: n, init: r } = i
			s && n.include(e, t), r && n.included && !r.included && (n instanceof _n || n instanceof wi) && r.include(e, t)
		}
	}
	initialise() {
		for (const e of this.declarations) e.declareDeclarator(this.kind)
	}
	render(e, t, s = me) {
		if (
			(function (e, t) {
				for (const s of e) {
					if (!s.id.included) return !1
					if (s.id.type === Os) {
						if (t.has(s.id.variable)) return !1
					} else {
						const e = []
						if ((s.id.addExportedVariables(e, t), e.length > 0)) return !1
					}
				}
				return !0
			})(this.declarations, t.exportNamesByVariable)
		) {
			for (const s of this.declarations) s.render(e, t)
			s.isNoStatement || 59 === e.original.charCodeAt(this.end - 1) || e.appendLeft(this.end, ';')
		} else this.renderReplacedDeclarations(e, t)
	}
	applyDeoptimizations() {}
	renderDeclarationEnd(e, t, s, i, n, r, o) {
		59 === e.original.charCodeAt(this.end - 1) && e.remove(this.end - 1, this.end),
			(t += ';'),
			null === s
				? e.appendLeft(n, t)
				: (10 !== e.original.charCodeAt(i - 1) || (10 !== e.original.charCodeAt(this.end) && 13 !== e.original.charCodeAt(this.end)) || (i--, 13 === e.original.charCodeAt(i) && i--),
				  i === s + 1 ? e.overwrite(s, n, t) : (e.overwrite(s, s + 1, t), e.remove(i, n))),
			r.length > 0 && e.appendLeft(n, ` ${Cn(r, o)};`)
	}
	renderReplacedDeclarations(e, t) {
		const s = bn(this.declarations, e, this.start + this.kind.length, this.end - (59 === e.original.charCodeAt(this.end - 1) ? 1 : 0))
		let i, n
		n = yn(e.original, this.start + this.kind.length)
		let r = n - 1
		e.remove(this.start, r)
		let o,
			a,
			l = !1,
			c = !1,
			h = ''
		const u = [],
			d = (function (e, t, s) {
				let i = null
				if ('system' === t.format) {
					for (const { node: n } of e)
						n.id instanceof hn && n.init && 0 === s.length && 1 === t.exportNamesByVariable.get(n.id.variable)?.length
							? ((i = n.id.variable), s.push(i))
							: n.id.addExportedVariables(s, t.exportNamesByVariable)
					s.length > 1 ? (i = null) : i && (s.length = 0)
				}
				return i
			})(s, t, u)
		for (const { node: u, start: p, separator: f, contentEnd: m, end: g } of s)
			if (u.included) {
				if ((u.render(e, t), (o = ''), (a = ''), !u.id.included || (u.id instanceof hn && Fr(u.id.variable, t.exportNamesByVariable)))) c && (h += ';'), (l = !1)
				else {
					if (d && d === u.id.variable) {
						const s = mn(e.original, '=', u.id.end)
						$n(d, yn(e.original, s + 1), null === f ? m : f, e, t)
					}
					l ? (h += ',') : (c && (h += ';'), (o += `${this.kind} `), (l = !0))
				}
				n === r + 1 ? e.overwrite(r, n, h + o) : (e.overwrite(r, r + 1, h), e.appendLeft(n, o)), (i = m), (n = g), (c = !0), (r = f), (h = '')
			} else e.remove(p, g)
		this.renderDeclarationEnd(e, h, r, i, n, u, t)
	}
}
const mo = {
		ArrayExpression: Ii,
		ArrayPattern: wi,
		ArrowFunctionExpression: Pn,
		AssignmentExpression: class extends ei {
			hasEffects(e) {
				const { deoptimized: t, left: s, operator: i, right: n } = this
				return t || this.applyDeoptimizations(), n.hasEffects(e) || s.hasEffectsAsAssignmentTarget(e, '=' !== i)
			}
			hasEffectsOnInteractionAtPath(e, t, s) {
				return this.right.hasEffectsOnInteractionAtPath(e, t, s)
			}
			include(e, t) {
				const { deoptimized: s, left: i, right: n, operator: r } = this
				s || this.applyDeoptimizations(),
					(this.included = !0),
					(t || '=' !== r || i.included || i.hasEffectsAsAssignmentTarget(is(), !1)) && i.includeAsAssignmentTarget(e, t, '=' !== r),
					n.include(e, t)
			}
			initialise() {
				this.left.setAssignedValue(this.right)
			}
			render(e, t, { preventASI: s, renderedParentType: i, renderedSurroundingElement: n } = me) {
				const { left: r, right: o, start: a, end: l, parent: c } = this
				if (r.included) r.render(e, t), o.render(e, t)
				else {
					const l = yn(e.original, mn(e.original, '=', r.end) + 1)
					e.remove(a, l), s && vn(e, l, o.start), o.render(e, t, { renderedParentType: i || c.type, renderedSurroundingElement: n || c.type })
				}
				if ('system' === t.format)
					if (r instanceof hn) {
						const s = r.variable,
							i = t.exportNamesByVariable.get(s)
						if (i) return void (1 === i.length ? $n(s, a, l, e, t) : Nn(s, a, l, c.type !== Rs, e, t))
					} else {
						const s = []
						if ((r.addExportedVariables(s, t.exportNamesByVariable), s.length > 0))
							return void (function (e, t, s, i, n, r) {
								const { _: o, getDirectReturnIifeLeft: a } = r.snippets
								n.prependRight(t, a(['v'], `${Cn(e, r)},${o}v`, { needsArrowReturnParens: !0, needsWrappedFunction: i })), n.appendLeft(s, ')')
							})(s, a, l, n === Rs, e, t)
					}
				r.included && r instanceof _n && (n === Rs || n === ks) && (e.appendRight(a, '('), e.prependLeft(l, ')'))
			}
			applyDeoptimizations() {
				;(this.deoptimized = !0), this.left.deoptimizePath(X), this.right.deoptimizePath(Q), this.context.requestTreeshakingPass()
			}
		},
		AssignmentPattern: class extends ei {
			addExportedVariables(e, t) {
				this.left.addExportedVariables(e, t)
			}
			declare(e, t) {
				return this.left.declare(e, t)
			}
			deoptimizePath(e) {
				0 === e.length && this.left.deoptimizePath(e)
			}
			hasEffectsOnInteractionAtPath(e, t, s) {
				return e.length > 0 || this.left.hasEffectsOnInteractionAtPath(X, t, s)
			}
			markDeclarationReached() {
				this.left.markDeclarationReached()
			}
			render(e, t, { isShorthandProperty: s } = me) {
				this.left.render(e, t, { isShorthandProperty: s }), this.right.render(e, t)
			}
			applyDeoptimizations() {
				;(this.deoptimized = !0), this.left.deoptimizePath(X), this.right.deoptimizePath(Q), this.context.requestTreeshakingPass()
			}
		},
		AwaitExpression: Ln,
		BinaryExpression: class extends ei {
			deoptimizeCache() {}
			getLiteralValueAtPath(e, t, s) {
				if (e.length > 0) return ne
				const i = this.left.getLiteralValueAtPath(X, t, s)
				if ('symbol' == typeof i) return ne
				const n = this.right.getLiteralValueAtPath(X, t, s)
				if ('symbol' == typeof n) return ne
				const r = Tn[this.operator]
				return r ? r(i, n) : ne
			}
			hasEffects(e) {
				return ('+' === this.operator && this.parent instanceof An && '' === this.left.getLiteralValueAtPath(X, se, this)) || super.hasEffects(e)
			}
			hasEffectsOnInteractionAtPath(e, { type: t }) {
				return 0 !== t || e.length > 1
			}
			render(e, t, { renderedSurroundingElement: s } = me) {
				this.left.render(e, t, { renderedSurroundingElement: s }), this.right.render(e, t)
			}
		},
		BlockStatement: kn,
		BreakStatement: class extends ei {
			hasEffects(e) {
				if (this.label) {
					if (!e.ignore.labels.has(this.label.name)) return !0
					e.includedLabels.add(this.label.name)
				} else {
					if (!e.ignore.breaks) return !0
					e.hasBreak = !0
				}
				return (e.brokenFlow = !0), !1
			}
			include(e) {
				;(this.included = !0), this.label ? (this.label.include(), e.includedLabels.add(this.label.name)) : (e.hasBreak = !0), (e.brokenFlow = !0)
			}
		},
		CallExpression: Wn,
		CatchClause: class extends ei {
			createScope(e) {
				this.scope = new qn(e, this.context)
			}
			parseNode(e) {
				const { param: t } = e
				t && ((this.param = new (this.context.getNodeConstructor(t.type))(t, this, this.scope)), this.param.declare('parameter', ae)), super.parseNode(e)
			}
		},
		ChainExpression: class extends ei {
			deoptimizeCache() {}
			getLiteralValueAtPath(e, t, s) {
				if (!this.expression.isSkippedAsOptional(s)) return this.expression.getLiteralValueAtPath(e, t, s)
			}
			hasEffects(e) {
				return !this.expression.isSkippedAsOptional(this) && this.expression.hasEffects(e)
			}
		},
		ClassBody: class extends ei {
			createScope(e) {
				this.scope = new Hn(e, this.parent, this.context)
			}
			include(e, t) {
				;(this.included = !0), this.context.includeVariableInModule(this.scope.thisVariable)
				for (const s of this.body) s.include(e, t)
			}
			parseNode(e) {
				const t = (this.body = [])
				for (const s of e.body) t.push(new (this.context.getNodeConstructor(s.type))(s, this, s.static ? this.scope : this.scope.instanceScope))
				super.parseNode(e)
			}
			applyDeoptimizations() {}
		},
		ClassDeclaration: Zn,
		ClassExpression: Jn,
		ConditionalExpression: class extends ei {
			constructor() {
				super(...arguments), (this.expressionsToBeDeoptimized = []), (this.isBranchResolutionAnalysed = !1), (this.usedBranch = null)
			}
			deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
				this.consequent.deoptimizeArgumentsOnInteractionAtPath(e, t, s), this.alternate.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
			}
			deoptimizeCache() {
				if (null !== this.usedBranch) {
					const e = this.usedBranch === this.consequent ? this.alternate : this.consequent
					;(this.usedBranch = null), e.deoptimizePath(Q)
					const { expressionsToBeDeoptimized: t } = this
					this.expressionsToBeDeoptimized = ye
					for (const e of t) e.deoptimizeCache()
				}
			}
			deoptimizePath(e) {
				const t = this.getUsedBranch()
				t ? t.deoptimizePath(e) : (this.consequent.deoptimizePath(e), this.alternate.deoptimizePath(e))
			}
			getLiteralValueAtPath(e, t, s) {
				const i = this.getUsedBranch()
				return i ? (this.expressionsToBeDeoptimized.push(s), i.getLiteralValueAtPath(e, t, s)) : ne
			}
			getReturnExpressionWhenCalledAtPath(e, t, s, i) {
				const n = this.getUsedBranch()
				return n
					? (this.expressionsToBeDeoptimized.push(i), n.getReturnExpressionWhenCalledAtPath(e, t, s, i))
					: [new er([this.consequent.getReturnExpressionWhenCalledAtPath(e, t, s, i)[0], this.alternate.getReturnExpressionWhenCalledAtPath(e, t, s, i)[0]]), !1]
			}
			hasEffects(e) {
				if (this.test.hasEffects(e)) return !0
				const t = this.getUsedBranch()
				return t ? t.hasEffects(e) : this.consequent.hasEffects(e) || this.alternate.hasEffects(e)
			}
			hasEffectsOnInteractionAtPath(e, t, s) {
				const i = this.getUsedBranch()
				return i ? i.hasEffectsOnInteractionAtPath(e, t, s) : this.consequent.hasEffectsOnInteractionAtPath(e, t, s) || this.alternate.hasEffectsOnInteractionAtPath(e, t, s)
			}
			include(e, t) {
				this.included = !0
				const s = this.getUsedBranch()
				t || this.test.shouldBeIncluded(e) || null === s ? (this.test.include(e, t), this.consequent.include(e, t), this.alternate.include(e, t)) : s.include(e, t)
			}
			includeCallArguments(e, t) {
				const s = this.getUsedBranch()
				s ? s.includeCallArguments(e, t) : (this.consequent.includeCallArguments(e, t), this.alternate.includeCallArguments(e, t))
			}
			render(e, t, { isCalleeOfRenderedParent: s, preventASI: i, renderedParentType: n, renderedSurroundingElement: r } = me) {
				const o = this.getUsedBranch()
				if (this.test.included) this.test.render(e, t, { renderedSurroundingElement: r }), this.consequent.render(e, t), this.alternate.render(e, t)
				else {
					const a = mn(e.original, ':', this.consequent.end),
						l = yn(e.original, (this.consequent.included ? mn(e.original, '?', this.test.end) : a) + 1)
					i && vn(e, l, o.start),
						e.remove(this.start, l),
						this.consequent.included && e.remove(a, this.end),
						pn(this, e),
						o.render(e, t, { isCalleeOfRenderedParent: s, preventASI: !0, renderedParentType: n || this.parent.type, renderedSurroundingElement: r || this.parent.type })
				}
			}
			getUsedBranch() {
				if (this.isBranchResolutionAnalysed) return this.usedBranch
				this.isBranchResolutionAnalysed = !0
				const e = this.test.getLiteralValueAtPath(X, se, this)
				return 'symbol' == typeof e ? null : (this.usedBranch = e ? this.consequent : this.alternate)
			}
		},
		ContinueStatement: class extends ei {
			hasEffects(e) {
				if (this.label) {
					if (!e.ignore.labels.has(this.label.name)) return !0
					e.includedLabels.add(this.label.name)
				} else {
					if (!e.ignore.continues) return !0
					e.hasContinue = !0
				}
				return (e.brokenFlow = !0), !1
			}
			include(e) {
				;(this.included = !0), this.label ? (this.label.include(), e.includedLabels.add(this.label.name)) : (e.hasContinue = !0), (e.brokenFlow = !0)
			}
		},
		DoWhileStatement: class extends ei {
			hasEffects(e) {
				return !!this.test.hasEffects(e) || tr(e, this.body)
			}
			include(e, t) {
				;(this.included = !0), this.test.include(e, t), sr(e, this.body, t)
			}
		},
		EmptyStatement: class extends ei {
			hasEffects() {
				return !1
			}
		},
		ExportAllDeclaration: ir,
		ExportDefaultDeclaration: rr,
		ExportNamedDeclaration: or,
		ExportSpecifier: class extends ei {
			applyDeoptimizations() {}
		},
		ExpressionStatement: An,
		ForInStatement: class extends ei {
			createScope(e) {
				this.scope = new Sn(e)
			}
			hasEffects(e) {
				const { body: t, deoptimized: s, left: i, right: n } = this
				return s || this.applyDeoptimizations(), !(!i.hasEffectsAsAssignmentTarget(e, !1) && !n.hasEffects(e)) || tr(e, t)
			}
			include(e, t) {
				const { body: s, deoptimized: i, left: n, right: r } = this
				i || this.applyDeoptimizations(), (this.included = !0), n.includeAsAssignmentTarget(e, t || !0, !1), r.include(e, t), sr(e, s, t)
			}
			initialise() {
				this.left.setAssignedValue(ae)
			}
			render(e, t) {
				this.left.render(e, t, fn), this.right.render(e, t, fn), 110 === e.original.charCodeAt(this.right.start - 1) && e.prependLeft(this.right.start, ' '), this.body.render(e, t)
			}
			applyDeoptimizations() {
				;(this.deoptimized = !0), this.left.deoptimizePath(X), this.context.requestTreeshakingPass()
			}
		},
		ForOfStatement: class extends ei {
			createScope(e) {
				this.scope = new Sn(e)
			}
			hasEffects() {
				return this.deoptimized || this.applyDeoptimizations(), !0
			}
			include(e, t) {
				const { body: s, deoptimized: i, left: n, right: r } = this
				i || this.applyDeoptimizations(), (this.included = !0), n.includeAsAssignmentTarget(e, t || !0, !1), r.include(e, t), sr(e, s, t)
			}
			initialise() {
				this.left.setAssignedValue(ae)
			}
			render(e, t) {
				this.left.render(e, t, fn), this.right.render(e, t, fn), 102 === e.original.charCodeAt(this.right.start - 1) && e.prependLeft(this.right.start, ' '), this.body.render(e, t)
			}
			applyDeoptimizations() {
				;(this.deoptimized = !0), this.left.deoptimizePath(X), this.right.deoptimizePath(Q), this.context.requestTreeshakingPass()
			}
		},
		ForStatement: class extends ei {
			createScope(e) {
				this.scope = new Sn(e)
			}
			hasEffects(e) {
				return !!(this.init?.hasEffects(e) || this.test?.hasEffects(e) || this.update?.hasEffects(e)) || tr(e, this.body)
			}
			include(e, t) {
				;(this.included = !0), this.init?.include(e, t, { asSingleStatement: !0 }), this.test?.include(e, t), this.update?.include(e, t), sr(e, this.body, t)
			}
			render(e, t) {
				this.init?.render(e, t, fn), this.test?.render(e, t, fn), this.update?.render(e, t, fn), this.body.render(e, t)
			}
		},
		FunctionDeclaration: nr,
		FunctionExpression: ar,
		Identifier: hn,
		IfStatement: hr,
		ImportAttribute: class extends ei {},
		ImportDeclaration: ur,
		ImportDefaultSpecifier: dr,
		ImportExpression: class extends ei {
			constructor() {
				super(...arguments),
					(this.inlineNamespace = null),
					(this.assertions = null),
					(this.mechanism = null),
					(this.namespaceExportName = void 0),
					(this.resolution = null),
					(this.resolutionString = null)
			}
			bind() {
				this.source.bind()
			}
			getDeterministicImportedNames() {
				const e = this.parent
				if (e instanceof An) return ye
				if (e instanceof Ln) {
					const t = e.parent
					if (t instanceof An) return ye
					if (t instanceof jr) {
						const e = t.id
						return e instanceof _n ? Wr(e) : void 0
					}
					if (t instanceof jn) {
						const e = t.property
						if (!t.computed && e instanceof hn) return [e.name]
					}
				} else if (e instanceof jn) {
					const t = e.parent,
						s = e.property
					if (!(t instanceof Wn && s instanceof hn)) return
					const i = s.name
					if (t.parent instanceof An && ['catch', 'finally'].includes(i)) return ye
					if ('then' !== i) return
					if (0 === t.arguments.length) return ye
					const n = t.arguments[0]
					if (1 !== t.arguments.length || !(n instanceof Pn || n instanceof ar)) return
					if (0 === n.params.length) return ye
					const r = n.params[0]
					return 1 === n.params.length && r instanceof _n ? Wr(r) : void 0
				}
			}
			hasEffects() {
				return !0
			}
			include(e, t) {
				this.included || ((this.included = !0), this.context.includeDynamicImport(this), this.scope.addAccessedDynamicImport(this)), this.source.include(e, t)
			}
			initialise() {
				this.context.addDynamicImport(this)
			}
			parseNode(e) {
				super.parseNode(e, ['source'])
			}
			render(e, t) {
				const {
					snippets: { _: s, getDirectReturnFunction: i, getObject: n, getPropertyAccess: r }
				} = t
				if (this.inlineNamespace) {
					const [t, s] = i([], { functionReturn: !0, lineBreakIndent: null, name: null })
					e.overwrite(this.start, this.end, `Promise.resolve().then(${t}${this.inlineNamespace.getName(r)}${s})`)
				} else {
					if (
						(this.mechanism && (e.overwrite(this.start, mn(e.original, '(', this.start + 6) + 1, this.mechanism.left), e.overwrite(this.end - 1, this.end, this.mechanism.right)),
						this.resolutionString)
					) {
						if ((e.overwrite(this.source.start, this.source.end, this.resolutionString), this.namespaceExportName)) {
							const [t, s] = i(['n'], { functionReturn: !0, lineBreakIndent: null, name: null })
							e.prependLeft(this.end, `.then(${t}n.${this.namespaceExportName}${s})`)
						}
					} else this.source.render(e, t)
					!0 !== this.assertions &&
						(this.arguments && e.overwrite(this.source.end, this.end - 1, '', { contentOnly: !0 }),
						this.assertions && e.appendLeft(this.end - 1, `,${s}${n([['assert', this.assertions]], { lineBreakIndent: null })}`))
				}
			}
			setExternalResolution(e, t, s, i, n, r, o, a, l) {
				const { format: c } = s
				;(this.inlineNamespace = null), (this.resolution = t), (this.resolutionString = o), (this.namespaceExportName = a), (this.assertions = l)
				const h = [...(Gr[c] || [])]
				let u
				;({ helper: u, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(t, e, s, i, n)), u && h.push(u), h.length > 0 && this.scope.addAccessedGlobals(h, r)
			}
			setInternalResolution(e) {
				this.inlineNamespace = e
			}
			applyDeoptimizations() {}
			getDynamicImportMechanismAndHelper(
				e,
				t,
				{ compact: s, dynamicImportFunction: i, dynamicImportInCjs: n, format: r, generatedCode: { arrowFunctions: o }, interop: a },
				{ _: l, getDirectReturnFunction: c, getDirectReturnIifeLeft: h },
				u
			) {
				const d = u.hookFirstSync('renderDynamicImport', [
					{
						customResolution: 'string' == typeof this.resolution ? this.resolution : null,
						format: r,
						moduleId: this.context.module.id,
						targetModuleId: this.resolution && 'string' != typeof this.resolution ? this.resolution.id : null
					}
				])
				if (d) return { helper: null, mechanism: d }
				const p = !this.resolution || 'string' == typeof this.resolution
				switch (r) {
					case 'cjs': {
						if (n && (!e || 'string' == typeof e || e instanceof Jt)) return { helper: null, mechanism: null }
						const s = Ur(e, t, a)
						let i = 'require(',
							r = ')'
						s && ((i = `/*#__PURE__*/${s}(${i}`), (r += ')'))
						const [l, u] = c([], { functionReturn: !0, lineBreakIndent: null, name: null })
						return (
							(i = `Promise.resolve().then(${l}${i}`),
							(r += `${u})`),
							!o && p && ((i = h(['t'], `${i}t${r}`, { needsArrowReturnParens: !1, needsWrappedFunction: !0 })), (r = ')')),
							{ helper: s, mechanism: { left: i, right: r } }
						)
					}
					case 'amd': {
						const i = s ? 'c' : 'resolve',
							n = s ? 'e' : 'reject',
							r = Ur(e, t, a),
							[u, d] = c(['m'], { functionReturn: !1, lineBreakIndent: null, name: null }),
							f = r ? `${u}${i}(/*#__PURE__*/${r}(m))${d}` : i,
							[m, g] = c([i, n], { functionReturn: !1, lineBreakIndent: null, name: null })
						let y = `new Promise(${m}require([`,
							x = `],${l}${f},${l}${n})${g})`
						return !o && p && ((y = h(['t'], `${y}t${x}`, { needsArrowReturnParens: !1, needsWrappedFunction: !0 })), (x = ')')), { helper: r, mechanism: { left: y, right: x } }
					}
					case 'system':
						return { helper: null, mechanism: { left: 'module.import(', right: ')' } }
					case 'es':
						if (i) return { helper: null, mechanism: { left: `${i}(`, right: ')' } }
				}
				return { helper: null, mechanism: null }
			}
		},
		ImportNamespaceSpecifier: qr,
		ImportSpecifier: class extends ei {
			applyDeoptimizations() {}
		},
		LabeledStatement: class extends ei {
			hasEffects(e) {
				const t = e.brokenFlow
				return (
					e.ignore.labels.add(this.label.name),
					!!this.body.hasEffects(e) || (e.ignore.labels.delete(this.label.name), e.includedLabels.has(this.label.name) && (e.includedLabels.delete(this.label.name), (e.brokenFlow = t)), !1)
				)
			}
			include(e, t) {
				this.included = !0
				const s = e.brokenFlow
				this.body.include(e, t), (t || e.includedLabels.has(this.label.name)) && (this.label.include(), e.includedLabels.delete(this.label.name), (e.brokenFlow = s))
			}
			render(e, t) {
				this.label.included ? this.label.render(e, t) : e.remove(this.start, yn(e.original, mn(e.original, ':', this.label.end) + 1)), this.body.render(e, t)
			}
		},
		Literal: Bn,
		LogicalExpression: class extends ei {
			constructor() {
				super(...arguments), (this.expressionsToBeDeoptimized = []), (this.isBranchResolutionAnalysed = !1), (this.usedBranch = null)
			}
			deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
				this.left.deoptimizeArgumentsOnInteractionAtPath(e, t, s), this.right.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
			}
			deoptimizeCache() {
				if (this.usedBranch) {
					const e = this.usedBranch === this.left ? this.right : this.left
					;(this.usedBranch = null), e.deoptimizePath(Q)
					const { context: t, expressionsToBeDeoptimized: s } = this
					this.expressionsToBeDeoptimized = ye
					for (const e of s) e.deoptimizeCache()
					t.requestTreeshakingPass()
				}
			}
			deoptimizePath(e) {
				const t = this.getUsedBranch()
				t ? t.deoptimizePath(e) : (this.left.deoptimizePath(e), this.right.deoptimizePath(e))
			}
			getLiteralValueAtPath(e, t, s) {
				const i = this.getUsedBranch()
				return i ? (this.expressionsToBeDeoptimized.push(s), i.getLiteralValueAtPath(e, t, s)) : ne
			}
			getReturnExpressionWhenCalledAtPath(e, t, s, i) {
				const n = this.getUsedBranch()
				return n
					? (this.expressionsToBeDeoptimized.push(i), n.getReturnExpressionWhenCalledAtPath(e, t, s, i))
					: [new er([this.left.getReturnExpressionWhenCalledAtPath(e, t, s, i)[0], this.right.getReturnExpressionWhenCalledAtPath(e, t, s, i)[0]]), !1]
			}
			hasEffects(e) {
				return !!this.left.hasEffects(e) || (this.getUsedBranch() !== this.left && this.right.hasEffects(e))
			}
			hasEffectsOnInteractionAtPath(e, t, s) {
				const i = this.getUsedBranch()
				return i ? i.hasEffectsOnInteractionAtPath(e, t, s) : this.left.hasEffectsOnInteractionAtPath(e, t, s) || this.right.hasEffectsOnInteractionAtPath(e, t, s)
			}
			include(e, t) {
				this.included = !0
				const s = this.getUsedBranch()
				t || (s === this.right && this.left.shouldBeIncluded(e)) || !s ? (this.left.include(e, t), this.right.include(e, t)) : s.include(e, t)
			}
			render(e, t, { isCalleeOfRenderedParent: s, preventASI: i, renderedParentType: n, renderedSurroundingElement: r } = me) {
				if (this.left.included && this.right.included) this.left.render(e, t, { preventASI: i, renderedSurroundingElement: r }), this.right.render(e, t)
				else {
					const o = mn(e.original, this.operator, this.left.end)
					if (this.right.included) {
						const t = yn(e.original, o + 2)
						e.remove(this.start, t), i && vn(e, t, this.right.start)
					} else e.remove(o, this.end)
					pn(this, e), this.getUsedBranch().render(e, t, { isCalleeOfRenderedParent: s, preventASI: i, renderedParentType: n || this.parent.type, renderedSurroundingElement: r || this.parent.type })
				}
			}
			getUsedBranch() {
				if (!this.isBranchResolutionAnalysed) {
					this.isBranchResolutionAnalysed = !0
					const e = this.left.getLiteralValueAtPath(X, se, this)
					if ('symbol' == typeof e) return null
					this.usedBranch = ('||' === this.operator && e) || ('&&' === this.operator && !e) || ('??' === this.operator && null != e) ? this.left : this.right
				}
				return this.usedBranch
			}
		},
		MemberExpression: jn,
		MetaProperty: class extends ei {
			constructor() {
				super(...arguments), (this.metaProperty = null), (this.preliminaryChunkId = null), (this.referenceId = null)
			}
			getReferencedFileName(e) {
				const {
					meta: { name: t },
					metaProperty: s
				} = this
				return t === Kr && s?.startsWith(Hr) ? e.getFileName(s.slice(16)) : null
			}
			hasEffects() {
				return !1
			}
			hasEffectsOnInteractionAtPath(e, { type: t }) {
				return e.length > 1 || 0 !== t
			}
			include() {
				if (!this.included && ((this.included = !0), this.meta.name === Kr)) {
					this.context.addImportMeta(this)
					const e = this.parent,
						t = (this.metaProperty = e instanceof jn && 'string' == typeof e.propertyKey ? e.propertyKey : null)
					t?.startsWith(Hr) && (this.referenceId = t.slice(16))
				}
			}
			render(e, t) {
				const { format: s, pluginDriver: i, snippets: n } = t,
					{
						context: { module: r },
						meta: { name: o },
						metaProperty: a,
						parent: l,
						preliminaryChunkId: c,
						referenceId: h,
						start: u,
						end: d
					} = this,
					{ id: p } = r
				if (o !== Kr) return
				const f = c
				if (h) {
					const t = i.getFileName(h),
						n = P(_($(f), t)),
						r = i.hookFirstSync('resolveFileUrl', [{ chunkId: f, fileName: t, format: s, moduleId: p, referenceId: h, relativePath: n }]) || no[s](n)
					return void e.overwrite(l.start, l.end, r, { contentOnly: !0 })
				}
				let m = i.hookFirstSync('resolveImportMeta', [a, { chunkId: f, format: s, moduleId: p }])
				m || ((m = ro[s]?.(a, { chunkId: f, snippets: n })), t.accessedDocumentCurrentScript || (t.accessedDocumentCurrentScript = Yr.includes(s) && 'undefined' !== m)),
					'string' == typeof m && (l instanceof jn ? e.overwrite(l.start, l.end, m, { contentOnly: !0 }) : e.overwrite(u, d, m, { contentOnly: !0 }))
			}
			setResolution(e, t, s) {
				this.preliminaryChunkId = s
				const i = (this.metaProperty?.startsWith(Hr) ? Qr : Xr)[e]
				i.length > 0 && this.scope.addAccessedGlobals(i, t)
			}
		},
		MethodDefinition: Yn,
		NewExpression: class extends ei {
			hasEffects(e) {
				try {
					for (const t of this.arguments) if (t.hasEffects(e)) return !0
					return !this.annotationPure && (this.callee.hasEffects(e) || this.callee.hasEffectsOnInteractionAtPath(X, this.interaction, e))
				} finally {
					this.deoptimized || this.applyDeoptimizations()
				}
			}
			hasEffectsOnInteractionAtPath(e, { type: t }) {
				return e.length > 0 || 0 !== t
			}
			include(e, t) {
				this.deoptimized || this.applyDeoptimizations(), t ? super.include(e, t) : ((this.included = !0), this.callee.include(e, !1)), this.callee.includeCallArguments(e, this.arguments)
			}
			initialise() {
				this.interaction = { args: [null, ...this.arguments], type: 2, withNew: !0 }
			}
			render(e, t) {
				this.callee.render(e, t), Vn(e, t, this)
			}
			applyDeoptimizations() {
				;(this.deoptimized = !0), this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction, X, se), this.context.requestTreeshakingPass()
			}
		},
		ObjectExpression: class extends ei {
			constructor() {
				super(...arguments), (this.objectEntity = null)
			}
			deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
				this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(e, t, s)
			}
			deoptimizeCache() {
				this.getObjectEntity().deoptimizeAllProperties()
			}
			deoptimizePath(e) {
				this.getObjectEntity().deoptimizePath(e)
			}
			getLiteralValueAtPath(e, t, s) {
				return this.getObjectEntity().getLiteralValueAtPath(e, t, s)
			}
			getReturnExpressionWhenCalledAtPath(e, t, s, i) {
				return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e, t, s, i)
			}
			hasEffectsOnInteractionAtPath(e, t, s) {
				return this.getObjectEntity().hasEffectsOnInteractionAtPath(e, t, s)
			}
			render(e, t, { renderedSurroundingElement: s } = me) {
				super.render(e, t), (s !== Rs && s !== ks) || (e.appendRight(this.start, '('), e.prependLeft(this.end, ')'))
			}
			applyDeoptimizations() {}
			getObjectEntity() {
				if (null !== this.objectEntity) return this.objectEntity
				let e = ui
				const t = []
				for (const s of this.properties) {
					if (s instanceof ti) {
						t.push({ key: q, kind: 'init', property: s })
						continue
					}
					let i
					if (s.computed) {
						const e = s.key.getLiteralValueAtPath(X, se, this)
						if ('symbol' == typeof e) {
							t.push({ key: q, kind: s.kind, property: s })
							continue
						}
						i = String(e)
					} else if (((i = s.key instanceof hn ? s.key.name : String(s.key.value)), '__proto__' === i && 'init' === s.kind)) {
						e = s.value instanceof Bn && null === s.value.value ? null : s.value
						continue
					}
					t.push({ key: i, kind: s.kind, property: s })
				}
				return (this.objectEntity = new li(t, e))
			}
		},
		ObjectPattern: _n,
		PrivateIdentifier: class extends ei {},
		Program: oo,
		Property: class extends Kn {
			constructor() {
				super(...arguments), (this.declarationInit = null)
			}
			declare(e, t) {
				return (this.declarationInit = t), this.value.declare(e, ae)
			}
			hasEffects(e) {
				this.deoptimized || this.applyDeoptimizations()
				const t = this.context.options.treeshake.propertyReadSideEffects
				return ('ObjectPattern' === this.parent.type && 'always' === t) || this.key.hasEffects(e) || this.value.hasEffects(e)
			}
			markDeclarationReached() {
				this.value.markDeclarationReached()
			}
			render(e, t) {
				this.shorthand || this.key.render(e, t), this.value.render(e, t, { isShorthandProperty: this.shorthand })
			}
			applyDeoptimizations() {
				;(this.deoptimized = !0), null !== this.declarationInit && (this.declarationInit.deoptimizePath([q, q]), this.context.requestTreeshakingPass())
			}
		},
		PropertyDefinition: class extends ei {
			deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
				this.value?.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
			}
			deoptimizePath(e) {
				this.value?.deoptimizePath(e)
			}
			getLiteralValueAtPath(e, t, s) {
				return this.value ? this.value.getLiteralValueAtPath(e, t, s) : ne
			}
			getReturnExpressionWhenCalledAtPath(e, t, s, i) {
				return this.value ? this.value.getReturnExpressionWhenCalledAtPath(e, t, s, i) : le
			}
			hasEffects(e) {
				return this.key.hasEffects(e) || (this.static && !!this.value?.hasEffects(e))
			}
			hasEffectsOnInteractionAtPath(e, t, s) {
				return !this.value || this.value.hasEffectsOnInteractionAtPath(e, t, s)
			}
			applyDeoptimizations() {}
		},
		RestElement: In,
		ReturnStatement: class extends ei {
			hasEffects(e) {
				return !(e.ignore.returnYield && !this.argument?.hasEffects(e)) || ((e.brokenFlow = !0), !1)
			}
			include(e, t) {
				;(this.included = !0), this.argument?.include(e, t), (e.brokenFlow = !0)
			}
			initialise() {
				this.scope.addReturnExpression(this.argument || ae)
			}
			render(e, t) {
				this.argument && (this.argument.render(e, t, { preventASI: !0 }), this.argument.start === this.start + 6 && e.prependLeft(this.start + 6, ' '))
			}
		},
		SequenceExpression: class extends ei {
			deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
				this.expressions[this.expressions.length - 1].deoptimizeArgumentsOnInteractionAtPath(e, t, s)
			}
			deoptimizePath(e) {
				this.expressions[this.expressions.length - 1].deoptimizePath(e)
			}
			getLiteralValueAtPath(e, t, s) {
				return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(e, t, s)
			}
			hasEffects(e) {
				for (const t of this.expressions) if (t.hasEffects(e)) return !0
				return !1
			}
			hasEffectsOnInteractionAtPath(e, t, s) {
				return this.expressions[this.expressions.length - 1].hasEffectsOnInteractionAtPath(e, t, s)
			}
			include(e, t) {
				this.included = !0
				const s = this.expressions[this.expressions.length - 1]
				for (const i of this.expressions) (t || (i === s && !(this.parent instanceof An)) || i.shouldBeIncluded(e)) && i.include(e, t)
			}
			render(e, t, { renderedParentType: s, isCalleeOfRenderedParent: i, preventASI: n } = me) {
				let r = 0,
					o = null
				const a = this.expressions[this.expressions.length - 1]
				for (const { node: l, separator: c, start: h, end: u } of bn(this.expressions, e, this.start, this.end))
					if (l.included)
						if ((r++, (o = c), 1 === r && n && vn(e, h, l.start), 1 === r)) {
							const n = s || this.parent.type
							l.render(e, t, { isCalleeOfRenderedParent: i && l === a, renderedParentType: n, renderedSurroundingElement: n })
						} else l.render(e, t)
					else dn(l, e, h, u)
				o && e.remove(o, this.end)
			}
		},
		SpreadElement: ti,
		StaticBlock: class extends ei {
			createScope(e) {
				this.scope = new Sn(e)
			}
			hasEffects(e) {
				for (const t of this.body) if (t.hasEffects(e)) return !0
				return !1
			}
			include(e, t) {
				this.included = !0
				for (const s of this.body) (t || s.shouldBeIncluded(e)) && s.include(e, t)
			}
			render(e, t) {
				if (this.body.length > 0) {
					const s = mn(e.original.slice(this.start, this.end), '{') + 1
					En(this.body, e, this.start + s, this.end - 1, t)
				} else super.render(e, t)
			}
		},
		Super: class extends ei {
			bind() {
				this.variable = this.scope.findVariable('this')
			}
			deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
				this.variable.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
			}
			deoptimizePath(e) {
				this.variable.deoptimizePath(e)
			}
			include() {
				this.included || ((this.included = !0), this.context.includeVariableInModule(this.variable))
			}
		},
		SwitchCase: ao,
		SwitchStatement: class extends ei {
			createScope(e) {
				;(this.parentScope = e), (this.scope = new Sn(e))
			}
			hasEffects(e) {
				if (this.discriminant.hasEffects(e)) return !0
				const { brokenFlow: t, hasBreak: s, ignore: i } = e,
					{ breaks: n } = i
				;(i.breaks = !0), (e.hasBreak = !1)
				let r = !0
				for (const s of this.cases) {
					if (s.hasEffects(e)) return !0
					r && (r = e.brokenFlow && !e.hasBreak), (e.hasBreak = !1), (e.brokenFlow = t)
				}
				return null !== this.defaultCase && (e.brokenFlow = r), (i.breaks = n), (e.hasBreak = s), !1
			}
			include(e, t) {
				;(this.included = !0), this.discriminant.include(e, t)
				const { brokenFlow: s, hasBreak: i } = e
				e.hasBreak = !1
				let n = !0,
					r = t || (null !== this.defaultCase && this.defaultCase < this.cases.length - 1)
				for (let i = this.cases.length - 1; i >= 0; i--) {
					const o = this.cases[i]
					if ((o.included && (r = !0), !r)) {
						const e = is()
						;(e.ignore.breaks = !0), (r = o.hasEffects(e))
					}
					r ? (o.include(e, t), n && (n = e.brokenFlow && !e.hasBreak), (e.hasBreak = !1), (e.brokenFlow = s)) : (n = s)
				}
				r && null !== this.defaultCase && (e.brokenFlow = n), (e.hasBreak = i)
			}
			initialise() {
				for (let e = 0; e < this.cases.length; e++) if (null === this.cases[e].test) return void (this.defaultCase = e)
				this.defaultCase = null
			}
			parseNode(e) {
				;(this.discriminant = new (this.context.getNodeConstructor(e.discriminant.type))(e.discriminant, this, this.parentScope)), super.parseNode(e)
			}
			render(e, t) {
				this.discriminant.render(e, t), this.cases.length > 0 && En(this.cases, e, this.cases[0].start, this.end - 1, t)
			}
		},
		TaggedTemplateExpression: class extends Gn {
			bind() {
				if ((super.bind(), this.tag.type === Os)) {
					const e = this.tag.name
					this.scope.findVariable(e).isNamespace && this.context.log(Ae, Ot(e), this.start)
				}
			}
			hasEffects(e) {
				try {
					for (const t of this.quasi.expressions) if (t.hasEffects(e)) return !0
					return this.tag.hasEffects(e) || this.tag.hasEffectsOnInteractionAtPath(X, this.interaction, e)
				} finally {
					this.deoptimized || this.applyDeoptimizations()
				}
			}
			include(e, t) {
				this.deoptimized || this.applyDeoptimizations(), t ? super.include(e, t) : ((this.included = !0), this.tag.include(e, t), this.quasi.include(e, t)), this.tag.includeCallArguments(e, this.args)
				const [s] = this.getReturnExpression()
				s.included || s.include(e, !1)
			}
			initialise() {
				;(this.args = [ae, ...this.quasi.expressions]), (this.interaction = { args: [this.tag instanceof jn && !this.tag.variable ? this.tag.object : null, ...this.args], type: 2, withNew: !1 })
			}
			render(e, t) {
				this.tag.render(e, t, { isCalleeOfRenderedParent: !0 }), this.quasi.render(e, t)
			}
			applyDeoptimizations() {
				;(this.deoptimized = !0), this.tag.deoptimizeArgumentsOnInteractionAtPath(this.interaction, X, se), this.context.requestTreeshakingPass()
			}
			getReturnExpression(e = se) {
				return null === this.returnExpression
					? ((this.returnExpression = le), (this.returnExpression = this.tag.getReturnExpressionWhenCalledAtPath(X, this.interaction, e, this)))
					: this.returnExpression
			}
		},
		TemplateElement: class extends ei {
			bind() {}
			hasEffects() {
				return !1
			}
			include() {
				this.included = !0
			}
			parseNode(e) {
				;(this.value = e.value), super.parseNode(e)
			}
			render() {}
		},
		TemplateLiteral: lo,
		ThisExpression: class extends ei {
			bind() {
				this.variable = this.scope.findVariable('this')
			}
			deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
				this.variable.deoptimizeArgumentsOnInteractionAtPath(e, t, s)
			}
			deoptimizePath(e) {
				this.variable.deoptimizePath(e)
			}
			hasEffectsOnInteractionAtPath(e, t, s) {
				return 0 === e.length ? 0 !== t.type : this.variable.hasEffectsOnInteractionAtPath(e, t, s)
			}
			include() {
				this.included || ((this.included = !0), this.context.includeVariableInModule(this.variable))
			}
			initialise() {
				;(this.alias = this.scope.findLexicalBoundary() instanceof uo ? this.context.moduleContext : null),
					'undefined' === this.alias &&
						this.context.log(
							Ae,
							{
								code: 'THIS_IS_UNDEFINED',
								message: "The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten",
								url: De('troubleshooting/#error-this-is-undefined')
							},
							this.start
						)
			}
			render(e) {
				null !== this.alias && e.overwrite(this.start, this.end, this.alias, { contentOnly: !1, storeName: !0 })
			}
		},
		ThrowStatement: class extends ei {
			hasEffects() {
				return !0
			}
			include(e, t) {
				;(this.included = !0), this.argument.include(e, t), (e.brokenFlow = !0)
			}
			render(e, t) {
				this.argument.render(e, t, { preventASI: !0 }), this.argument.start === this.start + 5 && e.prependLeft(this.start + 5, ' ')
			}
		},
		TryStatement: class extends ei {
			constructor() {
				super(...arguments), (this.directlyIncluded = !1), (this.includedLabelsAfterBlock = null)
			}
			hasEffects(e) {
				return (this.context.options.treeshake.tryCatchDeoptimization ? this.block.body.length > 0 : this.block.hasEffects(e)) || !!this.finalizer?.hasEffects(e)
			}
			include(e, t) {
				const s = this.context.options.treeshake?.tryCatchDeoptimization,
					{ brokenFlow: i, includedLabels: n } = e
				if (this.directlyIncluded && s) {
					if (this.includedLabelsAfterBlock) for (const e of this.includedLabelsAfterBlock) n.add(e)
				} else (this.included = !0), (this.directlyIncluded = !0), this.block.include(e, s ? Js : t), n.size > 0 && (this.includedLabelsAfterBlock = [...n]), (e.brokenFlow = i)
				null !== this.handler && (this.handler.include(e, t), (e.brokenFlow = i)), this.finalizer?.include(e, t)
			}
		},
		UnaryExpression: class extends ei {
			getLiteralValueAtPath(e, t, s) {
				if (e.length > 0) return ne
				const i = this.argument.getLiteralValueAtPath(X, t, s)
				return 'symbol' == typeof i ? ne : po[this.operator](i)
			}
			hasEffects(e) {
				return (
					this.deoptimized || this.applyDeoptimizations(),
					!('typeof' === this.operator && this.argument instanceof hn) && (this.argument.hasEffects(e) || ('delete' === this.operator && this.argument.hasEffectsOnInteractionAtPath(X, ue, e)))
				)
			}
			hasEffectsOnInteractionAtPath(e, { type: t }) {
				return 0 !== t || e.length > ('void' === this.operator ? 0 : 1)
			}
			applyDeoptimizations() {
				;(this.deoptimized = !0), 'delete' === this.operator && (this.argument.deoptimizePath(X), this.context.requestTreeshakingPass())
			}
		},
		UnknownNode: class extends ei {
			hasEffects() {
				return !0
			}
			include(e) {
				super.include(e, !0)
			}
		},
		UpdateExpression: class extends ei {
			hasEffects(e) {
				return this.deoptimized || this.applyDeoptimizations(), this.argument.hasEffectsAsAssignmentTarget(e, !0)
			}
			hasEffectsOnInteractionAtPath(e, { type: t }) {
				return e.length > 1 || 0 !== t
			}
			include(e, t) {
				this.deoptimized || this.applyDeoptimizations(), (this.included = !0), this.argument.includeAsAssignmentTarget(e, t, !0)
			}
			initialise() {
				this.argument.setAssignedValue(ae)
			}
			render(e, t) {
				const {
					exportNamesByVariable: s,
					format: i,
					snippets: { _: n }
				} = t
				if ((this.argument.render(e, t), 'system' === i)) {
					const i = this.argument.variable,
						r = s.get(i)
					if (r)
						if (this.prefix) 1 === r.length ? $n(i, this.start, this.end, e, t) : Nn(i, this.start, this.end, this.parent.type !== Rs, e, t)
						else {
							const s = this.operator[0]
							!(function (e, t, s, i, n, r, o) {
								const { _: a } = r.snippets
								n.prependRight(t, `${Cn([e], r, o)},${a}`), i && (n.prependRight(t, '('), n.appendLeft(s, ')'))
							})(i, this.start, this.end, this.parent.type !== Rs, e, t, `${n}${s}${n}1`)
						}
				}
			}
			applyDeoptimizations() {
				if (((this.deoptimized = !0), this.argument.deoptimizePath(X), this.argument instanceof hn)) {
					this.scope.findVariable(this.argument.name).isReassigned = !0
				}
				this.context.requestTreeshakingPass()
			}
		},
		VariableDeclaration: fo,
		VariableDeclarator: jr,
		WhileStatement: class extends ei {
			hasEffects(e) {
				return !!this.test.hasEffects(e) || tr(e, this.body)
			}
			include(e, t) {
				;(this.included = !0), this.test.include(e, t), sr(e, this.body, t)
			}
		},
		YieldExpression: class extends ei {
			hasEffects(e) {
				return this.deoptimized || this.applyDeoptimizations(), !(e.ignore.returnYield && !this.argument?.hasEffects(e))
			}
			render(e, t) {
				this.argument && (this.argument.render(e, t, { preventASI: !0 }), this.argument.start === this.start + 5 && e.prependLeft(this.start + 5, ' '))
			}
		}
	},
	go = '_missingExportShim'
class yo extends pe {
	constructor(e) {
		super(go), (this.module = e)
	}
	include() {
		super.include(), (this.module.needsExportShim = !0)
	}
}
class xo extends pe {
	constructor(e) {
		super(e.getModuleName()), (this.memberVariables = null), (this.mergedNamespaces = []), (this.referencedEarly = !1), (this.references = []), (this.context = e), (this.module = e.module)
	}
	addReference(e) {
		this.references.push(e), (this.name = e.name)
	}
	deoptimizeArgumentsOnInteractionAtPath(e, t, s) {
		if (t.length > 1 || (1 === t.length && 2 === e.type)) {
			const i = t[0]
			'string' == typeof i ? this.getMemberVariables()[i]?.deoptimizeArgumentsOnInteractionAtPath(e, t.slice(1), s) : ce(e)
		}
	}
	deoptimizePath(e) {
		if (e.length > 1) {
			const t = e[0]
			'string' == typeof t && this.getMemberVariables()[t]?.deoptimizePath(e.slice(1))
		}
	}
	getLiteralValueAtPath(e) {
		return e[0] === Y ? 'Module' : ne
	}
	getMemberVariables() {
		if (this.memberVariables) return this.memberVariables
		const e = Object.create(null),
			t = [...this.context.getExports(), ...this.context.getReexports()].sort()
		for (const s of t)
			if ('*' !== s[0] && s !== this.module.info.syntheticNamedExports) {
				const t = this.context.traceExport(s)
				t && (e[s] = t)
			}
		return (this.memberVariables = e)
	}
	hasEffectsOnInteractionAtPath(e, t, s) {
		const { type: i } = t
		if (0 === e.length) return !0
		if (1 === e.length && 2 !== i) return 1 === i
		const n = e[0]
		if ('string' != typeof n) return !0
		const r = this.getMemberVariables()[n]
		return !r || r.hasEffectsOnInteractionAtPath(e.slice(1), t, s)
	}
	include() {
		;(this.included = !0), this.context.includeAllExports()
	}
	prepare(e) {
		this.mergedNamespaces.length > 0 && this.module.scope.addAccessedGlobals([Er], e)
	}
	renderBlock(e) {
		const {
				exportNamesByVariable: t,
				format: s,
				freeze: i,
				indent: n,
				namespaceToStringTag: r,
				snippets: { _: o, cnst: a, getObject: l, getPropertyAccess: c, n: h, s: u }
			} = e,
			d = this.getMemberVariables(),
			p = Object.entries(d)
				.filter(([e, t]) => t.included)
				.map(([e, t]) => (this.referencedEarly || t.isReassigned || t === this ? [null, `get ${e}${o}()${o}{${o}return ${t.getName(c)}${u}${o}}`] : [e, t.getName(c)]))
		p.unshift([null, `__proto__:${o}null`])
		let f = l(p, { lineBreakIndent: { base: '', t: n } })
		if (this.mergedNamespaces.length > 0) {
			const e = this.mergedNamespaces.map((e) => e.getName(c))
			f = `/*#__PURE__*/${Er}(${f},${o}[${e.join(`,${o}`)}])`
		} else r && (f = `/*#__PURE__*/Object.defineProperty(${f},${o}Symbol.toStringTag,${o}${zr(l)})`), i && (f = `/*#__PURE__*/Object.freeze(${f})`)
		return (f = `${a} ${this.getName(c)}${o}=${o}${f};`), 'system' === s && t.has(this) && (f += `${h}${Cn([this], e)};`), f
	}
	renderFirst() {
		return this.referencedEarly
	}
	setMergedNamespaces(e) {
		this.mergedNamespaces = e
		const t = this.context.getModuleExecIndex()
		for (const e of this.references)
			if (e.context.getModuleExecIndex() <= t) {
				this.referencedEarly = !0
				break
			}
	}
}
xo.prototype.isNamespace = !0
class Eo extends pe {
	constructor(e, t, s) {
		super(t), (this.baseVariable = null), (this.context = e), (this.module = e.module), (this.syntheticNamespace = s)
	}
	getBaseVariable() {
		if (this.baseVariable) return this.baseVariable
		let e = this.syntheticNamespace
		for (; e instanceof ho || e instanceof Eo; ) {
			if (e instanceof ho) {
				const t = e.getOriginalVariable()
				if (t === e) break
				e = t
			}
			e instanceof Eo && (e = e.syntheticNamespace)
		}
		return (this.baseVariable = e)
	}
	getBaseVariableName() {
		return this.syntheticNamespace.getBaseVariableName()
	}
	getName(e) {
		return `${this.syntheticNamespace.getName(e)}${e(this.name)}`
	}
	include() {
		;(this.included = !0), this.context.includeVariableInModule(this.syntheticNamespace)
	}
	setRenderNames(e, t) {
		super.setRenderNames(e, t)
	}
}
var bo
!(function (e) {
	;(e[(e.LOAD_AND_PARSE = 0)] = 'LOAD_AND_PARSE'), (e[(e.ANALYSE = 1)] = 'ANALYSE'), (e[(e.GENERATE = 2)] = 'GENERATE')
})(bo || (bo = {}))
const vo = new WeakMap()
function So(e, t) {
	if (e) {
		const t = vo.get(e)
		t &&
			(function (e) {
				void 0 === e.encodedMappings && e.decodedMappings && (e.encodedMappings = i.encode(e.decodedMappings)), (e.decodedMappings = void 0)
			})(t)
	}
	if (t) for (const e of t) e.missing || So(e)
}
function Ao(e) {
	if (!e) return null
	if (('string' == typeof e && (e = JSON.parse(e)), !e.mappings)) return { mappings: [], names: [], sources: [], version: 3 }
	const t = e.mappings,
		s = Array.isArray(t),
		n = { decodedMappings: s ? t : void 0, encodedMappings: s ? void 0 : t },
		r = {
			...e,
			get mappings() {
				return n.decodedMappings || ((n.decodedMappings = n.encodedMappings ? i.decode(n.encodedMappings) : []), (n.encodedMappings = void 0)), n.decodedMappings
			}
		}
	return vo.set(r, n), r
}
function ko(e) {
	return e.id
}
const Io = (e) => {
	const t = e.key
	return t && (t.name || t.value)
}
function wo(e, t) {
	const s = Object.keys(e)
	return s.length !== Object.keys(t).length || s.some((s) => e[s] !== t[s])
}
var Po = 'performance' in ('undefined' == typeof globalThis ? ('undefined' == typeof window ? {} : window) : globalThis) ? performance : { now: () => 0 },
	Co = { memoryUsage: () => ({ heapUsed: 0 }) }
let $o = new Map()
function No(e, t) {
	switch (t) {
		case 1:
			return `# ${e}`
		case 2:
			return `## ${e}`
		case 3:
			return e
		default:
			return `${'  '.repeat(t - 4)}- ${e}`
	}
}
function _o(e, t = 3) {
	e = No(e, t)
	const s = Co.memoryUsage().heapUsed,
		i = Po.now(),
		n = $o.get(e)
	void 0 === n ? $o.set(e, { memory: 0, startMemory: s, startTime: i, time: 0, totalMemory: 0 }) : ((n.startMemory = s), (n.startTime = i))
}
function Ro(e, t = 3) {
	e = No(e, t)
	const s = $o.get(e)
	if (void 0 !== s) {
		const e = Co.memoryUsage().heapUsed
		;(s.memory += e - s.startMemory), (s.time += Po.now() - s.startTime), (s.totalMemory = Math.max(s.totalMemory, e))
	}
}
function Mo() {
	const e = {}
	for (const [t, { memory: s, time: i, totalMemory: n }] of $o) e[t] = [i, s, n]
	return e
}
let Oo = Ui,
	Do = Ui
const Lo = [
	'augmentChunkHash',
	'buildEnd',
	'buildStart',
	'generateBundle',
	'load',
	'moduleParsed',
	'options',
	'outputOptions',
	'renderChunk',
	'renderDynamicImport',
	'renderStart',
	'resolveDynamicImport',
	'resolveFileUrl',
	'resolveId',
	'resolveImportMeta',
	'shouldTransformCachedModule',
	'transform',
	'writeBundle'
]
function To(e, t) {
	if (e._hasTimer) return e
	e._hasTimer = !0
	for (const s of Lo)
		if (s in e) {
			let i = `plugin ${t}`
			e.name && (i += ` (${e.name})`), (i += ` - ${s}`)
			const n = function (...e) {
				Oo(i, 4)
				const t = r.apply(this, e)
				return Do(i, 4), t
			}
			let r
			'function' == typeof e[s].handler ? ((r = e[s].handler), (e[s].handler = n)) : ((r = e[s]), (e[s] = n))
		}
	return e
}
function Vo(e) {
	e.isExecuted = !0
	const t = [e],
		s = new Set()
	for (const e of t)
		for (const i of [...e.dependencies, ...e.implicitlyLoadedBefore])
			i instanceof Jt || i.isExecuted || (!i.info.moduleSideEffects && !e.implicitlyLoadedBefore.has(i)) || s.has(i.id) || ((i.isExecuted = !0), s.add(i.id), t.push(i))
}
const Bo = { identifier: null, localName: go }
function zo(e, t, s, i, n = new Map()) {
	const r = n.get(t)
	if (r) {
		if (r.has(e)) return i ? [null] : Qe(((o = t), (a = e.id), { code: rt, exporter: a, message: `"${o}" cannot be exported from "${V(a)}" as it is a reexport that references itself.` }))
		r.add(e)
	} else n.set(t, new Set([e]))
	var o, a
	return e.getVariableForExportName(t, { importerForSideEffects: s, isExportAllSearch: i, searchedNamesAndModules: n })
}
function Fo(e, t) {
	const s = U(t.sideEffectDependenciesByVariable, e, G)
	let i = e
	const n = new Set([i])
	for (;;) {
		const e = i.module
		if (((i = i instanceof ho ? i.getDirectOriginalVariable() : i instanceof Eo ? i.syntheticNamespace : null), !i || n.has(i))) break
		n.add(i), s.add(e)
		const t = e.sideEffectDependenciesByVariable.get(i)
		if (t) for (const e of t) s.add(e)
	}
	return s
}
class jo {
	constructor(e, t, s, i, n, r, o, a) {
		;(this.graph = e),
			(this.id = t),
			(this.options = s),
			(this.alternativeReexportModules = new Map()),
			(this.chunkFileNames = new Set()),
			(this.chunkNames = []),
			(this.cycles = new Set()),
			(this.dependencies = new Set()),
			(this.dynamicDependencies = new Set()),
			(this.dynamicImporters = []),
			(this.dynamicImports = []),
			(this.execIndex = 1 / 0),
			(this.implicitlyLoadedAfter = new Set()),
			(this.implicitlyLoadedBefore = new Set()),
			(this.importDescriptions = new Map()),
			(this.importMetas = []),
			(this.importedFromNotTreeshaken = !1),
			(this.importers = []),
			(this.includedDynamicImporters = []),
			(this.includedImports = new Set()),
			(this.isExecuted = !1),
			(this.isUserDefinedEntryPoint = !1),
			(this.needsExportShim = !1),
			(this.sideEffectDependenciesByVariable = new Map()),
			(this.sourcesWithAssertions = new Map()),
			(this.allExportNames = null),
			(this.ast = null),
			(this.exportAllModules = []),
			(this.exportAllSources = new Set()),
			(this.exportNamesByVariable = null),
			(this.exportShimVariable = new yo(this)),
			(this.exports = new Map()),
			(this.namespaceReexportsByName = new Map()),
			(this.reexportDescriptions = new Map()),
			(this.relevantDependencies = null),
			(this.syntheticExports = new Map()),
			(this.syntheticNamespace = null),
			(this.transformDependencies = []),
			(this.transitiveReexports = null),
			(this.excludeFromSourcemap = /\0/.test(t)),
			(this.context = s.moduleContext(t)),
			(this.preserveSignature = this.options.preserveEntrySignatures)
		const l = this,
			{
				dynamicImports: c,
				dynamicImporters: h,
				exportAllSources: u,
				exports: d,
				implicitlyLoadedAfter: p,
				implicitlyLoadedBefore: f,
				importers: m,
				reexportDescriptions: g,
				sourcesWithAssertions: y
			} = this
		;(this.info = {
			assertions: a,
			ast: null,
			code: null,
			get dynamicallyImportedIdResolutions() {
				return c.map(({ argument: e }) => 'string' == typeof e && l.resolvedIds[e]).filter(Boolean)
			},
			get dynamicallyImportedIds() {
				return c.map(({ id: e }) => e).filter((e) => null != e)
			},
			get dynamicImporters() {
				return h.sort()
			},
			get exportedBindings() {
				const e = { '.': [...d.keys()] }
				for (const [t, { source: s }] of g) (e[s] ?? (e[s] = [])).push(t)
				for (const t of u) (e[t] ?? (e[t] = [])).push('*')
				return e
			},
			get exports() {
				return [...d.keys(), ...g.keys(), ...[...u].map(() => '*')]
			},
			get hasDefaultExport() {
				return l.ast ? l.exports.has('default') || g.has('default') : null
			},
			get hasModuleSideEffects() {
				return Qt('Accessing ModuleInfo.hasModuleSideEffects from plugins is deprecated. Please use ModuleInfo.moduleSideEffects instead.', Xe, !0, s), this.moduleSideEffects
			},
			id: t,
			get implicitlyLoadedAfterOneOf() {
				return Array.from(p, ko).sort()
			},
			get implicitlyLoadedBefore() {
				return Array.from(f, ko).sort()
			},
			get importedIdResolutions() {
				return Array.from(y.keys(), (e) => l.resolvedIds[e]).filter(Boolean)
			},
			get importedIds() {
				return Array.from(y.keys(), (e) => l.resolvedIds[e]?.id).filter(Boolean)
			},
			get importers() {
				return m.sort()
			},
			isEntry: i,
			isExternal: !1,
			get isIncluded() {
				return e.phase !== bo.GENERATE ? null : l.isIncluded()
			},
			meta: { ...o },
			moduleSideEffects: n,
			syntheticNamedExports: r
		}),
			Object.defineProperty(this.info, 'hasModuleSideEffects', { enumerable: !1 })
	}
	basename() {
		const e = C(this.id),
			t = N(this.id)
		return Se(t ? e.slice(0, -t.length) : e)
	}
	bindReferences() {
		this.ast.bind()
	}
	error(e, t) {
		return this.addLocationToLogProps(e, t), Qe(e)
	}
	estimateSize() {
		let e = 0
		for (const t of this.ast.body) t.included && (e += t.end - t.start)
		return e
	}
	getAllExportNames() {
		if (this.allExportNames) return this.allExportNames
		this.allExportNames = new Set([...this.exports.keys(), ...this.reexportDescriptions.keys()])
		for (const e of this.exportAllModules)
			if (e instanceof Jt) this.allExportNames.add(`*${e.id}`)
			else for (const t of e.getAllExportNames()) 'default' !== t && this.allExportNames.add(t)
		return 'string' == typeof this.info.syntheticNamedExports && this.allExportNames.delete(this.info.syntheticNamedExports), this.allExportNames
	}
	getDependenciesToBeIncluded() {
		if (this.relevantDependencies) return this.relevantDependencies
		this.relevantDependencies = new Set()
		const e = new Set(),
			t = new Set(),
			s = new Set(this.includedImports)
		if (this.info.isEntry || this.includedDynamicImporters.length > 0 || this.namespace.included || this.implicitlyLoadedAfter.size > 0)
			for (const e of [...this.getReexports(), ...this.getExports()]) {
				const [t] = this.getVariableForExportName(e)
				t?.included && s.add(t)
			}
		for (let i of s) {
			const s = this.sideEffectDependenciesByVariable.get(i)
			if (s) for (const e of s) t.add(e)
			i instanceof Eo ? (i = i.getBaseVariable()) : i instanceof ho && (i = i.getOriginalVariable()), e.add(i.module)
		}
		if (this.options.treeshake && 'no-treeshake' !== this.info.moduleSideEffects) this.addRelevantSideEffectDependencies(this.relevantDependencies, e, t)
		else for (const e of this.dependencies) this.relevantDependencies.add(e)
		for (const t of e) this.relevantDependencies.add(t)
		return this.relevantDependencies
	}
	getExportNamesByVariable() {
		if (this.exportNamesByVariable) return this.exportNamesByVariable
		const e = new Map()
		for (const t of this.getAllExportNames()) {
			let [s] = this.getVariableForExportName(t)
			if ((s instanceof ho && (s = s.getOriginalVariable()), !s || !(s.included || s instanceof fe))) continue
			const i = e.get(s)
			i ? i.push(t) : e.set(s, [t])
		}
		return (this.exportNamesByVariable = e)
	}
	getExports() {
		return [...this.exports.keys()]
	}
	getReexports() {
		if (this.transitiveReexports) return this.transitiveReexports
		this.transitiveReexports = []
		const e = new Set(this.reexportDescriptions.keys())
		for (const t of this.exportAllModules)
			if (t instanceof Jt) e.add(`*${t.id}`)
			else for (const s of [...t.getReexports(), ...t.getExports()]) 'default' !== s && e.add(s)
		return (this.transitiveReexports = [...e])
	}
	getRenderedExports() {
		const e = [],
			t = []
		for (const s of this.exports.keys()) {
			const [i] = this.getVariableForExportName(s)
			;(i && i.included ? e : t).push(s)
		}
		return { removedExports: t, renderedExports: e }
	}
	getSyntheticNamespace() {
		return (
			null === this.syntheticNamespace &&
				((this.syntheticNamespace = void 0),
				([this.syntheticNamespace] = this.getVariableForExportName('string' == typeof this.info.syntheticNamedExports ? this.info.syntheticNamedExports : 'default', { onlyExplicit: !0 }))),
			this.syntheticNamespace
				? this.syntheticNamespace
				: Qe(
						((e = this.id),
						(t = this.info.syntheticNamedExports),
						{
							code: 'SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT',
							exporter: e,
							message: `Module "${V(e)}" that is marked with \`syntheticNamedExports: ${JSON.stringify(t)}\` needs ${
								'string' == typeof t && 'default' !== t ? `an explicit export named "${t}"` : 'a default export'
							} that does not reexport an unresolved named export of the same module.`
						})
				  )
		)
		var e, t
	}
	getVariableForExportName(e, { importerForSideEffects: t, isExportAllSearch: s, onlyExplicit: i, searchedNamesAndModules: n } = ge) {
		if ('*' === e[0]) {
			if (1 === e.length) return [this.namespace]
			return this.graph.modulesById.get(e.slice(1)).getVariableForExportName('*')
		}
		const r = this.reexportDescriptions.get(e)
		if (r) {
			const [e] = zo(r.module, r.localName, t, !1, n)
			return e ? (t && (Uo(e, t, this), this.info.moduleSideEffects && U(t.sideEffectDependenciesByVariable, e, G).add(this)), [e]) : this.error(Ut(r.localName, this.id, r.module.id), r.start)
		}
		const o = this.exports.get(e)
		if (o) {
			if (o === Bo) return [this.exportShimVariable]
			const e = o.localName,
				s = this.traceVariable(e, { importerForSideEffects: t, searchedNamesAndModules: n })
			return t && (Uo(s, t, this), U(t.sideEffectDependenciesByVariable, s, G).add(this)), [s]
		}
		if (i) return [null]
		if ('default' !== e) {
			const s = this.namespaceReexportsByName.get(e) ?? this.getVariableFromNamespaceReexports(e, t, n)
			if ((this.namespaceReexportsByName.set(e, s), s[0])) return s
		}
		return this.info.syntheticNamedExports
			? [U(this.syntheticExports, e, () => new Eo(this.astContext, e, this.getSyntheticNamespace()))]
			: !s && this.options.shimMissingExports
			? (this.shimMissingExport(e), [this.exportShimVariable])
			: [null]
	}
	hasEffects() {
		return 'no-treeshake' === this.info.moduleSideEffects || this.ast.hasCachedEffects()
	}
	include() {
		const e = ss()
		this.ast.shouldBeIncluded(e) && this.ast.include(e, !1)
	}
	includeAllExports(e) {
		this.isExecuted || (Vo(this), (this.graph.needsTreeshakingPass = !0))
		for (const t of this.exports.keys())
			if (e || t !== this.info.syntheticNamedExports) {
				const e = this.getVariableForExportName(t)[0]
				e.deoptimizePath(Q), e.included || this.includeVariable(e)
			}
		for (const e of this.getReexports()) {
			const [t] = this.getVariableForExportName(e)
			t && (t.deoptimizePath(Q), t.included || this.includeVariable(t), t instanceof fe && (t.module.reexported = !0))
		}
		e && this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces())
	}
	includeAllInBundle() {
		this.ast.include(ss(), !0), this.includeAllExports(!1)
	}
	includeExportsByNames(e) {
		this.isExecuted || (Vo(this), (this.graph.needsTreeshakingPass = !0))
		let t = !1
		for (const s of e) {
			const e = this.getVariableForExportName(s)[0]
			e && (e.deoptimizePath(Q), e.included || this.includeVariable(e)), this.exports.has(s) || this.reexportDescriptions.has(s) || (t = !0)
		}
		t && this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces())
	}
	isIncluded() {
		return this.ast && (this.ast.included || this.namespace.included || this.importedFromNotTreeshaken || this.exportShimVariable.included)
	}
	linkImports() {
		this.addModulesToImportDescriptions(this.importDescriptions), this.addModulesToImportDescriptions(this.reexportDescriptions)
		const e = []
		for (const t of this.exportAllSources) {
			const s = this.graph.modulesById.get(this.resolvedIds[t].id)
			s instanceof Jt ? e.push(s) : this.exportAllModules.push(s)
		}
		this.exportAllModules.push(...e)
	}
	log(e, t, s) {
		this.addLocationToLogProps(t, s), this.options.onLog(e, t)
	}
	render(e) {
		const t = this.magicString.clone()
		this.ast.render(t, e), t.trim()
		const { usesTopLevelAwait: s } = this.astContext
		return s && 'es' !== e.format && 'system' !== e.format
			? Qe(((i = this.id), (n = e.format), { code: 'INVALID_TLA_FORMAT', id: i, message: `Module format "${n}" does not support top-level await. Use the "es" or "system" output formats rather.` }))
			: { source: t, usesTopLevelAwait: s }
		var i, n
	}
	setSource({ ast: e, code: t, customTransformCache: s, originalCode: i, originalSourcemap: n, resolvedIds: r, sourcemapChain: o, transformDependencies: a, transformFiles: l, ...c }) {
		Oo('generate ast', 3),
			(this.info.code = t),
			(this.originalCode = i),
			(this.originalSourcemap = Ao(n)),
			(this.sourcemapChain = o.map((e) => (e.missing ? e : Ao(e)))),
			So(this.originalSourcemap, this.sourcemapChain),
			l && (this.transformFiles = l),
			(this.transformDependencies = a),
			(this.customTransformCache = s),
			this.updateOptions(c)
		const h = e ?? this.tryParse()
		Do('generate ast', 3), Oo('analyze ast', 3), (this.resolvedIds = r ?? Object.create(null))
		const u = this.id
		;(this.magicString = new y(t, { filename: this.excludeFromSourcemap ? null : u, indentExclusionRanges: [] })),
			(this.astContext = {
				addDynamicImport: this.addDynamicImport.bind(this),
				addExport: this.addExport.bind(this),
				addImport: this.addImport.bind(this),
				addImportMeta: this.addImportMeta.bind(this),
				code: t,
				deoptimizationTracker: this.graph.deoptimizationTracker,
				error: this.error.bind(this),
				fileName: u,
				getExports: this.getExports.bind(this),
				getModuleExecIndex: () => this.execIndex,
				getModuleName: this.basename.bind(this),
				getNodeConstructor: (e) => mo[e] || mo.UnknownNode,
				getReexports: this.getReexports.bind(this),
				importDescriptions: this.importDescriptions,
				includeAllExports: () => this.includeAllExports(!0),
				includeDynamicImport: this.includeDynamicImport.bind(this),
				includeVariableInModule: this.includeVariableInModule.bind(this),
				log: this.log.bind(this),
				magicString: this.magicString,
				manualPureFunctions: this.graph.pureFunctions,
				module: this,
				moduleContext: this.context,
				options: this.options,
				requestTreeshakingPass: () => (this.graph.needsTreeshakingPass = !0),
				traceExport: (e) => this.getVariableForExportName(e)[0],
				traceVariable: this.traceVariable.bind(this),
				usesTopLevelAwait: !1
			}),
			(this.scope = new uo(this.graph.scope, this.astContext)),
			(this.namespace = new xo(this.astContext)),
			(this.ast = new oo(h, { context: this.astContext, type: 'Module' }, this.scope)),
			e || !1 !== this.options.cache
				? (this.info.ast = h)
				: Object.defineProperty(this.info, 'ast', {
						get: () => {
							if (this.graph.astLru.has(u)) return this.graph.astLru.get(u)
							{
								const e = this.tryParse()
								return this.graph.astLru.set(u, e), e
							}
						}
				  }),
			Do('analyze ast', 3)
	}
	toJSON() {
		return {
			assertions: this.info.assertions,
			ast: this.info.ast,
			code: this.info.code,
			customTransformCache: this.customTransformCache,
			dependencies: Array.from(this.dependencies, ko),
			id: this.id,
			meta: this.info.meta,
			moduleSideEffects: this.info.moduleSideEffects,
			originalCode: this.originalCode,
			originalSourcemap: this.originalSourcemap,
			resolvedIds: this.resolvedIds,
			sourcemapChain: this.sourcemapChain,
			syntheticNamedExports: this.info.syntheticNamedExports,
			transformDependencies: this.transformDependencies,
			transformFiles: this.transformFiles
		}
	}
	traceVariable(e, { importerForSideEffects: t, isExportAllSearch: s, searchedNamesAndModules: i } = ge) {
		const n = this.scope.variables.get(e)
		if (n) return n
		const r = this.importDescriptions.get(e)
		if (r) {
			const e = r.module
			if (e instanceof jo && '*' === r.name) return e.namespace
			const [n] = zo(e, r.name, t || this, s, i)
			return n || this.error(Ut(r.name, this.id, e.id), r.start)
		}
		return null
	}
	updateOptions({ meta: e, moduleSideEffects: t, syntheticNamedExports: s }) {
		null != t && (this.info.moduleSideEffects = t), null != s && (this.info.syntheticNamedExports = s), null != e && Object.assign(this.info.meta, e)
	}
	addDynamicImport(e) {
		let t = e.source
		t instanceof lo ? 1 === t.quasis.length && t.quasis[0].value.cooked && (t = t.quasis[0].value.cooked) : t instanceof Bn && 'string' == typeof t.value && (t = t.value),
			this.dynamicImports.push({ argument: t, id: null, node: e, resolution: null })
	}
	addExport(e) {
		if (e instanceof rr) this.exports.set('default', { identifier: e.variable.getAssignedVariableName(), localName: 'default' })
		else if (e instanceof ir) {
			const t = e.source.value
			if ((this.addSource(t, e), e.exported)) {
				const s = e.exported.name
				this.reexportDescriptions.set(s, { localName: '*', module: null, source: t, start: e.start })
			} else this.exportAllSources.add(t)
		} else if (e.source instanceof Bn) {
			const t = e.source.value
			this.addSource(t, e)
			for (const { exported: s, local: i, start: n } of e.specifiers) {
				const e = s instanceof Bn ? s.value : s.name
				this.reexportDescriptions.set(e, { localName: i instanceof Bn ? i.value : i.name, module: null, source: t, start: n })
			}
		} else if (e.declaration) {
			const t = e.declaration
			if (t instanceof fo) for (const e of t.declarations) for (const t of ts(e.id)) this.exports.set(t, { identifier: null, localName: t })
			else {
				const e = t.id.name
				this.exports.set(e, { identifier: null, localName: e })
			}
		} else
			for (const { local: t, exported: s } of e.specifiers) {
				const e = t.name,
					i = s instanceof hn ? s.name : s.value
				this.exports.set(i, { identifier: null, localName: e })
			}
	}
	addImport(e) {
		const t = e.source.value
		this.addSource(t, e)
		for (const s of e.specifiers) {
			const e = s instanceof dr ? 'default' : s instanceof qr ? '*' : s.imported instanceof hn ? s.imported.name : s.imported.value
			this.importDescriptions.set(s.local.name, { module: null, name: e, source: t, start: s.start })
		}
	}
	addImportMeta(e) {
		this.importMetas.push(e)
	}
	addLocationToLogProps(e, t) {
		;(e.id = this.id), (e.pos = t)
		let s = this.info.code
		const i = Ce(s, t, { offsetLine: 1 })
		if (i) {
			let { column: n, line: r } = i
			try {
				;({ column: n, line: r } = (function (e, t) {
					const s = e.filter((e) => !e.missing)
					e: for (; s.length > 0; ) {
						const e = s.pop().mappings[t.line - 1]
						if (e) {
							const s = e.filter((e) => e.length > 1),
								i = s[s.length - 1]
							for (const e of s)
								if (e[0] >= t.column || e === i) {
									t = { column: e[3], line: e[2] + 1 }
									continue e
								}
						}
						throw new Error("Can't resolve original location of error.")
					}
					return t
				})(this.sourcemapChain, { column: n, line: r })),
					(s = this.originalCode)
			} catch (e) {
				this.options.onLog(
					Ae,
					(function (e, t, s, i, n) {
						return { cause: e, code: 'SOURCEMAP_ERROR', id: t, loc: { column: s, file: t, line: i }, message: `Error when using sourcemap for reporting an error: ${e.message}`, pos: n }
					})(e, this.id, n, r, t)
				)
			}
			Ze(e, { column: n, line: r }, s, this.id)
		}
	}
	addModulesToImportDescriptions(e) {
		for (const t of e.values()) {
			const { id: e } = this.resolvedIds[t.source]
			t.module = this.graph.modulesById.get(e)
		}
	}
	addRelevantSideEffectDependencies(e, t, s) {
		const i = new Set(),
			n = (r) => {
				for (const o of r) i.has(o) || (i.add(o), t.has(o) ? e.add(o) : (o.info.moduleSideEffects || s.has(o)) && (o instanceof Jt || o.hasEffects() ? e.add(o) : n(o.dependencies)))
			}
		n(this.dependencies), n(s)
	}
	addSource(e, t) {
		const s = ((i = t.assertions), i?.length ? Object.fromEntries(i.map((e) => [Io(e), e.value.value])) : ge)
		var i
		const n = this.sourcesWithAssertions.get(e)
		n ? wo(n, s) && this.log(Ae, Bt(n, s, e, this.id), t.start) : this.sourcesWithAssertions.set(e, s)
	}
	getVariableFromNamespaceReexports(e, t, s) {
		let i = null
		const n = new Map(),
			r = new Set()
		for (const o of this.exportAllModules) {
			if (o.info.syntheticNamedExports === e) continue
			const [a, l] = zo(o, e, t, !0, Go(s))
			o instanceof Jt || l ? r.add(a) : a instanceof Eo ? i || (i = a) : a && n.set(a, o)
		}
		if (n.size > 0) {
			const t = [...n],
				s = t[0][0]
			return 1 === t.length
				? [s]
				: (this.options.onLog(
						Ae,
						((o = e),
						(a = this.id),
						(l = t.map(([, e]) => e.id)),
						{
							binding: o,
							code: 'NAMESPACE_CONFLICT',
							ids: l,
							message: `Conflicting namespaces: "${V(a)}" re-exports "${o}" from one of the modules ${Oe(l.map((e) => V(e)))} (will be ignored).`,
							reexporter: a
						})
				  ),
				  [null])
		}
		var o, a, l
		if (r.size > 0) {
			const t = [...r],
				s = t[0]
			return (
				t.length > 1 &&
					this.options.onLog(
						Ae,
						(function (e, t, s, i) {
							return {
								binding: e,
								code: 'AMBIGUOUS_EXTERNAL_NAMESPACES',
								ids: i,
								message: `Ambiguous external namespace resolution: "${V(t)}" re-exports "${e}" from one of the external modules ${Oe(i.map((e) => V(e)))}, guessing "${V(s)}".`,
								reexporter: t
							}
						})(
							e,
							this.id,
							s.module.id,
							t.map((e) => e.module.id)
						)
					),
				[s, !0]
			)
		}
		return i ? [i] : [null]
	}
	includeAndGetAdditionalMergedNamespaces() {
		const e = new Set(),
			t = new Set()
		for (const s of [this, ...this.exportAllModules])
			if (s instanceof Jt) {
				const [t] = s.getVariableForExportName('*')
				t.include(), this.includedImports.add(t), e.add(t)
			} else if (s.info.syntheticNamedExports) {
				const e = s.getSyntheticNamespace()
				e.include(), this.includedImports.add(e), t.add(e)
			}
		return [...t, ...e]
	}
	includeDynamicImport(e) {
		const t = this.dynamicImports.find((t) => t.node === e).resolution
		if (t instanceof jo) {
			t.includedDynamicImporters.push(this)
			const s = this.options.treeshake ? e.getDeterministicImportedNames() : void 0
			s ? t.includeExportsByNames(s) : t.includeAllExports(!0)
		}
	}
	includeVariable(e) {
		const t = e.module
		if (e.included) t instanceof jo && t !== this && Fo(e, this)
		else if ((e.include(), (this.graph.needsTreeshakingPass = !0), t instanceof jo && (t.isExecuted || Vo(t), t !== this))) {
			const t = Fo(e, this)
			for (const e of t) e.isExecuted || Vo(e)
		}
	}
	includeVariableInModule(e) {
		this.includeVariable(e)
		const t = e.module
		t && t !== this && this.includedImports.add(e)
	}
	shimMissingExport(e) {
		var t, s
		this.options.onLog(Ae, ((t = this.id), { binding: (s = e), code: 'SHIMMED_EXPORT', exporter: t, message: `Missing export "${s}" has been shimmed in module "${V(t)}".` })), this.exports.set(e, Bo)
	}
	tryParse() {
		try {
			return this.graph.contextParse(this.info.code)
		} catch (e) {
			return this.error(
				(function (e, t) {
					let s = e.message.replace(/ \(\d+:\d+\)$/, '')
					return (
						t.endsWith('.json')
							? (s += ' (Note that you need @rollup/plugin-json to import JSON files)')
							: t.endsWith('.js') || (s += ' (Note that you need plugins to import files that are not JavaScript)'),
						{ cause: e, code: 'PARSE_ERROR', id: t, message: s }
					)
				})(e, this.id),
				e.pos
			)
		}
	}
}
function Uo(e, t, s) {
	if (e.module instanceof jo && e.module !== s) {
		const i = e.module.cycles
		if (i.size > 0) {
			const n = s.cycles
			for (const r of n)
				if (i.has(r)) {
					t.alternativeReexportModules.set(e, s)
					break
				}
		}
	}
}
const Go = (e) => e && new Map(Array.from(e, ([e, t]) => [e, new Set(t)]))
function Wo(e) {
	return e.endsWith('.js') ? e.slice(0, -3) : e
}
function qo(e, t) {
	return e.autoId ? `${e.basePath ? e.basePath + '/' : ''}${Wo(t)}` : e.id ?? ''
}
function Ho(e, t, s, i, n, r, o, a = 'return ') {
	const { _: l, getDirectReturnFunction: c, getFunctionIntro: h, getPropertyAccess: u, n: d, s: p } = n
	if (!s)
		return `${d}${d}${a}${(function (e, t, s, i, n) {
			if (e.length > 0) return e[0].local
			for (const { defaultVariableName: e, importPath: r, isChunk: o, name: a, namedExportsMode: l, namespaceVariableName: c, reexports: h } of t)
				if (h) return Ko(a, h[0].imported, l, o, e, c, s, r, i, n)
		})(e, t, i, o, u)};`
	let f = ''
	for (const { defaultVariableName: e, importPath: n, isChunk: a, name: h, namedExportsMode: p, namespaceVariableName: m, reexports: g } of t)
		if (g && s)
			for (const t of g)
				if ('*' !== t.reexported) {
					const s = Ko(h, t.imported, p, a, e, m, i, n, o, u)
					if ((f && (f += d), '*' !== t.imported && t.needsLiveBinding)) {
						const [e, i] = c([], { functionReturn: !0, lineBreakIndent: null, name: null })
						f += `Object.defineProperty(exports,${l}'${t.reexported}',${l}{${d}${r}enumerable:${l}true,${d}${r}get:${l}${e}${s}${i}${d}});`
					} else f += `exports${u(t.reexported)}${l}=${l}${s};`
				}
	for (const { exported: t, local: s } of e) {
		const e = `exports${u(t)}`
		e !== s && (f && (f += d), (f += `${e}${l}=${l}${s};`))
	}
	for (const { name: e, reexports: i } of t)
		if (i && s)
			for (const t of i)
				if ('*' === t.reexported) {
					f && (f += d)
					const s = `{${d}${r}if${l}(k${l}!==${l}'default'${l}&&${l}!Object.prototype.hasOwnProperty.call(exports,${l}k))${l}${Qo(e, t.needsLiveBinding, r, n)}${p}${d}}`
					f += `Object.keys(${e}).forEach(${h(['k'], { isAsync: !1, name: null })}${s});`
				}
	return f ? `${d}${d}${f}` : ''
}
function Ko(e, t, s, i, n, r, o, a, l, c) {
	if ('default' === t) {
		if (!i) {
			const t = o(a),
				s = vr[t] ? n : e
			return Sr(t, l) ? `${s}${c('default')}` : s
		}
		return s ? `${e}${c('default')}` : e
	}
	return '*' === t ? ((i ? !s : Ar[o(a)]) ? r : e) : `${e}${c(t)}`
}
function Yo(e) {
	return e([['value', 'true']], { lineBreakIndent: null })
}
function Xo(e, t, s, { _: i, getObject: n }) {
	if (e) {
		if (t)
			return s
				? `Object.defineProperties(exports,${i}${n(
						[
							['__esModule', Yo(n)],
							[null, `[Symbol.toStringTag]:${i}${zr(n)}`]
						],
						{ lineBreakIndent: null }
				  )});`
				: `Object.defineProperty(exports,${i}'__esModule',${i}${Yo(n)});`
		if (s) return `Object.defineProperty(exports,${i}Symbol.toStringTag,${i}${zr(n)});`
	}
	return ''
}
const Qo = (e, t, s, { _: i, getDirectReturnFunction: n, n: r }) => {
	if (t) {
		const [t, o] = n([], { functionReturn: !0, lineBreakIndent: null, name: null })
		return `Object.defineProperty(exports,${i}k,${i}{${r}${s}${s}enumerable:${i}true,${r}${s}${s}get:${i}${t}${e}[k]${o}${r}${s}})`
	}
	return `exports[k]${i}=${i}${e}[k]`
}
function Zo(e, t, s, i, n, r, o, a) {
	const { _: l, cnst: c, n: h } = a,
		u = new Set(),
		d = [],
		p = (e, t, s) => {
			u.add(t), d.push(`${c} ${e}${l}=${l}/*#__PURE__*/${t}(${s});`)
		}
	for (const { defaultVariableName: s, imports: i, importPath: n, isChunk: r, name: o, namedExportsMode: a, namespaceVariableName: l, reexports: c } of e)
		if (r) {
			for (const { imported: e, reexported: t } of [...(i || []), ...(c || [])])
				if ('*' === e && '*' !== t) {
					a || p(l, xr, o)
					break
				}
		} else {
			const e = t(n)
			let r = !1,
				a = !1
			for (const { imported: t, reexported: n } of [...(i || []), ...(c || [])]) {
				let i, c
				'default' === t ? r || ((r = !0), s !== l && ((c = s), (i = vr[e]))) : '*' !== t || '*' === n || a || ((a = !0), (i = Ar[e]), (c = l)), i && p(c, i, o)
			}
		}
	return `${Ir(u, r, o, a, s, i, n)}${d.length > 0 ? `${d.join(h)}${h}${h}` : ''}`
}
function Jo(e, t) {
	return '.' !== e[0] ? e : t ? ((s = e).endsWith('.js') ? s : s + '.js') : Wo(e)
	var s
}
const ea = new Set([
	...t([
		'assert',
		'async_hooks',
		'buffer',
		'child_process',
		'cluster',
		'console',
		'constants',
		'crypto',
		'dgram',
		'diagnostics_channel',
		'dns',
		'domain',
		'events',
		'fs',
		'http',
		'http2',
		'https',
		'inspector',
		'module',
		'net',
		'os',
		'path',
		'perf_hooks',
		'process',
		'punycode',
		'querystring',
		'readline',
		'repl',
		'stream',
		'string_decoder',
		'timers',
		'tls',
		'trace_events',
		'tty',
		'url',
		'util',
		'v8',
		'vm',
		'wasi',
		'worker_threads',
		'zlib'
	]),
	'assert/strict',
	'dns/promises',
	'fs/promises',
	'path/posix',
	'path/win32',
	'readline/promises',
	'stream/consumers',
	'stream/promises',
	'stream/web',
	'timers/promises',
	'util/types'
])
function ta(e, t) {
	const s = t.map(({ importPath: e }) => e).filter((e) => ea.has(e) || e.startsWith('node:'))
	0 !== s.length &&
		e(
			Ae,
			(function (e) {
				return {
					code: vt,
					ids: e,
					message: `Creating a browser bundle that depends on Node.js built-in modules (${Oe(e)}). You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`
				}
			})(s)
		)
}
const sa = (e, t) => e.split('.').map(t).join('')
function ia(e, t, s, i, { _: n, getPropertyAccess: r }) {
	const o = e.split('.')
	o[0] = ('function' == typeof s ? s(o[0]) : s[o[0]]) || o[0]
	const a = o.pop()
	let l = t,
		c = [...o.map((e) => ((l += r(e)), `${l}${n}=${n}${l}${n}||${n}{}`)), `${l}${r(a)}`].join(`,${n}`) + `${n}=${n}${i}`
	return o.length > 0 && (c = `(${c})`), c
}
function na(e) {
	let t = e.length
	for (; t--; ) {
		const { imports: s, reexports: i } = e[t]
		if (s || i) return e.slice(0, t + 1)
	}
	return []
}
const ra = ({ dependencies: e, exports: t }) => {
		const s = new Set(t.map((e) => e.exported))
		s.add('default')
		for (const { reexports: t } of e) if (t) for (const e of t) '*' !== e.reexported && s.add(e.reexported)
		return s
	},
	oa = (e, t, { _: s, cnst: i, getObject: n, n: r }) =>
		e
			? `${r}${t}${i} _starExcludes${s}=${s}${n(
					[...e].map((e) => [e, '1']),
					{ lineBreakIndent: { base: t, t: t } }
			  )};`
			: '',
	aa = (e, t, { _: s, n: i }) => (e.length > 0 ? `${i}${t}var ${e.join(`,${s}`)};` : ''),
	la = (e, t, s) =>
		ca(
			e.filter((e) => e.hoisted).map((e) => ({ name: e.exported, value: e.local })),
			t,
			s
		)
function ca(e, t, { _: s, n: i }) {
	return 0 === e.length
		? ''
		: 1 === e.length
		? `exports('${e[0].name}',${s}${e[0].value});${i}${i}`
		: `exports({${i}` + e.map(({ name: e, value: i }) => `${t}${e}:${s}${i}`).join(`,${i}`) + `${i}});${i}${i}`
}
const ha = (e, t, s) =>
		ca(
			e.filter((e) => e.expression).map((e) => ({ name: e.exported, value: e.local })),
			t,
			s
		),
	ua = (e, t, s) =>
		ca(
			e.filter((e) => e.local === go).map((e) => ({ name: e.exported, value: go })),
			t,
			s
		)
function da(e, t, s) {
	return e ? `${t}${sa(e, s)}` : 'null'
}
var pa = {
	amd: function (
		e,
		{
			accessedGlobals: t,
			dependencies: s,
			exports: i,
			hasDefaultExport: n,
			hasExports: r,
			id: o,
			indent: a,
			intro: l,
			isEntryFacade: c,
			isModuleFacade: h,
			namedExportsMode: u,
			log: d,
			outro: p,
			snippets: f
		},
		{ amd: m, esModule: g, externalLiveBindings: y, freeze: x, interop: E, namespaceToStringTag: b, strict: v }
	) {
		ta(d, s)
		const S = s.map((e) => `'${Jo(e.importPath, m.forceJsExtensionForImports)}'`),
			A = s.map((e) => e.name),
			{ n: k, getNonArrowFunctionIntro: I, _: w } = f
		u && r && (A.unshift('exports'), S.unshift("'exports'")), t.has('require') && (A.unshift('require'), S.unshift("'require'")), t.has('module') && (A.unshift('module'), S.unshift("'module'"))
		const P = qo(m, o),
			C = (P ? `'${P}',${w}` : '') + (S.length > 0 ? `[${S.join(`,${w}`)}],${w}` : ''),
			$ = v ? `${w}'use strict';` : ''
		e.prepend(`${l}${Zo(s, E, y, x, b, t, a, f)}`)
		const N = Ho(i, s, u, E, f, a, y)
		let _ = Xo(u && r, c && (!0 === g || ('if-default-prop' === g && n)), h && b, f)
		_ && (_ = k + k + _),
			e
				.append(`${N}${_}${p}`)
				.indent(a)
				.prepend(`${m.define}(${C}(${I(A, { isAsync: !1, name: null })}{${$}${k}${k}`)
				.append(`${k}${k}}));`)
	},
	cjs: function (
		e,
		{ accessedGlobals: t, dependencies: s, exports: i, hasDefaultExport: n, hasExports: r, indent: o, intro: a, isEntryFacade: l, isModuleFacade: c, namedExportsMode: h, outro: u, snippets: d },
		{ compact: p, esModule: f, externalLiveBindings: m, freeze: g, interop: y, namespaceToStringTag: x, strict: E }
	) {
		const { _: b, n: v } = d,
			S = E ? `'use strict';${v}${v}` : ''
		let A = Xo(h && r, l && (!0 === f || ('if-default-prop' === f && n)), c && x, d)
		A && (A += v + v)
		const k = (function (e, { _: t, cnst: s, n: i }, n) {
				let r = '',
					o = !1
				for (const { importPath: a, name: l, reexports: c, imports: h } of e)
					c || h ? ((r += n && o ? ',' : `${r ? `;${i}` : ''}${s} `), (o = !0), (r += `${l}${t}=${t}require('${a}')`)) : (r && (r += n && !o ? ',' : `;${i}`), (o = !1), (r += `require('${a}')`))
				if (r) return `${r};${i}${i}`
				return ''
			})(s, d, p),
			I = Zo(s, y, m, g, x, t, o, d)
		e.prepend(`${S}${a}${A}${k}${I}`)
		const w = Ho(i, s, h, y, d, o, m, `module.exports${b}=${b}`)
		e.append(`${w}${u}`)
	},
	es: function (e, { accessedGlobals: t, indent: s, intro: i, outro: n, dependencies: r, exports: o, snippets: a }, { externalLiveBindings: l, freeze: c, namespaceToStringTag: h }) {
		const { n: u } = a,
			d = (function (e, { _: t }) {
				const s = []
				for (const { importPath: i, reexports: n, imports: r, name: o, assertions: a } of e) {
					const e = `'${i}'${a ? `${t}assert${t}${a}` : ''};`
					if (n || r) {
						if (r) {
							let i = null,
								n = null
							const o = []
							for (const e of r) 'default' === e.imported ? (i = e) : '*' === e.imported ? (n = e) : o.push(e)
							n && s.push(`import${t}*${t}as ${n.local} from${t}${e}`),
								i && 0 === o.length
									? s.push(`import ${i.local} from${t}${e}`)
									: o.length > 0 &&
									  s.push(`import ${i ? `${i.local},${t}` : ''}{${t}${o.map((e) => (e.imported === e.local ? e.imported : `${e.imported} as ${e.local}`)).join(`,${t}`)}${t}}${t}from${t}${e}`)
						}
						if (n) {
							let i = null
							const a = [],
								l = []
							for (const e of n) '*' === e.reexported ? (i = e) : '*' === e.imported ? a.push(e) : l.push(e)
							if ((i && s.push(`export${t}*${t}from${t}${e}`), a.length > 0)) {
								;(r && r.some((e) => '*' === e.imported && e.local === o)) || s.push(`import${t}*${t}as ${o} from${t}${e}`)
								for (const e of a) s.push(`export${t}{${t}${o === e.reexported ? o : `${o} as ${e.reexported}`} };`)
							}
							l.length > 0 && s.push(`export${t}{${t}${l.map((e) => (e.imported === e.reexported ? e.imported : `${e.imported} as ${e.reexported}`)).join(`,${t}`)}${t}}${t}from${t}${e}`)
						}
					} else s.push(`import${t}${e}`)
				}
				return s
			})(r, a)
		d.length > 0 && (i += d.join(u) + u + u), (i += Ir(null, t, s, a, l, c, h)) && e.prepend(i)
		const p = (function (e, { _: t, cnst: s }) {
			const i = [],
				n = []
			for (const r of e) r.expression && i.push(`${s} ${r.local}${t}=${t}${r.expression};`), n.push(r.exported === r.local ? r.local : `${r.local} as ${r.exported}`)
			n.length > 0 && i.push(`export${t}{${t}${n.join(`,${t}`)}${t}};`)
			return i
		})(o, a)
		p.length > 0 && e.append(u + u + p.join(u).trim()), n && e.append(n), e.trim()
	},
	iife: function (
		e,
		{ accessedGlobals: t, dependencies: s, exports: i, hasDefaultExport: n, hasExports: r, indent: o, intro: a, namedExportsMode: l, log: c, outro: h, snippets: u },
		{ compact: d, esModule: p, extend: f, freeze: m, externalLiveBindings: g, globals: y, interop: x, name: E, namespaceToStringTag: b, strict: v }
	) {
		const { _: S, getNonArrowFunctionIntro: A, getPropertyAccess: k, n: I } = u,
			w = E && E.includes('.'),
			P = !f && !w
		if (E && P && (ve((C = E)) || be.test(C)))
			return Qe(
				(function (e) {
					return { code: ct, message: `Given name "${e}" is not a legal JS identifier. If you need this, you can try "output.extend: true".`, url: De(Fe) }
				})(E)
			)
		var C
		ta(c, s)
		const $ = na(s),
			N = $.map((e) => e.globalName || 'null'),
			_ = $.map((e) => e.name)
		r && !E && c(Ae, { code: bt, message: 'If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.', url: De(Ke) }),
			l && r && (f ? (N.unshift(`this${sa(E, k)}${S}=${S}this${sa(E, k)}${S}||${S}{}`), _.unshift('exports')) : (N.unshift('{}'), _.unshift('exports')))
		const R = v ? `${o}'use strict';${I}` : '',
			M = Zo(s, x, g, m, b, t, o, u)
		e.prepend(`${a}${M}`)
		let O = `(${A(_, { isAsync: !1, name: null })}{${I}${R}${I}`
		r &&
			(!E || (f && l) || (O = (P ? `var ${E}` : `this${sa(E, k)}`) + `${S}=${S}${O}`),
			w &&
				(O =
					(function (e, t, s, { _: i, getPropertyAccess: n, s: r }, o) {
						const a = e.split('.')
						;(a[0] = ('function' == typeof s ? s(a[0]) : s[a[0]]) || a[0]), a.pop()
						let l = t
						return a.map((e) => ((l += n(e)), `${l}${i}=${i}${l}${i}||${i}{}${r}`)).join(o ? ',' : '\n') + (o && a.length > 0 ? ';' : '\n')
					})(E, 'this', y, u, d) + O))
		let D = `${I}${I}})(${N.join(`,${S}`)});`
		r && !f && l && (D = `${I}${I}${o}return exports;${D}`)
		const L = Ho(i, s, l, x, u, o, g)
		let T = Xo(l && r, !0 === p || ('if-default-prop' === p && n), b, u)
		T && (T = I + I + T), e.append(`${L}${T}${h}`).indent(o).prepend(O).append(D)
	},
	system: function (
		e,
		{ accessedGlobals: t, dependencies: s, exports: i, hasExports: n, indent: r, intro: o, snippets: a, outro: l, usesTopLevelAwait: c },
		{ externalLiveBindings: h, freeze: u, name: d, namespaceToStringTag: p, strict: f, systemNullSetters: m }
	) {
		const { _: g, getFunctionIntro: y, getNonArrowFunctionIntro: x, n: E, s: b } = a,
			{
				importBindings: v,
				setters: S,
				starExcludes: A
			} = (function (e, t, s, { _: i, cnst: n, getObject: r, getPropertyAccess: o, n: a }) {
				const l = [],
					c = []
				let h = null
				for (const { imports: u, reexports: d } of e) {
					const p = []
					if (u) for (const e of u) l.push(e.local), '*' === e.imported ? p.push(`${e.local}${i}=${i}module;`) : p.push(`${e.local}${i}=${i}module${o(e.imported)};`)
					if (d) {
						const a = []
						let l = !1
						for (const { imported: e, reexported: t } of d) '*' === t ? (l = !0) : a.push([t, '*' === e ? 'module' : `module${o(e)}`])
						if (a.length > 1 || l) {
							const o = r(a, { lineBreakIndent: null })
							l
								? (h || (h = ra({ dependencies: e, exports: t })),
								  p.push(`${n} setter${i}=${i}${o};`, `for${i}(${n} name in module)${i}{`, `${s}if${i}(!_starExcludes[name])${i}setter[name]${i}=${i}module[name];`, '}', 'exports(setter);'))
								: p.push(`exports(${o});`)
						} else {
							const [e, t] = a[0]
							p.push(`exports('${e}',${i}${t});`)
						}
					}
					c.push(p.join(`${a}${s}${s}${s}`))
				}
				return { importBindings: l, setters: c, starExcludes: h }
			})(s, i, r, a),
			k = d ? `'${d}',${g}` : '',
			I = t.has('module') ? ['exports', 'module'] : n ? ['exports'] : []
		let w =
			`System.register(${k}[` +
			s.map(({ importPath: e }) => `'${e}'`).join(`,${g}`) +
			`],${g}(${x(I, { isAsync: !1, name: null })}{${E}${r}${f ? "'use strict';" : ''}` +
			oa(A, r, a) +
			aa(v, r, a) +
			`${E}${r}return${g}{${
				S.length > 0
					? `${E}${r}${r}setters:${g}[${S.map((e) =>
							e ? `${y(['module'], { isAsync: !1, name: null })}{${E}${r}${r}${r}${e}${E}${r}${r}}` : m ? 'null' : `${y([], { isAsync: !1, name: null })}{}`
					  ).join(`,${g}`)}],`
					: ''
			}${E}`
		w += `${r}${r}execute:${g}(${x([], { isAsync: c, name: null })}{${E}${E}`
		const P = `${r}${r}})${E}${r}}${b}${E}}));`
		e.prepend(o + Ir(null, t, r, a, h, u, p) + la(i, r, a))
			.append(`${l}${E}${E}` + ha(i, r, a) + ua(i, r, a))
			.indent(`${r}${r}${r}`)
			.append(P)
			.prepend(w)
	},
	umd: function (
		e,
		{ accessedGlobals: t, dependencies: s, exports: i, hasDefaultExport: n, hasExports: r, id: o, indent: a, intro: l, namedExportsMode: c, log: h, outro: u, snippets: d },
		{ amd: p, compact: f, esModule: m, extend: g, externalLiveBindings: y, freeze: x, interop: E, name: b, namespaceToStringTag: v, globals: S, noConflict: A, strict: k }
	) {
		const { _: I, cnst: w, getFunctionIntro: P, getNonArrowFunctionIntro: C, getPropertyAccess: $, n: N, s: _ } = d,
			R = f ? 'f' : 'factory',
			M = f ? 'g' : 'global'
		if (r && !b)
			return Qe({ code: bt, message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.', url: De(Ke) })
		ta(h, s)
		const O = s.map((e) => `'${Jo(e.importPath, p.forceJsExtensionForImports)}'`),
			D = s.map((e) => `require('${e.importPath}')`),
			L = na(s),
			T = L.map((e) => da(e.globalName, M, $)),
			V = L.map((e) => e.name)
		c && (r || A) && (O.unshift("'exports'"), D.unshift('exports'), T.unshift(ia(b, M, S, (g ? `${da(b, M, $)}${I}||${I}` : '') + '{}', d)), V.unshift('exports'))
		const B = qo(p, o),
			z = (B ? `'${B}',${I}` : '') + (O.length > 0 ? `[${O.join(`,${I}`)}],${I}` : ''),
			F = p.define,
			j = !c && r ? `module.exports${I}=${I}` : '',
			U = k ? `${I}'use strict';${N}` : ''
		let G
		if (A) {
			const e = f ? 'e' : 'exports'
			let t
			if (!c && r) t = `${w} ${e}${I}=${I}${ia(b, M, S, `${R}(${T.join(`,${I}`)})`, d)};`
			else {
				t = `${w} ${e}${I}=${I}${T.shift()};${N}${a}${a}${R}(${[e, ...T].join(`,${I}`)});`
			}
			G = `(${P([], { isAsync: !1, name: null })}{${N}${a}${a}${w} current${I}=${I}${(function (e, t, { _: s, getPropertyAccess: i }) {
				let n = t
				return e
					.split('.')
					.map((e) => (n += i(e)))
					.join(`${s}&&${s}`)
			})(b, M, d)};${N}${a}${a}${t}${N}${a}${a}${e}.noConflict${I}=${I}${P([], { isAsync: !1, name: null })}{${I}${da(b, M, $)}${I}=${I}current;${I}return ${e}${_}${I}};${N}${a}})()`
		} else (G = `${R}(${T.join(`,${I}`)})`), !c && r && (G = ia(b, M, S, G, d))
		const W = r || (A && c) || T.length > 0,
			q = [R]
		W && q.unshift(M)
		const H = W ? `this,${I}` : '',
			K = W ? `(${M}${I}=${I}typeof globalThis${I}!==${I}'undefined'${I}?${I}globalThis${I}:${I}${M}${I}||${I}self,${I}` : '',
			Y = W ? ')' : '',
			X = W ? `${a}typeof exports${I}===${I}'object'${I}&&${I}typeof module${I}!==${I}'undefined'${I}?${I}${j}${R}(${D.join(`,${I}`)})${I}:${N}` : '',
			Q =
				`(${C(q, { isAsync: !1, name: null })}{${N}` +
				X +
				`${a}typeof ${F}${I}===${I}'function'${I}&&${I}${F}.amd${I}?${I}${F}(${z}${R})${I}:${N}` +
				`${a}${K}${G}${Y};${N}` +
				`})(${H}(${C(V, { isAsync: !1, name: null })}{${U}${N}`,
			Z = N + N + '}));'
		e.prepend(`${l}${Zo(s, E, y, x, v, t, a, d)}`)
		const J = Ho(i, s, c, E, d, a, y)
		let ee = Xo(c && r, !0 === m || ('if-default-prop' === m && n), v, d)
		ee && (ee = N + N + ee), e.append(`${J}${ee}${u}`).trim().indent(a).append(Z).prepend(Q)
	}
}
const fa = (e, t) => (t ? `${e}\n${t}` : e),
	ma = (e, t) => (t ? `${e}\n\n${t}` : e)
async function ga(e, t, s) {
	try {
		let [i, n, r, o] = await Promise.all([
			t.hookReduceValue('banner', e.banner(s), [s], fa),
			t.hookReduceValue('footer', e.footer(s), [s], fa),
			t.hookReduceValue('intro', e.intro(s), [s], ma),
			t.hookReduceValue('outro', e.outro(s), [s], ma)
		])
		return r && (r += '\n\n'), o && (o = `\n\n${o}`), i && (i += '\n'), n && (n = '\n' + n), { banner: i, footer: n, intro: r, outro: o }
	} catch (e) {
		return Qe(((i = e.message), (n = e.hook), (r = e.plugin), { code: Je, message: `Could not retrieve "${n}". Check configuration of plugin "${r}".\n\tError Message: ${i}` }))
	}
	var i, n, r
}
const ya = { amd: ba, cjs: ba, es: Ea, iife: ba, system: Ea, umd: ba }
function xa(e, t, s, i, n, r, o, a, l, c, h, u, d, p) {
	const f = [...e].reverse()
	for (const e of f) e.scope.addUsedOutsideNames(i, n, u, d)
	!(function (e, t, s) {
		for (const i of t) {
			for (const t of i.scope.variables.values()) t.included && !(t.renderBaseName || (t instanceof ho && t.getOriginalVariable() !== t)) && t.setRenderNames(null, Li(t.name, e, t.forbiddenNames))
			if (s.has(i)) {
				const t = i.namespace
				t.setRenderNames(null, Li(t.name, e, t.forbiddenNames))
			}
		}
	})(i, f, p),
		ya[n](i, s, t, r, o, a, l, c, h)
	for (const e of f) e.scope.deconflict(n, u, d)
}
function Ea(e, t, s, i, n, r, o, a, l) {
	for (const t of s.dependencies) (n || t instanceof j) && (t.variableName = Li(t.suggestedVariableName, e, null))
	for (const s of t) {
		const t = s.module,
			i = s.name
		s.isNamespace && (n || t instanceof Jt)
			? s.setRenderNames(null, (t instanceof Jt ? a.get(t) : o.get(t)).variableName)
			: t instanceof Jt && 'default' === i
			? s.setRenderNames(null, Li([...t.exportedVariables].some(([e, t]) => '*' === t && e.included) ? t.suggestedVariableName + '__default' : t.suggestedVariableName, e, s.forbiddenNames))
			: s.setRenderNames(null, Li(i, e, s.forbiddenNames))
	}
	for (const t of l) t.setRenderNames(null, Li(t.name, e, t.forbiddenNames))
}
function ba(e, t, { deconflictedDefault: s, deconflictedNamespace: i, dependencies: n }, r, o, a, l, c) {
	for (const t of n) t.variableName = Li(t.suggestedVariableName, e, null)
	for (const t of i) t.namespaceVariableName = Li(`${t.suggestedVariableName}__namespace`, e, null)
	for (const t of s) t.defaultVariableName = i.has(t) && kr(r(t.id), a) ? t.namespaceVariableName : Li(`${t.suggestedVariableName}__default`, e, null)
	for (const e of t) {
		const t = e.module
		if (t instanceof Jt) {
			const s = c.get(t),
				i = e.name
			if ('default' === i) {
				const i = r(t.id),
					n = vr[i] ? s.defaultVariableName : s.variableName
				Sr(i, a) ? e.setRenderNames(n, 'default') : e.setRenderNames(null, n)
			} else '*' === i ? e.setRenderNames(null, Ar[r(t.id)] ? s.namespaceVariableName : s.variableName) : e.setRenderNames(s.variableName, null)
		} else {
			const s = l.get(t)
			o && e.isNamespace
				? e.setRenderNames(null, 'default' === s.exportMode ? s.namespaceVariableName : s.variableName)
				: 'default' === s.exportMode
				? e.setRenderNames(null, s.variableName)
				: e.setRenderNames(s.variableName, s.getVariableExportName(e))
		}
	}
}
function va(e, { exports: t, name: s, format: i }, n, r) {
	const o = e.getExportNames()
	if ('default' === t) {
		if (1 !== o.length || 'default' !== o[0]) return Qe(Ft('default', o, n))
	} else if ('none' === t && o.length > 0) return Qe(Ft('none', o, n))
	return (
		'auto' === t &&
			(0 === o.length
				? (t = 'none')
				: 1 === o.length && 'default' === o[0]
				? (t = 'default')
				: ('es' !== i &&
						'system' !== i &&
						o.includes('default') &&
						r(
							Ae,
							(function (e, t) {
								return {
									code: At,
									id: e,
									message: `Entry module "${V(e)}" is using named and default exports together. Consumers of your bundle will have to use \`${
										t || 'chunk'
									}.default\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`,
									url: De(ze)
								}
							})(n, s)
						),
				  (t = 'named'))),
		t
	)
}
function Sa(e) {
	const t = e.split('\n'),
		s = t.filter((e) => /^\t+/.test(e)),
		i = t.filter((e) => /^ {2,}/.test(e))
	if (0 === s.length && 0 === i.length) return null
	if (s.length >= i.length) return '\t'
	const n = i.reduce((e, t) => {
		const s = /^ +/.exec(t)[0].length
		return Math.min(s, e)
	}, 1 / 0)
	return ' '.repeat(n)
}
function Aa(e, t, s, i, n, r) {
	const o = e.getDependenciesToBeIncluded()
	for (const e of o) {
		if (e instanceof Jt) {
			t.push(r.get(e))
			continue
		}
		const o = n.get(e)
		o === i ? s.has(e) || (s.add(e), Aa(e, t, s, i, n, r)) : t.push(o)
	}
}
const ka = '!~{',
	Ia = '}~',
	wa = new RegExp(`${ka}[0-9a-zA-Z_$]{1,59}${Ia}`, 'g'),
	Pa = (e, t) => e.replace(wa, (e) => t.get(e) || e),
	Ca = (e, t, s) => e.replace(wa, (e) => (e === t ? s : e)),
	$a = (e, t) => {
		const s = new Set(),
			i = e.replace(wa, (e) => (t.has(e) ? (s.add(e), `${ka}${'0'.repeat(e.length - 5)}${Ia}`) : e))
		return { containedPlaceholders: s, transformedCode: i }
	},
	Na = Symbol('bundleKeys'),
	_a = { type: 'placeholder' }
function Ra(e, t, s) {
	return B(e)
		? Qe(
				Xt(
					`Invalid pattern "${e}" for "${t}", patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`
				)
		  )
		: e.replace(/\[(\w+)(:\d+)?]/g, (e, i, n) => {
				if (!s.hasOwnProperty(i) || (n && 'hash' !== i)) return Qe(Xt(`"[${i}${n || ''}]" is not a valid placeholder in the "${t}" pattern.`))
				const r = s[i](n && Number.parseInt(n.slice(1)))
				return B(r) ? Qe(Xt(`Invalid substitution "${r}" for placeholder "[${i}]" in "${t}" pattern, can be neither absolute nor relative path.`)) : r
		  })
}
function Ma(e, { [Na]: t }) {
	if (!t.has(e.toLowerCase())) return e
	const s = N(e)
	e = e.slice(0, Math.max(0, e.length - s.length))
	let i,
		n = 1
	for (; t.has((i = e + ++n + s).toLowerCase()); );
	return i
}
const Oa = new Set(['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts', '.cjs', '.cts'])
function Da(e, t, s, i) {
	const n = 'function' == typeof t ? t(e.id) : t[e.id]
	return (
		n ||
		(s
			? (i(Ae, ((r = e.id), (o = e.variableName), { code: xt, id: r, message: `No name was provided for external module "${r}" in "output.globals" – guessing "${o}".`, names: [o], url: De(Ge) })),
			  e.variableName)
			: void 0)
	)
	var r, o
}
class La {
	constructor(e, t, s, i, n, r, o, a, l, c, h, u, d, p, f) {
		;(this.orderedModules = e),
			(this.inputOptions = t),
			(this.outputOptions = s),
			(this.unsetOptions = i),
			(this.pluginDriver = n),
			(this.modulesById = r),
			(this.chunkByModule = o),
			(this.externalChunkByModule = a),
			(this.facadeChunkByModule = l),
			(this.includedNamespaces = c),
			(this.manualChunkAlias = h),
			(this.getPlaceholder = u),
			(this.bundle = d),
			(this.inputBase = p),
			(this.snippets = f),
			(this.entryModules = []),
			(this.exportMode = 'named'),
			(this.facadeModule = null),
			(this.namespaceVariableName = ''),
			(this.variableName = ''),
			(this.accessedGlobalsByScope = new Map()),
			(this.dependencies = new Set()),
			(this.dynamicEntryModules = []),
			(this.dynamicName = null),
			(this.exportNamesByVariable = new Map()),
			(this.exports = new Set()),
			(this.exportsByName = new Map()),
			(this.fileName = null),
			(this.implicitEntryModules = []),
			(this.implicitlyLoadedBefore = new Set()),
			(this.imports = new Set()),
			(this.includedDynamicImports = null),
			(this.includedReexportsByModule = new Map()),
			(this.isEmpty = !0),
			(this.name = null),
			(this.needsExportsShim = !1),
			(this.preRenderedChunkInfo = null),
			(this.preliminaryFileName = null),
			(this.preliminarySourcemapFileName = null),
			(this.renderedChunkInfo = null),
			(this.renderedDependencies = null),
			(this.renderedModules = Object.create(null)),
			(this.sortedExportNames = null),
			(this.strictFacade = !1),
			(this.execIndex = e.length > 0 ? e[0].execIndex : 1 / 0)
		const m = new Set(e)
		for (const t of e) {
			o.set(t, this), t.namespace.included && !s.preserveModules && c.add(t), this.isEmpty && t.isIncluded() && (this.isEmpty = !1), (t.info.isEntry || s.preserveModules) && this.entryModules.push(t)
			for (const e of t.includedDynamicImporters) m.has(e) || (this.dynamicEntryModules.push(t), t.info.syntheticNamedExports && (c.add(t), this.exports.add(t.namespace)))
			t.implicitlyLoadedAfter.size > 0 && this.implicitEntryModules.push(t)
		}
		this.suggestedVariableName = Se(this.generateVariableName())
	}
	static generateFacade(e, t, s, i, n, r, o, a, l, c, h, u, d, p, f) {
		const m = new La([], e, t, s, i, n, r, o, a, l, null, u, d, p, f)
		m.assignFacadeName(h, c), a.has(c) || a.set(c, m)
		for (const e of c.getDependenciesToBeIncluded()) m.dependencies.add(e instanceof jo ? r.get(e) : o.get(e))
		return (
			!m.dependencies.has(r.get(c)) && c.info.moduleSideEffects && c.hasEffects() && m.dependencies.add(r.get(c)),
			m.ensureReexportsAreAvailableForModule(c),
			(m.facadeModule = c),
			(m.strictFacade = !0),
			m
		)
	}
	canModuleBeFacade(e, t) {
		const s = e.getExportNamesByVariable()
		for (const e of this.exports) if (!s.has(e)) return !1
		for (const i of t) if (!(i.module === e || s.has(i) || (i instanceof Eo && s.has(i.getBaseVariable())))) return !1
		return !0
	}
	finalizeChunk(e, t, s, i) {
		const n = this.getRenderedChunkInfo(),
			r = (e) => Pa(e, i),
			o = n.fileName,
			a = (this.fileName = r(o))
		return {
			...n,
			code: e,
			dynamicImports: n.dynamicImports.map(r),
			fileName: a,
			implicitlyLoadedBefore: n.implicitlyLoadedBefore.map(r),
			importedBindings: Object.fromEntries(Object.entries(n.importedBindings).map(([e, t]) => [r(e), t])),
			imports: n.imports.map(r),
			map: t,
			preliminaryFileName: o,
			referencedFiles: n.referencedFiles.map(r),
			sourcemapFileName: s
		}
	}
	generateExports() {
		this.sortedExportNames = null
		const e = new Set(this.exports)
		if (null !== this.facadeModule && (!1 !== this.facadeModule.preserveSignature || this.strictFacade)) {
			const t = this.facadeModule.getExportNamesByVariable()
			for (const [s, i] of t) {
				this.exportNamesByVariable.set(s, [...i])
				for (const e of i) this.exportsByName.set(e, s)
				e.delete(s)
			}
		}
		this.outputOptions.minifyInternalExports
			? (function (e, t, s) {
					let i = 0
					for (const n of e) {
						let [e] = n.name
						if (t.has(e))
							do {
								;(e = Di(++i)), 49 === e.charCodeAt(0) && ((i += 9 * 64 ** (e.length - 1)), (e = Di(i)))
							} while (Ee.has(e) || t.has(e))
						t.set(e, n), s.set(n, [e])
					}
			  })(e, this.exportsByName, this.exportNamesByVariable)
			: (function (e, t, s) {
					for (const i of e) {
						let e = 0,
							n = i.name
						for (; t.has(n); ) n = i.name + '$' + ++e
						t.set(n, i), s.set(i, [n])
					}
			  })(e, this.exportsByName, this.exportNamesByVariable),
			(this.outputOptions.preserveModules || (this.facadeModule && this.facadeModule.info.isEntry)) && (this.exportMode = va(this, this.outputOptions, this.facadeModule.id, this.inputOptions.onLog))
	}
	generateFacades() {
		const e = [],
			t = new Set([...this.entryModules, ...this.implicitEntryModules]),
			s = new Set(this.dynamicEntryModules.map(({ namespace: e }) => e))
		for (const e of t) if (e.preserveSignature) for (const t of e.getExportNamesByVariable().keys()) this.chunkByModule.get(t.module) === this && s.add(t)
		for (const i of t) {
			const t = Array.from(new Set(i.chunkNames.filter(({ isUserDefined: e }) => e).map(({ name: e }) => e)), (e) => ({ name: e }))
			if ((0 === t.length && i.isUserDefinedEntryPoint && t.push({}), t.push(...Array.from(i.chunkFileNames, (e) => ({ fileName: e }))), 0 === t.length && t.push({}), !this.facadeModule)) {
				const e = !this.outputOptions.preserveModules && ('strict' === i.preserveSignature || ('exports-only' === i.preserveSignature && i.getExportNamesByVariable().size > 0))
				;(e && !this.canModuleBeFacade(i, s)) ||
					((this.facadeModule = i), this.facadeChunkByModule.set(i, this), i.preserveSignature && (this.strictFacade = e), this.assignFacadeName(t.shift(), i, this.outputOptions.preserveModules))
			}
			for (const s of t)
				e.push(
					La.generateFacade(
						this.inputOptions,
						this.outputOptions,
						this.unsetOptions,
						this.pluginDriver,
						this.modulesById,
						this.chunkByModule,
						this.externalChunkByModule,
						this.facadeChunkByModule,
						this.includedNamespaces,
						i,
						s,
						this.getPlaceholder,
						this.bundle,
						this.inputBase,
						this.snippets
					)
				)
		}
		for (const e of this.dynamicEntryModules)
			e.info.syntheticNamedExports ||
				(!this.facadeModule && this.canModuleBeFacade(e, s)
					? ((this.facadeModule = e), this.facadeChunkByModule.set(e, this), (this.strictFacade = !0), (this.dynamicName = Ta(e)))
					: this.facadeModule === e && !this.strictFacade && this.canModuleBeFacade(e, s)
					? (this.strictFacade = !0)
					: this.facadeChunkByModule.get(e)?.strictFacade || (this.includedNamespaces.add(e), this.exports.add(e.namespace)))
		return this.outputOptions.preserveModules || this.addNecessaryImportsForFacades(), e
	}
	getChunkName() {
		return this.name ?? (this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName()))
	}
	getExportNames() {
		return this.sortedExportNames ?? (this.sortedExportNames = [...this.exportsByName.keys()].sort())
	}
	getFileName() {
		return this.fileName || this.getPreliminaryFileName().fileName
	}
	getImportPath(e) {
		return L(F(e, this.getFileName(), 'amd' === this.outputOptions.format && !this.outputOptions.amd.forceJsExtensionForImports, !0))
	}
	getPreliminaryFileName() {
		if (this.preliminaryFileName) return this.preliminaryFileName
		let e,
			t = null
		const { chunkFileNames: s, entryFileNames: i, file: n, format: r, preserveModules: o } = this.outputOptions
		if (n) e = C(n)
		else if (null === this.fileName) {
			const [n, a] = o || this.facadeModule?.isUserDefinedEntryPoint ? [i, 'output.entryFileNames'] : [s, 'output.chunkFileNames']
			;(e = Ra('function' == typeof n ? n(this.getPreRenderedChunkInfo()) : n, a, { format: () => r, hash: (e) => t || (t = this.getPlaceholder(a, e)), name: () => this.getChunkName() })),
				t || (e = Ma(e, this.bundle))
		} else e = this.fileName
		return t || (this.bundle[e] = _a), (this.preliminaryFileName = { fileName: e, hashPlaceholder: t })
	}
	getPreliminarySourcemapFileName() {
		if (this.preliminarySourcemapFileName) return this.preliminarySourcemapFileName
		let e = null,
			t = null
		const { sourcemapFileNames: s, format: i } = this.outputOptions
		if (!s) return null
		{
			const [n, r] = [s, 'output.sourcemapFileNames']
			;(e = Ra('function' == typeof n ? n(this.getPreRenderedChunkInfo()) : n, r, {
				chunkhash: () => this.getPreliminaryFileName().hashPlaceholder || '',
				format: () => i,
				hash: (e) => t || (t = this.getPlaceholder(r, e)),
				name: () => this.getChunkName()
			})),
				t || (e = Ma(e, this.bundle))
		}
		return (this.preliminarySourcemapFileName = { fileName: e, hashPlaceholder: t })
	}
	getRenderedChunkInfo() {
		return this.renderedChunkInfo
			? this.renderedChunkInfo
			: (this.renderedChunkInfo = {
					...this.getPreRenderedChunkInfo(),
					dynamicImports: this.getDynamicDependencies().map(Fa),
					fileName: this.getFileName(),
					implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, Fa),
					importedBindings: Ba(this.getRenderedDependencies(), Fa),
					imports: Array.from(this.dependencies, Fa),
					modules: this.renderedModules,
					referencedFiles: this.getReferencedFiles()
			  })
	}
	getVariableExportName(e) {
		return this.outputOptions.preserveModules && e instanceof xo ? '*' : this.exportNamesByVariable.get(e)[0]
	}
	link() {
		this.dependencies = (function (e, t, s, i) {
			const n = [],
				r = new Set()
			for (let o = t.length - 1; o >= 0; o--) {
				const a = t[o]
				if (!r.has(a)) {
					const t = []
					Aa(a, t, r, e, s, i), n.unshift(t)
				}
			}
			const o = new Set()
			for (const e of n) for (const t of e) o.add(t)
			return o
		})(this, this.orderedModules, this.chunkByModule, this.externalChunkByModule)
		for (const e of this.orderedModules) this.addImplicitlyLoadedBeforeFromModule(e), this.setUpChunkImportsAndExportsForModule(e)
	}
	async render() {
		const {
				dependencies: e,
				exportMode: t,
				facadeModule: s,
				inputOptions: { onLog: i },
				outputOptions: n,
				pluginDriver: r,
				snippets: o
			} = this,
			{ format: a, hoistTransitiveImports: l, preserveModules: c } = n
		if (l && !c && null !== s) for (const t of e) t instanceof La && this.inlineChunkDependencies(t)
		const h = this.getPreliminaryFileName(),
			u = this.getPreliminarySourcemapFileName(),
			{ accessedGlobals: d, indent: p, magicString: f, renderedSource: m, usedModules: g, usesTopLevelAwait: y } = this.renderModules(h.fileName),
			x = [...this.getRenderedDependencies().values()],
			E = 'none' === t ? [] : this.getChunkExportDeclarations(a)
		let b = E.length > 0,
			v = !1
		for (const e of x) {
			const { reexports: t } = e
			t?.length && ((b = !0), !v && t.some((e) => 'default' === e.reexported) && (v = !0), 'es' === a && (e.reexports = t.filter(({ reexported: e }) => !E.find(({ exported: t }) => t === e))))
		}
		if (!v)
			for (const { exported: e } of E)
				if ('default' === e) {
					v = !0
					break
				}
		const { intro: S, outro: A, banner: k, footer: I } = await ga(n, r, this.getRenderedChunkInfo())
		return (
			pa[a](
				m,
				{
					accessedGlobals: d,
					dependencies: x,
					exports: E,
					hasDefaultExport: v,
					hasExports: b,
					id: h.fileName,
					indent: p,
					intro: S,
					isEntryFacade: c || (null !== s && s.info.isEntry),
					isModuleFacade: null !== s,
					log: i,
					namedExportsMode: 'default' !== t,
					outro: A,
					snippets: o,
					usesTopLevelAwait: y
				},
				n
			),
			k && f.prepend(k),
			I && f.append(I),
			{ chunk: this, magicString: f, preliminaryFileName: h, preliminarySourcemapFileName: u, usedModules: g }
		)
	}
	addImplicitlyLoadedBeforeFromModule(e) {
		const { chunkByModule: t, implicitlyLoadedBefore: s } = this
		for (const i of e.implicitlyLoadedBefore) {
			const e = t.get(i)
			e && e !== this && s.add(e)
		}
	}
	addNecessaryImportsForFacades() {
		for (const [e, t] of this.includedReexportsByModule) if (this.includedNamespaces.has(e)) for (const e of t) this.imports.add(e)
	}
	assignFacadeName({ fileName: e, name: t }, s, i) {
		e ? (this.fileName = e) : (this.name = this.outputOptions.sanitizeFileName(t || (i ? this.getPreserveModulesChunkNameFromModule(s) : Ta(s))))
	}
	checkCircularDependencyImport(e, t) {
		const s = e.module
		if (s instanceof jo) {
			const l = this.chunkByModule.get(s)
			let c
			do {
				if (((c = t.alternativeReexportModules.get(e)), c)) {
					this.chunkByModule.get(c) !== l &&
						this.inputOptions.onLog(
							Ae,
							((i = s.getExportNamesByVariable().get(e)?.[0] || '*'),
							(n = s.id),
							(r = c.id),
							(o = t.id),
							(a = this.outputOptions.preserveModules),
							{
								code: 'CYCLIC_CROSS_CHUNK_REEXPORT',
								exporter: n,
								id: o,
								message: `Export "${i}" of module "${V(n)}" was reexported through module "${V(
									r
								)}" while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.\nEither change the import in "${V(
									o
								)}" to point directly to the exporting module or ${a ? 'do not use "output.preserveModules"' : 'reconfigure "output.manualChunks"'} to ensure these modules end up in the same chunk.`,
								reexporter: r
							})
						),
						(t = c)
				}
			} while (c)
		}
		var i, n, r, o, a
	}
	ensureReexportsAreAvailableForModule(e) {
		const t = [],
			s = e.getExportNamesByVariable()
		for (const i of s.keys()) {
			const s = i instanceof Eo,
				n = s ? i.getBaseVariable() : i
			if ((this.checkCircularDependencyImport(n, e), !(n instanceof xo && this.outputOptions.preserveModules))) {
				const e = n.module
				if (e instanceof jo) {
					const i = this.chunkByModule.get(e)
					i && i !== this && (i.exports.add(n), t.push(n), s && this.imports.add(n))
				}
			}
		}
		t.length > 0 && this.includedReexportsByModule.set(e, t)
	}
	generateVariableName() {
		if (this.manualChunkAlias) return this.manualChunkAlias
		const e = this.entryModules[0] || this.implicitEntryModules[0] || this.dynamicEntryModules[0] || this.orderedModules[this.orderedModules.length - 1]
		return e ? Ta(e) : 'chunk'
	}
	getChunkExportDeclarations(e) {
		const t = []
		for (const s of this.getExportNames()) {
			if ('*' === s[0]) continue
			const i = this.exportsByName.get(s)
			if (!(i instanceof Eo)) {
				const t = i.module
				if (t) {
					const i = this.chunkByModule.get(t)
					if (i !== this) {
						if (!i || 'es' !== e) continue
						const t = this.renderedDependencies.get(i)
						if (!t) continue
						const { imports: n, reexports: r } = t,
							o = r?.find(({ reexported: e }) => e === s),
							a = n?.find(({ imported: e }) => e === o?.imported)
						if (!a) continue
					}
				}
			}
			let n = null,
				r = !1,
				o = i.getName(this.snippets.getPropertyAccess)
			if (i instanceof Pi) {
				for (const e of i.declarations)
					if (e.parent instanceof nr || (e instanceof rr && e.declaration instanceof nr)) {
						r = !0
						break
					}
			} else i instanceof Eo && ((n = o), 'es' === e && (o = i.renderName))
			t.push({ exported: s, expression: n, hoisted: r, local: o })
		}
		return t
	}
	getDependenciesToBeDeconflicted(e, t, s) {
		const i = new Set(),
			n = new Set(),
			r = new Set()
		for (const t of [...this.exportNamesByVariable.keys(), ...this.imports])
			if (e || t.isNamespace) {
				const o = t.module
				if (o instanceof Jt) {
					const a = this.externalChunkByModule.get(o)
					i.add(a), e && ('default' === t.name ? vr[s(o.id)] && n.add(a) : '*' === t.name && Ar[s(o.id)] && r.add(a))
				} else {
					const s = this.chunkByModule.get(o)
					s !== this && (i.add(s), e && 'default' === s.exportMode && t.isNamespace && r.add(s))
				}
			}
		if (t) for (const e of this.dependencies) i.add(e)
		return { deconflictedDefault: n, deconflictedNamespace: r, dependencies: i }
	}
	getDynamicDependencies() {
		return this.getIncludedDynamicImports()
			.map((e) => e.facadeChunk || e.chunk || e.externalChunk || e.resolution)
			.filter((e) => e !== this && (e instanceof La || e instanceof j))
	}
	getDynamicImportStringAndAssertions(e, t) {
		if (e instanceof Jt) {
			const s = this.externalChunkByModule.get(e)
			return [`'${s.getImportPath(t)}'`, s.getImportAssertions(this.snippets)]
		}
		return [e || '', ('es' === this.outputOptions.format && this.outputOptions.externalImportAssertions) || null]
	}
	getFallbackChunkName() {
		return this.manualChunkAlias ? this.manualChunkAlias : this.dynamicName ? this.dynamicName : this.fileName ? T(this.fileName) : T(this.orderedModules[this.orderedModules.length - 1].id)
	}
	getImportSpecifiers() {
		const { interop: e } = this.outputOptions,
			t = new Map()
		for (const s of this.imports) {
			const i = s.module
			let n, r
			if (i instanceof Jt) {
				if (((n = this.externalChunkByModule.get(i)), (r = s.name), 'default' !== r && '*' !== r && 'defaultOnly' === e(i.id))) return Qe(Kt(i.id, r, !1))
			} else (n = this.chunkByModule.get(i)), (r = n.getVariableExportName(s))
			U(t, n, W).push({ imported: r, local: s.getName(this.snippets.getPropertyAccess) })
		}
		return t
	}
	getIncludedDynamicImports() {
		if (this.includedDynamicImports) return this.includedDynamicImports
		const e = []
		for (const t of this.orderedModules)
			for (const { node: s, resolution: i } of t.dynamicImports)
				s.included &&
					e.push(
						i instanceof jo
							? { chunk: this.chunkByModule.get(i), externalChunk: null, facadeChunk: this.facadeChunkByModule.get(i), node: s, resolution: i }
							: i instanceof Jt
							? { chunk: null, externalChunk: this.externalChunkByModule.get(i), facadeChunk: null, node: s, resolution: i }
							: { chunk: null, externalChunk: null, facadeChunk: null, node: s, resolution: i }
					)
		return (this.includedDynamicImports = e)
	}
	getPreRenderedChunkInfo() {
		if (this.preRenderedChunkInfo) return this.preRenderedChunkInfo
		const { dynamicEntryModules: e, facadeModule: t, implicitEntryModules: s, orderedModules: i } = this
		return (this.preRenderedChunkInfo = {
			exports: this.getExportNames(),
			facadeModuleId: t && t.id,
			isDynamicEntry: e.length > 0,
			isEntry: !!t?.info.isEntry,
			isImplicitEntry: s.length > 0,
			moduleIds: i.map(({ id: e }) => e),
			name: this.getChunkName(),
			type: 'chunk'
		})
	}
	getPreserveModulesChunkNameFromModule(e) {
		const t = Va(e)
		if (t) return t
		const { preserveModulesRoot: s, sanitizeFileName: i } = this.outputOptions,
			n = i(P(e.id.split(za, 1)[0])),
			r = N(n),
			o = Oa.has(r) ? n.slice(0, -r.length) : n
		return I(o) ? (s && R(o).startsWith(s) ? o.slice(s.length).replace(/^[/\\]/, '') : _(this.inputBase, o)) : `_virtual/${C(o)}`
	}
	getReexportSpecifiers() {
		const { externalLiveBindings: e, interop: t } = this.outputOptions,
			s = new Map()
		for (let i of this.getExportNames()) {
			let n,
				r,
				o = !1
			if ('*' === i[0]) {
				const s = i.slice(1)
				'defaultOnly' === t(s) && this.inputOptions.onLog(Ae, Yt(s)), (o = e), (n = this.externalChunkByModule.get(this.modulesById.get(s))), (r = i = '*')
			} else {
				const s = this.exportsByName.get(i)
				if (s instanceof Eo) continue
				const a = s.module
				if (a instanceof jo) {
					if (((n = this.chunkByModule.get(a)), n === this)) continue
					;(r = n.getVariableExportName(s)), (o = s.isReassigned)
				} else {
					if (((n = this.externalChunkByModule.get(a)), (r = s.name), 'default' !== r && '*' !== r && 'defaultOnly' === t(a.id))) return Qe(Kt(a.id, r, !0))
					o = e && ('default' !== r || Sr(t(a.id), !0))
				}
			}
			U(s, n, W).push({ imported: r, needsLiveBinding: o, reexported: i })
		}
		return s
	}
	getReferencedFiles() {
		const e = new Set()
		for (const t of this.orderedModules)
			for (const s of t.importMetas) {
				const t = s.getReferencedFileName(this.pluginDriver)
				t && e.add(t)
			}
		return [...e]
	}
	getRenderedDependencies() {
		if (this.renderedDependencies) return this.renderedDependencies
		const e = this.getImportSpecifiers(),
			t = this.getReexportSpecifiers(),
			s = new Map(),
			i = this.getFileName()
		for (const n of this.dependencies) {
			const r = e.get(n) || null,
				o = t.get(n) || null,
				a = n instanceof j || 'default' !== n.exportMode,
				l = n.getImportPath(i)
			s.set(n, {
				assertions: n instanceof j ? n.getImportAssertions(this.snippets) : null,
				defaultVariableName: n.defaultVariableName,
				globalName: n instanceof j && ('umd' === this.outputOptions.format || 'iife' === this.outputOptions.format) && Da(n, this.outputOptions.globals, null !== (r || o), this.inputOptions.onLog),
				importPath: l,
				imports: r,
				isChunk: n instanceof La,
				name: n.variableName,
				namedExportsMode: a,
				namespaceVariableName: n.namespaceVariableName,
				reexports: o
			})
		}
		return (this.renderedDependencies = s)
	}
	inlineChunkDependencies(e) {
		for (const t of e.dependencies) this.dependencies.has(t) || (this.dependencies.add(t), t instanceof La && this.inlineChunkDependencies(t))
	}
	renderModules(e) {
		const {
				accessedGlobalsByScope: t,
				dependencies: s,
				exportNamesByVariable: i,
				includedNamespaces: n,
				inputOptions: { onLog: r },
				isEmpty: o,
				orderedModules: a,
				outputOptions: l,
				pluginDriver: c,
				renderedModules: h,
				snippets: u
			} = this,
			{ compact: d, dynamicImportFunction: p, format: f, freeze: m, namespaceToStringTag: g } = l,
			{ _: x, cnst: b, n: v } = u
		this.setDynamicImportResolutions(e), this.setImportMetaResolutions(e), this.setIdentifierRenderResolutions()
		const S = new E({ separator: `${v}${v}` }),
			A = (function (e, t) {
				if (!0 !== t.indent) return t.indent
				for (const t of e) {
					const e = Sa(t.originalCode)
					if (null !== e) return e
				}
				return '\t'
			})(a, l),
			k = []
		let I = ''
		const w = new Set(),
			P = new Map(),
			C = {
				accessedDocumentCurrentScript: !1,
				dynamicImportFunction: p,
				exportNamesByVariable: i,
				format: f,
				freeze: m,
				indent: A,
				namespaceToStringTag: g,
				pluginDriver: c,
				snippets: u,
				useOriginalName: null
			}
		let $ = !1
		for (const e of a) {
			let s,
				i = 0
			if (e.isIncluded() || n.has(e)) {
				const r = e.render(C)
				!C.accessedDocumentCurrentScript && Yr.includes(f) && this.accessedGlobalsByScope.get(e.scope)?.delete(br),
					(C.accessedDocumentCurrentScript = !1),
					({ source: s } = r),
					$ || ($ = r.usesTopLevelAwait),
					(i = s.length()),
					i && (d && s.lastLine().includes('//') && s.append('\n'), P.set(e, s), S.addSource(s), k.push(e))
				const o = e.namespace
				if (n.has(e)) {
					const e = o.renderBlock(C)
					o.renderFirst() ? (I += v + e) : S.addSource(new y(e))
				}
				const a = t.get(e.scope)
				if (a) for (const e of a) w.add(e)
			}
			const { renderedExports: r, removedExports: o } = e.getRenderedExports()
			h[e.id] = {
				get code() {
					return s?.toString() ?? null
				},
				originalLength: e.originalCode.length,
				removedExports: o,
				renderedExports: r,
				renderedLength: i
			}
		}
		I && S.prepend(I + v + v), this.needsExportsShim && S.prepend(`${v}${b} ${go}${x}=${x}void 0;${v}${v}`)
		const N = d ? S : S.trim()
		var _
		return (
			o && 0 === this.getExportNames().length && 0 === s.size && r(Ae, { code: 'EMPTY_BUNDLE', message: `Generated an empty chunk: "${(_ = this.getChunkName())}".`, names: [_] }),
			{ accessedGlobals: w, indent: A, magicString: S, renderedSource: N, usedModules: k, usesTopLevelAwait: $ }
		)
	}
	setDynamicImportResolutions(e) {
		const { accessedGlobalsByScope: t, outputOptions: s, pluginDriver: i, snippets: n } = this
		for (const r of this.getIncludedDynamicImports())
			if (r.chunk) {
				const { chunk: o, facadeChunk: a, node: l, resolution: c } = r
				o === this
					? l.setInternalResolution(c.namespace)
					: l.setExternalResolution((a || o).exportMode, c, s, n, i, t, `'${(a || o).getImportPath(e)}'`, !a?.strictFacade && o.exportNamesByVariable.get(c.namespace)[0], null)
			} else {
				const { node: o, resolution: a } = r,
					[l, c] = this.getDynamicImportStringAndAssertions(a, e)
				o.setExternalResolution('external', a, s, n, i, t, l, !1, c)
			}
	}
	setIdentifierRenderResolutions() {
		const { format: e, interop: t, namespaceToStringTag: s, preserveModules: i, externalLiveBindings: n } = this.outputOptions,
			r = new Set()
		for (const t of this.getExportNames()) {
			const s = this.exportsByName.get(t)
			'es' !== e && 'system' !== e && s.isReassigned && !s.isId ? s.setRenderNames('exports', t) : s instanceof Eo ? r.add(s) : s.setRenderNames(null, null)
		}
		for (const e of this.orderedModules)
			if (e.needsExportShim) {
				this.needsExportsShim = !0
				break
			}
		const o = new Set(['Object', 'Promise'])
		switch ((this.needsExportsShim && o.add(go), s && o.add('Symbol'), e)) {
			case 'system':
				o.add('module').add('exports')
				break
			case 'es':
				break
			case 'cjs':
				o.add('module').add('require').add('__filename').add('__dirname')
			default:
				o.add('exports')
				for (const e of Br) o.add(e)
		}
		xa(
			this.orderedModules,
			this.getDependenciesToBeDeconflicted('es' !== e && 'system' !== e, 'amd' === e || 'umd' === e || 'iife' === e, t),
			this.imports,
			o,
			e,
			t,
			i,
			n,
			this.chunkByModule,
			this.externalChunkByModule,
			r,
			this.exportNamesByVariable,
			this.accessedGlobalsByScope,
			this.includedNamespaces
		)
	}
	setImportMetaResolutions(e) {
		const {
			accessedGlobalsByScope: t,
			includedNamespaces: s,
			orderedModules: i,
			outputOptions: { format: n }
		} = this
		for (const r of i) {
			for (const s of r.importMetas) s.setResolution(n, t, e)
			s.has(r) && r.namespace.prepare(t)
		}
	}
	setUpChunkImportsAndExportsForModule(e) {
		const t = new Set(e.includedImports)
		if (!this.outputOptions.preserveModules && this.includedNamespaces.has(e)) {
			const s = e.namespace.getMemberVariables()
			for (const e of Object.values(s)) e.included && t.add(e)
		}
		for (let s of t) {
			s instanceof ho && (s = s.getOriginalVariable()), s instanceof Eo && (s = s.getBaseVariable())
			const t = this.chunkByModule.get(s.module)
			t !== this && (this.imports.add(s), s.module instanceof jo && (this.checkCircularDependencyImport(s, e), (s instanceof xo && this.outputOptions.preserveModules) || t.exports.add(s)))
		}
		;(this.includedNamespaces.has(e) || (e.info.isEntry && !1 !== e.preserveSignature) || e.includedDynamicImporters.some((e) => this.chunkByModule.get(e) !== this)) &&
			this.ensureReexportsAreAvailableForModule(e)
		for (const { node: t, resolution: s } of e.dynamicImports)
			t.included && s instanceof jo && this.chunkByModule.get(s) === this && !this.includedNamespaces.has(s) && (this.includedNamespaces.add(s), this.ensureReexportsAreAvailableForModule(s))
	}
}
function Ta(e) {
	return Va(e) ?? T(e.id)
}
function Va(e) {
	return e.chunkNames.find(({ isUserDefined: e }) => e)?.name ?? e.chunkNames[0]?.name
}
function Ba(e, t) {
	const s = {}
	for (const [i, n] of e) {
		const e = new Set()
		if (n.imports) for (const { imported: t } of n.imports) e.add(t)
		if (n.reexports) for (const { imported: t } of n.reexports) e.add(t)
		s[t(i)] = [...e]
	}
	return s
}
const za = /[#?]/,
	Fa = (e) => e.getFileName()
function* ja(e) {
	for (const t of e) yield* t
}
function Ua(e, t, s, i) {
	const { chunkDefinitions: n, modulesInManualChunks: r } = (function (e) {
			const t = [],
				s = new Set(e.keys()),
				i = Object.create(null)
			for (const [t, n] of e) Ga(t, i[n] || (i[n] = []), s)
			for (const [e, s] of Object.entries(i)) t.push({ alias: e, modules: s })
			return { chunkDefinitions: t, modulesInManualChunks: s }
		})(t),
		{
			allEntries: o,
			dependentEntriesByModule: a,
			dynamicallyDependentEntriesByDynamicEntry: l,
			dynamicImportsByEntry: c
		} = (function (e) {
			const t = new Set(),
				s = new Map(),
				i = [],
				n = new Set(e)
			let r = 0
			for (const e of n) {
				const o = new Set()
				i.push(o)
				const a = new Set([e])
				for (const e of a) {
					U(s, e, G).add(r)
					for (const t of e.getDependenciesToBeIncluded()) t instanceof Jt || a.add(t)
					for (const { resolution: s } of e.dynamicImports) s instanceof jo && s.includedDynamicImporters.length > 0 && !n.has(s) && (t.add(s), n.add(s), o.add(s))
					for (const s of e.implicitlyLoadedBefore) n.has(s) || (t.add(s), n.add(s))
				}
				r++
			}
			const o = [...n],
				{ dynamicEntries: a, dynamicImportsByEntry: l } = (function (e, t, s) {
					const i = new Map(),
						n = new Set()
					for (const [s, r] of e.entries()) i.set(r, s), t.has(r) && n.add(s)
					const r = []
					for (const e of s) {
						const t = new Set()
						for (const s of e) t.add(i.get(s))
						r.push(t)
					}
					return { dynamicEntries: n, dynamicImportsByEntry: r }
				})(o, t, i)
			return { allEntries: o, dependentEntriesByModule: s, dynamicallyDependentEntriesByDynamicEntry: Wa(s, a, o), dynamicImportsByEntry: l }
		})(e),
		h = qa(
			(function* (e, t) {
				for (const [s, i] of e) t.has(s) || (yield { dependentEntries: i, modules: [s] })
			})(a, r)
		)
	return (
		(function (e, t, s, i) {
			const n = i.map(() => 0n),
				r = i.map((e, s) => (t.has(s) ? -1n : 0n))
			let o = 1n
			for (const { dependentEntries: t } of e) {
				for (const e of t) n[e] |= o
				o <<= 1n
			}
			const a = t
			for (const [e, t] of a) {
				a.delete(e)
				const i = r[e]
				let o = i
				for (const e of t) o &= n[e] | r[e]
				if (o !== i) {
					r[e] = o
					for (const t of s[e]) U(a, t, G).add(e)
				}
			}
			o = 1n
			for (const { dependentEntries: t } of e) {
				for (const e of t) (r[e] & o) === o && t.delete(e)
				o <<= 1n
			}
		})(h, l, c, o),
		n.push(
			...(function (e, t, s, i) {
				Oo('optimize chunks', 3)
				const n = (function (e, t, s) {
					const i = [],
						n = [],
						r = new Map(),
						o = []
					let a = 0n,
						l = 1n
					for (const { dependentEntries: t, modules: c } of e) {
						const e = { containedAtoms: l, correlatedAtoms: 0n, dependencies: new Set(), dependentChunks: new Set(), dependentEntries: t, modules: c, pure: !0, size: 0 }
						let h = 0,
							u = !0
						for (const t of c) r.set(t, e), t.isIncluded() && (u && (u = !t.hasEffects()), (h += s > 1 ? t.estimateSize() : 1))
						;(e.pure = u), (e.size = h), o.push(h), u || (a |= l), (h < s ? i : n).push(e), (l <<= 1n)
					}
					if (0 === i.length) return null
					return (
						(a |= (function (e, t, s, i) {
							const n = new Map()
							let r = 0n
							const o = []
							for (let e = 0; e < s; e++) o.push(0n)
							for (const s of e) {
								s.sort(Ya)
								for (const e of s) {
									const { dependencies: s, dependentEntries: a, modules: l } = e
									for (const o of l)
										for (const a of o.getDependenciesToBeIncluded())
											if (a instanceof Jt)
												a.info.moduleSideEffects &&
													(e.containedAtoms |= U(n, a, () => {
														const e = i
														return (i <<= 1n), (r |= e), e
													}))
											else {
												const i = t.get(a)
												i && i !== e && (s.add(i), i.dependentChunks.add(e))
											}
									const { containedAtoms: c } = e
									for (const e of a) o[e] |= c
								}
							}
							for (const t of e)
								for (const e of t) {
									const { dependentEntries: t } = e
									e.correlatedAtoms = -1n
									for (const s of t) e.correlatedAtoms &= o[s]
								}
							return r
						})([n, i], r, t, l)),
						{ big: new Set(n), sideEffectAtoms: a, sizeByAtom: o, small: new Set(i) }
					)
				})(e, t, s)
				if (!n) return Do('optimize chunks', 3), e
				return (
					s > 1 && i('info', Wt(e.length, n.small.size, 'Initially')),
					(function (e, t) {
						const { small: s } = e
						for (const i of s) {
							const n = Ha(i, e, t <= 1 ? 1 : 1 / 0)
							if (n) {
								const { containedAtoms: r, correlatedAtoms: o, modules: a, pure: l, size: c } = i
								s.delete(i), Ka(n, t, e).delete(n), n.modules.push(...a), (n.size += c), n.pure && (n.pure = l)
								const { dependencies: h, dependentChunks: u, dependentEntries: d } = n
								;(n.correlatedAtoms &= o), (n.containedAtoms |= r)
								for (const e of i.dependentEntries) d.add(e)
								for (const e of i.dependencies) h.add(e), e.dependentChunks.delete(i), e.dependentChunks.add(n)
								for (const e of i.dependentChunks) u.add(e), e.dependencies.delete(i), e.dependencies.add(n)
								h.delete(n), u.delete(n), Ka(n, t, e).add(n)
							}
						}
					})(n, s),
					s > 1 && i('info', Wt(n.small.size + n.big.size, n.small.size, 'After merging chunks')),
					Do('optimize chunks', 3),
					[...n.small, ...n.big]
				)
			})(qa(h), o.length, s, i).map(({ modules: e }) => ({ alias: null, modules: e }))
		),
		n
	)
}
function Ga(e, t, s) {
	const i = new Set([e])
	for (const e of i) {
		s.add(e), t.push(e)
		for (const t of e.dependencies) t instanceof Jt || s.has(t) || i.add(t)
	}
}
function Wa(e, t, s) {
	const i = new Map()
	for (const n of t) {
		const t = U(i, n, G),
			r = s[n]
		for (const s of ja([r.includedDynamicImporters, r.implicitlyLoadedAfter])) for (const i of e.get(s)) t.add(i)
	}
	return i
}
function qa(e) {
	var t
	const s = Object.create(null)
	for (const { dependentEntries: i, modules: n } of e) {
		let e = 0n
		for (const t of i) e |= 1n << BigInt(t)
		;(s[(t = String(e))] || (s[t] = { dependentEntries: new Set(i), modules: [] })).modules.push(...n)
	}
	return Object.values(s)
}
function Ha(e, { big: t, sideEffectAtoms: s, sizeByAtom: i, small: n }, r) {
	let o = null
	for (const a of ja([n, t])) {
		if (e === a) continue
		const t = Xa(e, a, r, s, i)
		if (t < r) {
			if (((o = a), 0 === t)) break
			r = t
		}
	}
	return o
}
function Ka(e, t, s) {
	return e.size < t ? s.small : s.big
}
function Ya({ size: e }, { size: t }) {
	return e - t
}
function Xa(e, t, s, i, n) {
	const r = Qa(e, t, s, i, n)
	return r < s ? r + Qa(t, e, s - r, i, n) : 1 / 0
}
function Qa(e, t, s, i, n) {
	const { correlatedAtoms: r } = t
	let o = e.containedAtoms
	const a = o & i
	if ((r & a) !== a) return 1 / 0
	const l = new Set(e.dependencies)
	for (const { dependencies: e, containedAtoms: s } of l) {
		o |= s
		const n = s & i
		if ((r & n) !== n) return 1 / 0
		for (const s of e) {
			if (s === t) return 1 / 0
			l.add(s)
		}
	}
	return (function (e, t, s) {
		let i = 0,
			n = 0,
			r = 1n
		const { length: o } = s
		for (; n < o; n++) if (((e & r) === r && (i += s[n]), (r <<= 1n), i >= t)) return 1 / 0
		return i
	})(o & ~r, s, n)
}
const Za = (e, t) => (e.execIndex > t.execIndex ? 1 : -1)
function Ja(e, t, s) {
	const i = Symbol(e.id),
		n = [e.id]
	let r = t
	for (e.cycles.add(i); r !== e; ) r.cycles.add(i), n.push(r.id), (r = s.get(r))
	return n.push(n[0]), n.reverse(), n
}
const el = (e, t) => (t ? `(${e})` : e),
	tl = /^(?!\d)[\w$]+$/
class sl {
	constructor(e, t) {
		;(this.isOriginal = !0), (this.filename = e), (this.content = t)
	}
	traceSegment(e, t, s) {
		return { column: t, line: e, name: s, source: this }
	}
}
class il {
	constructor(e, t) {
		;(this.sources = t), (this.names = e.names), (this.mappings = e.mappings)
	}
	traceMappings() {
		const e = [],
			t = new Map(),
			s = [],
			i = [],
			n = new Map(),
			r = []
		for (const o of this.mappings) {
			const a = []
			for (const r of o) {
				if (1 === r.length) continue
				const o = this.sources[r[1]]
				if (!o) continue
				const l = o.traceSegment(r[2], r[3], 5 === r.length ? this.names[r[4]] : '')
				if (l) {
					const {
						column: o,
						line: c,
						name: h,
						source: { content: u, filename: d }
					} = l
					let p = t.get(d)
					if (void 0 === p) (p = e.length), e.push(d), t.set(d, p), (s[p] = u)
					else if (null == s[p]) s[p] = u
					else if (null != u && s[p] !== u) return Qe(Ht(d))
					const f = [r[0], p, c, o]
					if (h) {
						let e = n.get(h)
						void 0 === e && ((e = i.length), i.push(h), n.set(h, e)), (f[4] = e)
					}
					a.push(f)
				}
			}
			r.push(a)
		}
		return { mappings: r, names: i, sources: e, sourcesContent: s }
	}
	traceSegment(e, t, s) {
		const i = this.mappings[e]
		if (!i) return null
		let n = 0,
			r = i.length - 1
		for (; n <= r; ) {
			const e = (n + r) >> 1,
				o = i[e]
			if (o[0] === t || n === r) {
				if (1 == o.length) return null
				const e = this.sources[o[1]]
				return e ? e.traceSegment(o[2], o[3], 5 === o.length ? this.names[o[4]] : s) : null
			}
			o[0] > t ? (r = e - 1) : (n = e + 1)
		}
		return null
	}
}
function nl(e) {
	return function (t, s) {
		return s.missing
			? (e(
					Ae,
					((i = s.plugin),
					{
						code: Pt,
						message: `Sourcemap is likely to be incorrect: a plugin (${i}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`,
						plugin: i,
						url: De(Te)
					})
			  ),
			  new il({ mappings: [], names: [] }, [t]))
			: new il(s, [t])
		var i
	}
}
function rl(e, t, s, i, n) {
	let r
	if (s) {
		const t = s.sources,
			i = s.sourcesContent || [],
			n = $(e) || '.',
			o = s.sourceRoot || '.',
			a = t.map((e, t) => new sl(R(n, o, e), i[t]))
		r = new il(s, a)
	} else r = new sl(e, t)
	return i.reduce(n, r)
}
var ol = {},
	al = ll
function ll(e, t) {
	if (!e) throw new Error(t || 'Assertion failed')
}
ll.equal = function (e, t, s) {
	if (e != t) throw new Error(s || 'Assertion failed: ' + e + ' != ' + t)
}
var cl = { exports: {} }
'function' == typeof Object.create
	? (cl.exports = function (e, t) {
			t && ((e.super_ = t), (e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })))
	  })
	: (cl.exports = function (e, t) {
			if (t) {
				e.super_ = t
				var s = function () {}
				;(s.prototype = t.prototype), (e.prototype = new s()), (e.prototype.constructor = e)
			}
	  })
var hl = cl.exports,
	ul = al,
	dl = hl
function pl(e, t) {
	return 55296 == (64512 & e.charCodeAt(t)) && !(t < 0 || t + 1 >= e.length) && 56320 == (64512 & e.charCodeAt(t + 1))
}
function fl(e) {
	return ((e >>> 24) | ((e >>> 8) & 65280) | ((e << 8) & 16711680) | ((255 & e) << 24)) >>> 0
}
function ml(e) {
	return 1 === e.length ? '0' + e : e
}
function gl(e) {
	return 7 === e.length
		? '0' + e
		: 6 === e.length
		? '00' + e
		: 5 === e.length
		? '000' + e
		: 4 === e.length
		? '0000' + e
		: 3 === e.length
		? '00000' + e
		: 2 === e.length
		? '000000' + e
		: 1 === e.length
		? '0000000' + e
		: e
}
;(ol.inherits = dl),
	(ol.toArray = function (e, t) {
		if (Array.isArray(e)) return e.slice()
		if (!e) return []
		var s = []
		if ('string' == typeof e)
			if (t) {
				if ('hex' === t) for ((e = e.replace(/[^a-z0-9]+/gi, '')).length % 2 != 0 && (e = '0' + e), n = 0; n < e.length; n += 2) s.push(parseInt(e[n] + e[n + 1], 16))
			} else
				for (var i = 0, n = 0; n < e.length; n++) {
					var r = e.charCodeAt(n)
					r < 128
						? (s[i++] = r)
						: r < 2048
						? ((s[i++] = (r >> 6) | 192), (s[i++] = (63 & r) | 128))
						: pl(e, n)
						? ((r = 65536 + ((1023 & r) << 10) + (1023 & e.charCodeAt(++n))),
						  (s[i++] = (r >> 18) | 240),
						  (s[i++] = ((r >> 12) & 63) | 128),
						  (s[i++] = ((r >> 6) & 63) | 128),
						  (s[i++] = (63 & r) | 128))
						: ((s[i++] = (r >> 12) | 224), (s[i++] = ((r >> 6) & 63) | 128), (s[i++] = (63 & r) | 128))
				}
		else for (n = 0; n < e.length; n++) s[n] = 0 | e[n]
		return s
	}),
	(ol.toHex = function (e) {
		for (var t = '', s = 0; s < e.length; s++) t += ml(e[s].toString(16))
		return t
	}),
	(ol.htonl = fl),
	(ol.toHex32 = function (e, t) {
		for (var s = '', i = 0; i < e.length; i++) {
			var n = e[i]
			'little' === t && (n = fl(n)), (s += gl(n.toString(16)))
		}
		return s
	}),
	(ol.zero2 = ml),
	(ol.zero8 = gl),
	(ol.join32 = function (e, t, s, i) {
		var n = s - t
		ul(n % 4 == 0)
		for (var r = new Array(n / 4), o = 0, a = t; o < r.length; o++, a += 4) {
			var l
			;(l = 'big' === i ? (e[a] << 24) | (e[a + 1] << 16) | (e[a + 2] << 8) | e[a + 3] : (e[a + 3] << 24) | (e[a + 2] << 16) | (e[a + 1] << 8) | e[a]), (r[o] = l >>> 0)
		}
		return r
	}),
	(ol.split32 = function (e, t) {
		for (var s = new Array(4 * e.length), i = 0, n = 0; i < e.length; i++, n += 4) {
			var r = e[i]
			'big' === t
				? ((s[n] = r >>> 24), (s[n + 1] = (r >>> 16) & 255), (s[n + 2] = (r >>> 8) & 255), (s[n + 3] = 255 & r))
				: ((s[n + 3] = r >>> 24), (s[n + 2] = (r >>> 16) & 255), (s[n + 1] = (r >>> 8) & 255), (s[n] = 255 & r))
		}
		return s
	}),
	(ol.rotr32 = function (e, t) {
		return (e >>> t) | (e << (32 - t))
	}),
	(ol.rotl32 = function (e, t) {
		return (e << t) | (e >>> (32 - t))
	}),
	(ol.sum32 = function (e, t) {
		return (e + t) >>> 0
	}),
	(ol.sum32_3 = function (e, t, s) {
		return (e + t + s) >>> 0
	}),
	(ol.sum32_4 = function (e, t, s, i) {
		return (e + t + s + i) >>> 0
	}),
	(ol.sum32_5 = function (e, t, s, i, n) {
		return (e + t + s + i + n) >>> 0
	}),
	(ol.sum64 = function (e, t, s, i) {
		var n = e[t],
			r = (i + e[t + 1]) >>> 0,
			o = (r < i ? 1 : 0) + s + n
		;(e[t] = o >>> 0), (e[t + 1] = r)
	}),
	(ol.sum64_hi = function (e, t, s, i) {
		return (((t + i) >>> 0 < t ? 1 : 0) + e + s) >>> 0
	}),
	(ol.sum64_lo = function (e, t, s, i) {
		return (t + i) >>> 0
	}),
	(ol.sum64_4_hi = function (e, t, s, i, n, r, o, a) {
		var l = 0,
			c = t
		return (l += (c = (c + i) >>> 0) < t ? 1 : 0), (l += (c = (c + r) >>> 0) < r ? 1 : 0), (e + s + n + o + (l += (c = (c + a) >>> 0) < a ? 1 : 0)) >>> 0
	}),
	(ol.sum64_4_lo = function (e, t, s, i, n, r, o, a) {
		return (t + i + r + a) >>> 0
	}),
	(ol.sum64_5_hi = function (e, t, s, i, n, r, o, a, l, c) {
		var h = 0,
			u = t
		return (h += (u = (u + i) >>> 0) < t ? 1 : 0), (h += (u = (u + r) >>> 0) < r ? 1 : 0), (h += (u = (u + a) >>> 0) < a ? 1 : 0), (e + s + n + o + l + (h += (u = (u + c) >>> 0) < c ? 1 : 0)) >>> 0
	}),
	(ol.sum64_5_lo = function (e, t, s, i, n, r, o, a, l, c) {
		return (t + i + r + a + c) >>> 0
	}),
	(ol.rotr64_hi = function (e, t, s) {
		return ((t << (32 - s)) | (e >>> s)) >>> 0
	}),
	(ol.rotr64_lo = function (e, t, s) {
		return ((e << (32 - s)) | (t >>> s)) >>> 0
	}),
	(ol.shr64_hi = function (e, t, s) {
		return e >>> s
	}),
	(ol.shr64_lo = function (e, t, s) {
		return ((e << (32 - s)) | (t >>> s)) >>> 0
	})
var yl = {},
	xl = ol,
	El = al
function bl() {
	;(this.pending = null),
		(this.pendingTotal = 0),
		(this.blockSize = this.constructor.blockSize),
		(this.outSize = this.constructor.outSize),
		(this.hmacStrength = this.constructor.hmacStrength),
		(this.padLength = this.constructor.padLength / 8),
		(this.endian = 'big'),
		(this._delta8 = this.blockSize / 8),
		(this._delta32 = this.blockSize / 32)
}
;(yl.BlockHash = bl),
	(bl.prototype.update = function (e, t) {
		if (((e = xl.toArray(e, t)), this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e), (this.pendingTotal += e.length), this.pending.length >= this._delta8)) {
			var s = (e = this.pending).length % this._delta8
			;(this.pending = e.slice(e.length - s, e.length)), 0 === this.pending.length && (this.pending = null), (e = xl.join32(e, 0, e.length - s, this.endian))
			for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
		}
		return this
	}),
	(bl.prototype.digest = function (e) {
		return this.update(this._pad()), El(null === this.pending), this._digest(e)
	}),
	(bl.prototype._pad = function () {
		var e = this.pendingTotal,
			t = this._delta8,
			s = t - ((e + this.padLength) % t),
			i = new Array(s + this.padLength)
		i[0] = 128
		for (var n = 1; n < s; n++) i[n] = 0
		if (((e <<= 3), 'big' === this.endian)) {
			for (var r = 8; r < this.padLength; r++) i[n++] = 0
			;(i[n++] = 0), (i[n++] = 0), (i[n++] = 0), (i[n++] = 0), (i[n++] = (e >>> 24) & 255), (i[n++] = (e >>> 16) & 255), (i[n++] = (e >>> 8) & 255), (i[n++] = 255 & e)
		} else
			for (i[n++] = 255 & e, i[n++] = (e >>> 8) & 255, i[n++] = (e >>> 16) & 255, i[n++] = (e >>> 24) & 255, i[n++] = 0, i[n++] = 0, i[n++] = 0, i[n++] = 0, r = 8; r < this.padLength; r++) i[n++] = 0
		return i
	})
var vl = {},
	Sl = ol.rotr32
function Al(e, t, s) {
	return (e & t) ^ (~e & s)
}
function kl(e, t, s) {
	return (e & t) ^ (e & s) ^ (t & s)
}
function Il(e, t, s) {
	return e ^ t ^ s
}
;(vl.ft_1 = function (e, t, s, i) {
	return 0 === e ? Al(t, s, i) : 1 === e || 3 === e ? Il(t, s, i) : 2 === e ? kl(t, s, i) : void 0
}),
	(vl.ch32 = Al),
	(vl.maj32 = kl),
	(vl.p32 = Il),
	(vl.s0_256 = function (e) {
		return Sl(e, 2) ^ Sl(e, 13) ^ Sl(e, 22)
	}),
	(vl.s1_256 = function (e) {
		return Sl(e, 6) ^ Sl(e, 11) ^ Sl(e, 25)
	}),
	(vl.g0_256 = function (e) {
		return Sl(e, 7) ^ Sl(e, 18) ^ (e >>> 3)
	}),
	(vl.g1_256 = function (e) {
		return Sl(e, 17) ^ Sl(e, 19) ^ (e >>> 10)
	})
var wl = ol,
	Pl = yl,
	Cl = vl,
	$l = al,
	Nl = wl.sum32,
	_l = wl.sum32_4,
	Rl = wl.sum32_5,
	Ml = Cl.ch32,
	Ol = Cl.maj32,
	Dl = Cl.s0_256,
	Ll = Cl.s1_256,
	Tl = Cl.g0_256,
	Vl = Cl.g1_256,
	Bl = Pl.BlockHash,
	zl = [
		1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
		3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
		666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
		430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298
	]
function Fl() {
	if (!(this instanceof Fl)) return new Fl()
	Bl.call(this), (this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), (this.k = zl), (this.W = new Array(64))
}
wl.inherits(Fl, Bl)
var jl = Fl
;(Fl.blockSize = 512),
	(Fl.outSize = 256),
	(Fl.hmacStrength = 192),
	(Fl.padLength = 64),
	(Fl.prototype._update = function (e, t) {
		for (var s = this.W, i = 0; i < 16; i++) s[i] = e[t + i]
		for (; i < s.length; i++) s[i] = _l(Vl(s[i - 2]), s[i - 7], Tl(s[i - 15]), s[i - 16])
		var n = this.h[0],
			r = this.h[1],
			o = this.h[2],
			a = this.h[3],
			l = this.h[4],
			c = this.h[5],
			h = this.h[6],
			u = this.h[7]
		for ($l(this.k.length === s.length), i = 0; i < s.length; i++) {
			var d = Rl(u, Ll(l), Ml(l, c, h), this.k[i], s[i]),
				p = Nl(Dl(n), Ol(n, r, o))
			;(u = h), (h = c), (c = l), (l = Nl(a, d)), (a = o), (o = r), (r = n), (n = Nl(d, p))
		}
		;(this.h[0] = Nl(this.h[0], n)),
			(this.h[1] = Nl(this.h[1], r)),
			(this.h[2] = Nl(this.h[2], o)),
			(this.h[3] = Nl(this.h[3], a)),
			(this.h[4] = Nl(this.h[4], l)),
			(this.h[5] = Nl(this.h[5], c)),
			(this.h[6] = Nl(this.h[6], h)),
			(this.h[7] = Nl(this.h[7], u))
	}),
	(Fl.prototype._digest = function (e) {
		return 'hex' === e ? wl.toHex32(this.h, 'big') : wl.split32(this.h, 'big')
	})
var Ul = t(jl)
const Gl = () => Ul()
async function Wl(e, t, s, i, n) {
	Oo('render chunks', 2),
		(function (e) {
			for (const t of e) t.facadeModule && t.facadeModule.isUserDefinedEntryPoint && t.getPreliminaryFileName()
		})(e)
	const r = await Promise.all(e.map((e) => e.render()))
	Do('render chunks', 2), Oo('transform chunks', 2)
	const o = (function (e) {
			return Object.fromEntries(
				e.map((e) => {
					const t = e.getRenderedChunkInfo()
					return [t.fileName, t]
				})
			)
		})(e),
		{
			initialHashesByPlaceholder: a,
			nonHashedChunksWithPlaceholders: l,
			renderedChunksByPlaceholder: c,
			hashDependenciesByPlaceholder: h
		} = await (async function (e, t, s, i, n) {
			const r = [],
				o = new Map(),
				a = new Map(),
				l = new Map(),
				c = new Set()
			for (const {
				preliminaryFileName: { hashPlaceholder: t }
			} of e)
				t && c.add(t)
			return (
				await Promise.all(
					e.map(async ({ chunk: e, preliminaryFileName: { fileName: h, hashPlaceholder: u }, preliminarySourcemapFileName: d, magicString: p, usedModules: f }) => {
						const m = { chunk: e, fileName: h, sourcemapFileName: d?.fileName ?? null, ...(await ql(p, h, f, t, s, i, n)) },
							{ code: g, map: y } = m
						if (u) {
							const { containedPlaceholders: t, transformedCode: s } = $a(g, c),
								n = Gl().update(s),
								r = i.hookReduceValueSync('augmentChunkHash', '', [e.getRenderedChunkInfo()], (e, t) => (t && (e += t), e))
							r && n.update(r), o.set(u, m), a.set(u, { containedPlaceholders: t, contentHash: n.digest('hex') })
						} else r.push(m)
						const x = d?.hashPlaceholder
						y && x && l.set(d.hashPlaceholder, Gl().update(y.toString()).digest('hex').slice(0, d.hashPlaceholder.length))
					})
				),
				{ hashDependenciesByPlaceholder: a, initialHashesByPlaceholder: l, nonHashedChunksWithPlaceholders: r, renderedChunksByPlaceholder: o }
			)
		})(r, o, i, s, n),
		u = (function (e, t, s, i) {
			const n = new Map(s)
			for (const [s, { fileName: r }] of e) {
				let e = Gl()
				const o = new Set([s])
				for (const s of o) {
					const { containedPlaceholders: i, contentHash: n } = t.get(s)
					e.update(n)
					for (const e of i) o.add(e)
				}
				let a, l
				do {
					l && (e = Gl().update(l)), (l = e.digest('hex').slice(0, s.length)), (a = Ca(r, s, l))
				} while (i[Na].has(a.toLowerCase()))
				;(i[a] = _a), n.set(s, l)
			}
			return n
		})(c, h, a, t)
	!(function (e, t, s, i, n, r) {
		for (const { chunk: i, code: o, fileName: a, sourcemapFileName: l, map: c } of e.values()) {
			let e = Pa(o, t)
			const h = Pa(a, t)
			let u = null
			c && ((u = l ? Pa(l, t) : `${h}.map`), (c.file = Pa(c.file, t)), (e += Hl(u, c, n, r))), (s[h] = i.finalizeChunk(e, c, u, t))
		}
		for (const { chunk: e, code: o, fileName: a, sourcemapFileName: l, map: c } of i) {
			let i = t.size > 0 ? Pa(o, t) : o,
				h = null
			c && ((h = l ? Pa(l, t) : `${a}.map`), (i += Hl(h, c, n, r))), (s[a] = e.finalizeChunk(i, c, h, t))
		}
	})(c, u, t, l, s, i),
		Do('transform chunks', 2)
}
async function ql(e, t, s, i, n, r, o) {
	let a = null
	const c = []
	let h = await r.hookReduceArg0('renderChunk', [e.toString(), i[t], n, { chunks: i }], (e, t, s) => {
		if (null == t) return e
		if (('string' == typeof t && (t = { code: t, map: void 0 }), null !== t.map)) {
			const e = Ao(t.map)
			c.push(e || { missing: !0, plugin: s.name })
		}
		return t.code
	})
	const { compact: u, dir: d, file: p, sourcemap: f, sourcemapExcludeSources: m, sourcemapFile: g, sourcemapPathTransform: y, sourcemapIgnoreList: x } = n
	if ((u || '\n' === h[h.length - 1] || (h += '\n'), f)) {
		let i
		Oo('sourcemaps', 3), (i = p ? R(g || p) : d ? R(d, t) : R(t))
		a = (function (e, t, s, i, n, r) {
			const o = nl(r),
				a = s.filter((e) => !e.excludeFromSourcemap).map((e) => rl(e.id, e.originalCode, e.originalSourcemap, e.sourcemapChain, o)),
				c = new il(t, a),
				h = i.reduce(o, c)
			let { sources: u, sourcesContent: d, names: p, mappings: f } = h.traceMappings()
			if (e) {
				const t = $(e)
				;(u = u.map((e) => _(t, e))), (e = C(e))
			}
			d = n ? null : d
			for (const e of s) So(e.originalSourcemap, e.sourcemapChain)
			return new l({ file: e, mappings: f, names: p, sources: u, sourcesContent: d })
		})(i, e.generateDecodedMap({}), s, c, m, o)
		for (let e = 0; e < a.sources.length; ++e) {
			let t = a.sources[e]
			const s = `${i}.map`,
				n = x(t, s)
			'boolean' != typeof n && Qe(Xt('sourcemapIgnoreList function must return a boolean.')),
				n && (void 0 === a.x_google_ignoreList && (a.x_google_ignoreList = []), a.x_google_ignoreList.includes(e) || a.x_google_ignoreList.push(e)),
				y && ((t = y(t, s)), 'string' != typeof t && Qe(Xt('sourcemapPathTransform function must return a string.'))),
				(a.sources[e] = P(t))
		}
		Do('sourcemaps', 3)
	}
	return { code: h, map: a }
}
function Hl(e, t, s, { sourcemap: i, sourcemapBaseUrl: n }) {
	let r
	if ('inline' === i) r = t.toUrl()
	else {
		const i = C(e)
		;(r = n ? new URL(i, n).toString() : i), s.emitFile({ fileName: e, source: t.toString(), type: 'asset' })
	}
	return 'hidden' === i ? '' : `//# ${Fs}=${r}\n`
}
class Kl {
	constructor(e, t, s, i, n) {
		;(this.outputOptions = e),
			(this.unsetOptions = t),
			(this.inputOptions = s),
			(this.pluginDriver = i),
			(this.graph = n),
			(this.facadeChunkByModule = new Map()),
			(this.includedNamespaces = new Set())
	}
	async generate(e) {
		Oo('GENERATE', 1)
		const t = Object.create(null),
			s = ((e) => {
				const t = new Set()
				return new Proxy(e, {
					deleteProperty: (e, s) => ('string' == typeof s && t.delete(s.toLowerCase()), Reflect.deleteProperty(e, s)),
					get: (e, s) => (s === Na ? t : Reflect.get(e, s)),
					set: (e, s, i) => ('string' == typeof s && t.add(s.toLowerCase()), Reflect.set(e, s, i))
				})
			})(t)
		this.pluginDriver.setOutputBundle(s, this.outputOptions)
		try {
			Oo('initialize render', 2), await this.pluginDriver.hookParallel('renderStart', [this.outputOptions, this.inputOptions]), Do('initialize render', 2), Oo('generate chunks', 2)
			const e = (() => {
					let e = 0
					return (t, s = 8) => {
						if (s > 64) return Qe(Xt(`Hashes cannot be longer than 64 characters, received ${s}. Check the "${t}" option.`))
						const i = `${ka}${Di(++e).padStart(s - 5, '0')}${Ia}`
						return i.length > s ? Qe(Xt(`To generate hashes for this number of chunks (currently ${e}), you need a minimum hash size of ${i.length}, received ${s}. Check the "${t}" option.`)) : i
					}
				})(),
				t = await this.generateChunks(s, e)
			t.length > 1 &&
				(function (e, t) {
					if ('umd' === e.format || 'iife' === e.format) return Qe(jt('output.format', je, 'UMD and IIFE output formats are not supported for code-splitting builds', e.format))
					if ('string' == typeof e.file)
						return Qe(jt('output.file', Be, 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'))
					if (e.sourcemapFile) return Qe(jt('output.sourcemapFile', Ye, '"output.sourcemapFile" is only supported for single-file builds'))
					!e.amd.autoId && e.amd.id && t(Ae, jt('output.amd.id', Ve, 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'))
				})(this.outputOptions, this.inputOptions.onLog),
				this.pluginDriver.setChunkInformation(this.facadeChunkByModule)
			for (const e of t) e.generateExports()
			Do('generate chunks', 2), await Wl(t, s, this.pluginDriver, this.outputOptions, this.inputOptions.onLog)
		} catch (e) {
			throw (await this.pluginDriver.hookParallel('renderError', [e]), e)
		}
		return (
			((e) => {
				const t = new Set(),
					s = Object.values(e)
				for (const e of s) 'asset' === e.type && e.needsCodeReference && t.add(e.fileName)
				for (const e of s) if ('chunk' === e.type) for (const s of e.referencedFiles) t.has(s) && t.delete(s)
				for (const s of t) delete e[s]
			})(s),
			Oo('generate bundle', 2),
			await this.pluginDriver.hookSeq('generateBundle', [this.outputOptions, s, e]),
			this.finaliseAssets(s),
			Do('generate bundle', 2),
			Do('GENERATE', 1),
			t
		)
	}
	async addManualChunks(e) {
		const t = new Map(),
			s = await Promise.all(Object.entries(e).map(async ([e, t]) => ({ alias: e, entries: await this.graph.moduleLoader.addAdditionalModules(t, !0) })))
		for (const { alias: e, entries: i } of s) for (const s of i) Yl(e, s, t)
		return t
	}
	assignManualChunks(e) {
		const t = [],
			s = { getModuleIds: () => this.graph.modulesById.keys(), getModuleInfo: this.graph.getModuleInfo }
		for (const i of this.graph.modulesById.values())
			if (i instanceof jo) {
				const n = e(i.id, s)
				'string' == typeof n && t.push([n, i])
			}
		t.sort(([e], [t]) => (e > t ? 1 : e < t ? -1 : 0))
		const i = new Map()
		for (const [e, s] of t) Yl(e, s, i)
		return i
	}
	finaliseAssets(e) {
		if (this.outputOptions.validate)
			for (const t of Object.values(e))
				if ('code' in t)
					try {
						this.graph.contextParse(t.code, { ecmaVersion: 'latest' })
					} catch (e) {
						this.inputOptions.onLog(Ae, Dt(t, e))
					}
		this.pluginDriver.finaliseAssets()
	}
	async generateChunks(e, t) {
		const { experimentalMinChunkSize: s, inlineDynamicImports: i, manualChunks: n, preserveModules: r } = this.outputOptions,
			o = 'object' == typeof n ? await this.addManualChunks(n) : this.assignManualChunks(n),
			a = (function ({ compact: e, generatedCode: { arrowFunctions: t, constBindings: s, objectShorthand: i, reservedNamesAsProps: n } }) {
				const { _: r, n: o, s: a } = e ? { _: '', n: '', s: '' } : { _: ' ', n: '\n', s: ';' },
					l = s ? 'const' : 'var',
					c = (e, { isAsync: t, name: s }) => `${t ? 'async ' : ''}function${s ? ` ${s}` : ''}${r}(${e.join(`,${r}`)})${r}`,
					h = t
						? (e, { isAsync: t, name: s }) => {
								const i = 1 === e.length
								return `${s ? `${l} ${s}${r}=${r}` : ''}${t ? `async${i ? ' ' : r}` : ''}${i ? e[0] : `(${e.join(`,${r}`)})`}${r}=>${r}`
						  }
						: c,
					u = (e, { functionReturn: s, lineBreakIndent: i, name: n }) => [
						`${h(e, { isAsync: !1, name: n })}${t ? (i ? `${o}${i.base}${i.t}` : '') : `{${i ? `${o}${i.base}${i.t}` : r}${s ? 'return ' : ''}`}`,
						t ? `${n ? ';' : ''}${i ? `${o}${i.base}` : ''}` : `${a}${i ? `${o}${i.base}` : r}}`
					],
					d = n ? (e) => tl.test(e) : (e) => !Ee.has(e) && tl.test(e)
				return {
					_: r,
					cnst: l,
					getDirectReturnFunction: u,
					getDirectReturnIifeLeft: (e, s, { needsArrowReturnParens: i, needsWrappedFunction: n }) => {
						const [r, o] = u(e, { functionReturn: !0, lineBreakIndent: null, name: null })
						return `${el(`${r}${el(s, t && i)}${o}`, t || n)}(`
					},
					getFunctionIntro: h,
					getNonArrowFunctionIntro: c,
					getObject(e, { lineBreakIndent: t }) {
						const s = t ? `${o}${t.base}${t.t}` : r
						return `{${e
							.map(([e, t]) => {
								if (null === e) return `${s}${t}`
								const n = !d(e)
								return e === t && i && !n ? s + e : `${s}${n ? `'${e}'` : e}:${r}${t}`
							})
							.join(',')}${0 === e.length ? '' : t ? `${o}${t.base}` : r}}`
					},
					getPropertyAccess: (e) => (d(e) ? `.${e}` : `[${JSON.stringify(e)}]`),
					n: o,
					s: a
				}
			})(this.outputOptions),
			l = (function (e) {
				const t = []
				for (const s of e.values()) s instanceof jo && (s.isIncluded() || s.info.isEntry || s.includedDynamicImporters.length > 0) && t.push(s)
				return t
			})(this.graph.modulesById),
			c = (function (e) {
				if (0 === e.length) return '/'
				if (1 === e.length) return $(e[0])
				const t = e.slice(1).reduce((e, t) => {
					const s = t.split(/\/+|\\+/)
					let i
					for (i = 0; e[i] === s[i] && i < Math.min(e.length, s.length); i++);
					return e.slice(0, i)
				}, e[0].split(/\/+|\\+/))
				return t.length > 1 ? t.join('/') : '/'
			})(
				(function (e, t) {
					const s = []
					for (const i of e) (i.info.isEntry || t) && I(i.id) && s.push(i.id)
					return s
				})(l, r)
			),
			h = (function (e, t, s) {
				const i = new Map()
				for (const n of e.values()) n instanceof Jt && i.set(n, new j(n, t, s))
				return i
			})(this.graph.modulesById, this.outputOptions, c),
			u = [],
			d = new Map()
		for (const { alias: n, modules: p } of i ? [{ alias: null, modules: l }] : r ? l.map((e) => ({ alias: null, modules: [e] })) : Ua(this.graph.entryModules, o, s, this.inputOptions.onLog)) {
			p.sort(Za)
			const s = new La(p, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, d, h, this.facadeChunkByModule, this.includedNamespaces, n, t, e, c, a)
			u.push(s)
		}
		for (const e of u) e.link()
		const p = []
		for (const e of u) p.push(...e.generateFacades())
		return [...u, ...p]
	}
}
function Yl(e, t, s) {
	const i = s.get(t)
	if ('string' == typeof i && i !== e) return Qe(((n = t.id), (r = e), (o = i), { code: ht, message: `Cannot assign "${V(n)}" to the "${r}" chunk as it is already in the "${o}" chunk.` }))
	var n, r, o
	s.set(t, e)
}
var Xl = [
		509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9,
		6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83,
		16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123,
		5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
		1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13,
		983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239
	],
	Ql = [
		0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10,
		2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28,
		4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30,
		0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31,
		47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0,
		12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071,
		18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2,
		3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30,
		2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2,
		1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421,
		42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191
	],
	Zl =
		'ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ',
	Jl = {
		3: 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile',
		5: 'class enum extends super const export import',
		6: 'enum',
		strict: 'implements interface let package private protected public static yield',
		strictBind: 'eval arguments'
	},
	ec = 'break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this',
	tc = { 5: ec, '5module': ec + ' export import', 6: ec + ' const class extends export import super' },
	sc = /^in(stanceof)?$/,
	ic = new RegExp('[' + Zl + ']'),
	nc = new RegExp(
		'[' +
			Zl +
			'‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿]'
	)
function rc(e, t) {
	for (var s = 65536, i = 0; i < t.length; i += 2) {
		if ((s += t[i]) > e) return !1
		if ((s += t[i + 1]) >= e) return !0
	}
	return !1
}
function oc(e, t) {
	return e < 65 ? 36 === e : e < 91 || (e < 97 ? 95 === e : e < 123 || (e <= 65535 ? e >= 170 && ic.test(String.fromCharCode(e)) : !1 !== t && rc(e, Ql)))
}
function ac(e, t) {
	return e < 48 ? 36 === e : e < 58 || (!(e < 65) && (e < 91 || (e < 97 ? 95 === e : e < 123 || (e <= 65535 ? e >= 170 && nc.test(String.fromCharCode(e)) : !1 !== t && (rc(e, Ql) || rc(e, Xl))))))
}
var lc = function (e, t) {
	void 0 === t && (t = {}),
		(this.label = e),
		(this.keyword = t.keyword),
		(this.beforeExpr = !!t.beforeExpr),
		(this.startsExpr = !!t.startsExpr),
		(this.isLoop = !!t.isLoop),
		(this.isAssign = !!t.isAssign),
		(this.prefix = !!t.prefix),
		(this.postfix = !!t.postfix),
		(this.binop = t.binop || null),
		(this.updateContext = null)
}
function cc(e, t) {
	return new lc(e, { beforeExpr: !0, binop: t })
}
var hc = { beforeExpr: !0 },
	uc = { startsExpr: !0 },
	dc = {}
function pc(e, t) {
	return void 0 === t && (t = {}), (t.keyword = e), (dc[e] = new lc(e, t))
}
var fc = {
		num: new lc('num', uc),
		regexp: new lc('regexp', uc),
		string: new lc('string', uc),
		name: new lc('name', uc),
		privateId: new lc('privateId', uc),
		eof: new lc('eof'),
		bracketL: new lc('[', { beforeExpr: !0, startsExpr: !0 }),
		bracketR: new lc(']'),
		braceL: new lc('{', { beforeExpr: !0, startsExpr: !0 }),
		braceR: new lc('}'),
		parenL: new lc('(', { beforeExpr: !0, startsExpr: !0 }),
		parenR: new lc(')'),
		comma: new lc(',', hc),
		semi: new lc(';', hc),
		colon: new lc(':', hc),
		dot: new lc('.'),
		question: new lc('?', hc),
		questionDot: new lc('?.'),
		arrow: new lc('=>', hc),
		template: new lc('template'),
		invalidTemplate: new lc('invalidTemplate'),
		ellipsis: new lc('...', hc),
		backQuote: new lc('`', uc),
		dollarBraceL: new lc('${', { beforeExpr: !0, startsExpr: !0 }),
		eq: new lc('=', { beforeExpr: !0, isAssign: !0 }),
		assign: new lc('_=', { beforeExpr: !0, isAssign: !0 }),
		incDec: new lc('++/--', { prefix: !0, postfix: !0, startsExpr: !0 }),
		prefix: new lc('!/~', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
		logicalOR: cc('||', 1),
		logicalAND: cc('&&', 2),
		bitwiseOR: cc('|', 3),
		bitwiseXOR: cc('^', 4),
		bitwiseAND: cc('&', 5),
		equality: cc('==/!=/===/!==', 6),
		relational: cc('</>/<=/>=', 7),
		bitShift: cc('<</>>/>>>', 8),
		plusMin: new lc('+/-', { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
		modulo: cc('%', 10),
		star: cc('*', 10),
		slash: cc('/', 10),
		starstar: new lc('**', { beforeExpr: !0 }),
		coalesce: cc('??', 1),
		_break: pc('break'),
		_case: pc('case', hc),
		_catch: pc('catch'),
		_continue: pc('continue'),
		_debugger: pc('debugger'),
		_default: pc('default', hc),
		_do: pc('do', { isLoop: !0, beforeExpr: !0 }),
		_else: pc('else', hc),
		_finally: pc('finally'),
		_for: pc('for', { isLoop: !0 }),
		_function: pc('function', uc),
		_if: pc('if'),
		_return: pc('return', hc),
		_switch: pc('switch'),
		_throw: pc('throw', hc),
		_try: pc('try'),
		_var: pc('var'),
		_const: pc('const'),
		_while: pc('while', { isLoop: !0 }),
		_with: pc('with'),
		_new: pc('new', { beforeExpr: !0, startsExpr: !0 }),
		_this: pc('this', uc),
		_super: pc('super', uc),
		_class: pc('class', uc),
		_extends: pc('extends', hc),
		_export: pc('export'),
		_import: pc('import', uc),
		_null: pc('null', uc),
		_true: pc('true', uc),
		_false: pc('false', uc),
		_in: pc('in', { beforeExpr: !0, binop: 7 }),
		_instanceof: pc('instanceof', { beforeExpr: !0, binop: 7 }),
		_typeof: pc('typeof', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
		_void: pc('void', { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
		_delete: pc('delete', { beforeExpr: !0, prefix: !0, startsExpr: !0 })
	},
	mc = /\r\n?|\n|\u2028|\u2029/,
	gc = new RegExp(mc.source, 'g')
function yc(e) {
	return 10 === e || 13 === e || 8232 === e || 8233 === e
}
function xc(e, t, s) {
	void 0 === s && (s = e.length)
	for (var i = t; i < s; i++) {
		var n = e.charCodeAt(i)
		if (yc(n)) return i < s - 1 && 13 === n && 10 === e.charCodeAt(i + 1) ? i + 2 : i + 1
	}
	return -1
}
var Ec = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
	bc = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
	vc = Object.prototype,
	Sc = vc.hasOwnProperty,
	Ac = vc.toString,
	kc =
		Object.hasOwn ||
		function (e, t) {
			return Sc.call(e, t)
		},
	Ic =
		Array.isArray ||
		function (e) {
			return '[object Array]' === Ac.call(e)
		}
function wc(e) {
	return new RegExp('^(?:' + e.replace(/ /g, '|') + ')$')
}
function Pc(e) {
	return e <= 65535 ? String.fromCharCode(e) : ((e -= 65536), String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e)))
}
var Cc = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
	$c = function (e, t) {
		;(this.line = e), (this.column = t)
	}
$c.prototype.offset = function (e) {
	return new $c(this.line, this.column + e)
}
var Nc = function (e, t, s) {
	;(this.start = t), (this.end = s), null !== e.sourceFile && (this.source = e.sourceFile)
}
function _c(e, t) {
	for (var s = 1, i = 0; ; ) {
		var n = xc(e, i, t)
		if (n < 0) return new $c(s, t - i)
		++s, (i = n)
	}
}
var Rc = {
		ecmaVersion: null,
		sourceType: 'script',
		onInsertedSemicolon: null,
		onTrailingComma: null,
		allowReserved: null,
		allowReturnOutsideFunction: !1,
		allowImportExportEverywhere: !1,
		allowAwaitOutsideFunction: null,
		allowSuperOutsideMethod: null,
		allowHashBang: !1,
		checkPrivateFields: !0,
		locations: !1,
		onToken: null,
		onComment: null,
		ranges: !1,
		program: null,
		sourceFile: null,
		directSourceFile: null,
		preserveParens: !1
	},
	Mc = !1
function Oc(e) {
	var t = {}
	for (var s in Rc) t[s] = e && kc(e, s) ? e[s] : Rc[s]
	if (
		('latest' === t.ecmaVersion
			? (t.ecmaVersion = 1e8)
			: null == t.ecmaVersion
			? (!Mc &&
					'object' == typeof console &&
					console.warn &&
					((Mc = !0), console.warn('Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.')),
			  (t.ecmaVersion = 11))
			: t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009),
		null == t.allowReserved && (t.allowReserved = t.ecmaVersion < 5),
		(e && null != e.allowHashBang) || (t.allowHashBang = t.ecmaVersion >= 14),
		Ic(t.onToken))
	) {
		var i = t.onToken
		t.onToken = function (e) {
			return i.push(e)
		}
	}
	return (
		Ic(t.onComment) &&
			(t.onComment = (function (e, t) {
				return function (s, i, n, r, o, a) {
					var l = { type: s ? 'Block' : 'Line', value: i, start: n, end: r }
					e.locations && (l.loc = new Nc(this, o, a)), e.ranges && (l.range = [n, r]), t.push(l)
				}
			})(t, t.onComment)),
		t
	)
}
var Dc = 256
function Lc(e, t) {
	return 2 | (e ? 4 : 0) | (t ? 8 : 0)
}
var Tc = function (e, t, s) {
		;(this.options = e = Oc(e)), (this.sourceFile = e.sourceFile), (this.keywords = wc(tc[e.ecmaVersion >= 6 ? 6 : 'module' === e.sourceType ? '5module' : 5]))
		var i = ''
		!0 !== e.allowReserved && ((i = Jl[e.ecmaVersion >= 6 ? 6 : 5 === e.ecmaVersion ? 5 : 3]), 'module' === e.sourceType && (i += ' await')), (this.reservedWords = wc(i))
		var n = (i ? i + ' ' : '') + Jl.strict
		;(this.reservedWordsStrict = wc(n)),
			(this.reservedWordsStrictBind = wc(n + ' ' + Jl.strictBind)),
			(this.input = String(t)),
			(this.containsEsc = !1),
			s
				? ((this.pos = s), (this.lineStart = this.input.lastIndexOf('\n', s - 1) + 1), (this.curLine = this.input.slice(0, this.lineStart).split(mc).length))
				: ((this.pos = this.lineStart = 0), (this.curLine = 1)),
			(this.type = fc.eof),
			(this.value = null),
			(this.start = this.end = this.pos),
			(this.startLoc = this.endLoc = this.curPosition()),
			(this.lastTokEndLoc = this.lastTokStartLoc = null),
			(this.lastTokStart = this.lastTokEnd = this.pos),
			(this.context = this.initialContext()),
			(this.exprAllowed = !0),
			(this.inModule = 'module' === e.sourceType),
			(this.strict = this.inModule || this.strictDirective(this.pos)),
			(this.potentialArrowAt = -1),
			(this.potentialArrowInForAwait = !1),
			(this.yieldPos = this.awaitPos = this.awaitIdentPos = 0),
			(this.labels = []),
			(this.undefinedExports = Object.create(null)),
			0 === this.pos && e.allowHashBang && '#!' === this.input.slice(0, 2) && this.skipLineComment(2),
			(this.scopeStack = []),
			this.enterScope(1),
			(this.regexpState = null),
			(this.privateNameStack = [])
	},
	Vc = {
		inFunction: { configurable: !0 },
		inGenerator: { configurable: !0 },
		inAsync: { configurable: !0 },
		canAwait: { configurable: !0 },
		allowSuper: { configurable: !0 },
		allowDirectSuper: { configurable: !0 },
		treatFunctionsAsVar: { configurable: !0 },
		allowNewDotTarget: { configurable: !0 },
		inClassStaticBlock: { configurable: !0 }
	}
;(Tc.prototype.parse = function () {
	var e = this.options.program || this.startNode()
	return this.nextToken(), this.parseTopLevel(e)
}),
	(Vc.inFunction.get = function () {
		return (2 & this.currentVarScope().flags) > 0
	}),
	(Vc.inGenerator.get = function () {
		return (8 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit
	}),
	(Vc.inAsync.get = function () {
		return (4 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit
	}),
	(Vc.canAwait.get = function () {
		for (var e = this.scopeStack.length - 1; e >= 0; e--) {
			var t = this.scopeStack[e]
			if (t.inClassFieldInit || t.flags & Dc) return !1
			if (2 & t.flags) return (4 & t.flags) > 0
		}
		return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
	}),
	(Vc.allowSuper.get = function () {
		var e = this.currentThisScope(),
			t = e.flags,
			s = e.inClassFieldInit
		return (64 & t) > 0 || s || this.options.allowSuperOutsideMethod
	}),
	(Vc.allowDirectSuper.get = function () {
		return (128 & this.currentThisScope().flags) > 0
	}),
	(Vc.treatFunctionsAsVar.get = function () {
		return this.treatFunctionsAsVarInScope(this.currentScope())
	}),
	(Vc.allowNewDotTarget.get = function () {
		var e = this.currentThisScope(),
			t = e.flags,
			s = e.inClassFieldInit
		return (258 & t) > 0 || s
	}),
	(Vc.inClassStaticBlock.get = function () {
		return (this.currentVarScope().flags & Dc) > 0
	}),
	(Tc.extend = function () {
		for (var e = [], t = arguments.length; t--; ) e[t] = arguments[t]
		for (var s = this, i = 0; i < e.length; i++) s = e[i](s)
		return s
	}),
	(Tc.parse = function (e, t) {
		return new this(t, e).parse()
	}),
	(Tc.parseExpressionAt = function (e, t, s) {
		var i = new this(s, e, t)
		return i.nextToken(), i.parseExpression()
	}),
	(Tc.tokenizer = function (e, t) {
		return new this(t, e)
	}),
	Object.defineProperties(Tc.prototype, Vc)
var Bc = Tc.prototype,
	zc = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/
;(Bc.strictDirective = function (e) {
	if (this.options.ecmaVersion < 5) return !1
	for (;;) {
		;(bc.lastIndex = e), (e += bc.exec(this.input)[0].length)
		var t = zc.exec(this.input.slice(e))
		if (!t) return !1
		if ('use strict' === (t[1] || t[2])) {
			bc.lastIndex = e + t[0].length
			var s = bc.exec(this.input),
				i = s.index + s[0].length,
				n = this.input.charAt(i)
			return ';' === n || '}' === n || (mc.test(s[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(n) || ('!' === n && '=' === this.input.charAt(i + 1))))
		}
		;(e += t[0].length), (bc.lastIndex = e), (e += bc.exec(this.input)[0].length), ';' === this.input[e] && e++
	}
}),
	(Bc.eat = function (e) {
		return this.type === e && (this.next(), !0)
	}),
	(Bc.isContextual = function (e) {
		return this.type === fc.name && this.value === e && !this.containsEsc
	}),
	(Bc.eatContextual = function (e) {
		return !!this.isContextual(e) && (this.next(), !0)
	}),
	(Bc.expectContextual = function (e) {
		this.eatContextual(e) || this.unexpected()
	}),
	(Bc.canInsertSemicolon = function () {
		return this.type === fc.eof || this.type === fc.braceR || mc.test(this.input.slice(this.lastTokEnd, this.start))
	}),
	(Bc.insertSemicolon = function () {
		if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0
	}),
	(Bc.semicolon = function () {
		this.eat(fc.semi) || this.insertSemicolon() || this.unexpected()
	}),
	(Bc.afterTrailingComma = function (e, t) {
		if (this.type === e) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0
	}),
	(Bc.expect = function (e) {
		this.eat(e) || this.unexpected()
	}),
	(Bc.unexpected = function (e) {
		this.raise(null != e ? e : this.start, 'Unexpected token')
	})
var Fc = function () {
	this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1
}
;(Bc.checkPatternErrors = function (e, t) {
	if (e) {
		e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, 'Comma is not permitted after the rest element')
		var s = t ? e.parenthesizedAssign : e.parenthesizedBind
		s > -1 && this.raiseRecoverable(s, t ? 'Assigning to rvalue' : 'Parenthesized pattern')
	}
}),
	(Bc.checkExpressionErrors = function (e, t) {
		if (!e) return !1
		var s = e.shorthandAssign,
			i = e.doubleProto
		if (!t) return s >= 0 || i >= 0
		s >= 0 && this.raise(s, 'Shorthand property assignments are valid only in destructuring patterns'), i >= 0 && this.raiseRecoverable(i, 'Redefinition of __proto__ property')
	}),
	(Bc.checkYieldAwaitInDefaultParams = function () {
		this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, 'Yield expression cannot be a default value'),
			this.awaitPos && this.raise(this.awaitPos, 'Await expression cannot be a default value')
	}),
	(Bc.isSimpleAssignTarget = function (e) {
		return 'ParenthesizedExpression' === e.type ? this.isSimpleAssignTarget(e.expression) : 'Identifier' === e.type || 'MemberExpression' === e.type
	})
var jc = Tc.prototype
jc.parseTopLevel = function (e) {
	var t = Object.create(null)
	for (e.body || (e.body = []); this.type !== fc.eof; ) {
		var s = this.parseStatement(null, !0, t)
		e.body.push(s)
	}
	if (this.inModule)
		for (var i = 0, n = Object.keys(this.undefinedExports); i < n.length; i += 1) {
			var r = n[i]
			this.raiseRecoverable(this.undefinedExports[r].start, "Export '" + r + "' is not defined")
		}
	return this.adaptDirectivePrologue(e.body), this.next(), (e.sourceType = this.options.sourceType), this.finishNode(e, 'Program')
}
var Uc = { kind: 'loop' },
	Gc = { kind: 'switch' }
;(jc.isLet = function (e) {
	if (this.options.ecmaVersion < 6 || !this.isContextual('let')) return !1
	bc.lastIndex = this.pos
	var t = bc.exec(this.input),
		s = this.pos + t[0].length,
		i = this.input.charCodeAt(s)
	if (91 === i || 92 === i) return !0
	if (e) return !1
	if (123 === i || (i > 55295 && i < 56320)) return !0
	if (oc(i, !0)) {
		for (var n = s + 1; ac((i = this.input.charCodeAt(n)), !0); ) ++n
		if (92 === i || (i > 55295 && i < 56320)) return !0
		var r = this.input.slice(s, n)
		if (!sc.test(r)) return !0
	}
	return !1
}),
	(jc.isAsyncFunction = function () {
		if (this.options.ecmaVersion < 8 || !this.isContextual('async')) return !1
		bc.lastIndex = this.pos
		var e,
			t = bc.exec(this.input),
			s = this.pos + t[0].length
		return !(
			mc.test(this.input.slice(this.pos, s)) ||
			'function' !== this.input.slice(s, s + 8) ||
			(s + 8 !== this.input.length && (ac((e = this.input.charCodeAt(s + 8))) || (e > 55295 && e < 56320)))
		)
	}),
	(jc.parseStatement = function (e, t, s) {
		var i,
			n = this.type,
			r = this.startNode()
		switch ((this.isLet(e) && ((n = fc._var), (i = 'let')), n)) {
			case fc._break:
			case fc._continue:
				return this.parseBreakContinueStatement(r, n.keyword)
			case fc._debugger:
				return this.parseDebuggerStatement(r)
			case fc._do:
				return this.parseDoStatement(r)
			case fc._for:
				return this.parseForStatement(r)
			case fc._function:
				return e && (this.strict || ('if' !== e && 'label' !== e)) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(r, !1, !e)
			case fc._class:
				return e && this.unexpected(), this.parseClass(r, !0)
			case fc._if:
				return this.parseIfStatement(r)
			case fc._return:
				return this.parseReturnStatement(r)
			case fc._switch:
				return this.parseSwitchStatement(r)
			case fc._throw:
				return this.parseThrowStatement(r)
			case fc._try:
				return this.parseTryStatement(r)
			case fc._const:
			case fc._var:
				return (i = i || this.value), e && 'var' !== i && this.unexpected(), this.parseVarStatement(r, i)
			case fc._while:
				return this.parseWhileStatement(r)
			case fc._with:
				return this.parseWithStatement(r)
			case fc.braceL:
				return this.parseBlock(!0, r)
			case fc.semi:
				return this.parseEmptyStatement(r)
			case fc._export:
			case fc._import:
				if (this.options.ecmaVersion > 10 && n === fc._import) {
					bc.lastIndex = this.pos
					var o = bc.exec(this.input),
						a = this.pos + o[0].length,
						l = this.input.charCodeAt(a)
					if (40 === l || 46 === l) return this.parseExpressionStatement(r, this.parseExpression())
				}
				return (
					this.options.allowImportExportEverywhere ||
						(t || this.raise(this.start, "'import' and 'export' may only appear at the top level"),
						this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")),
					n === fc._import ? this.parseImport(r) : this.parseExport(r, s)
				)
			default:
				if (this.isAsyncFunction()) return e && this.unexpected(), this.next(), this.parseFunctionStatement(r, !0, !e)
				var c = this.value,
					h = this.parseExpression()
				return n === fc.name && 'Identifier' === h.type && this.eat(fc.colon) ? this.parseLabeledStatement(r, c, h, e) : this.parseExpressionStatement(r, h)
		}
	}),
	(jc.parseBreakContinueStatement = function (e, t) {
		var s = 'break' === t
		this.next(), this.eat(fc.semi) || this.insertSemicolon() ? (e.label = null) : this.type !== fc.name ? this.unexpected() : ((e.label = this.parseIdent()), this.semicolon())
		for (var i = 0; i < this.labels.length; ++i) {
			var n = this.labels[i]
			if (null == e.label || n.name === e.label.name) {
				if (null != n.kind && (s || 'loop' === n.kind)) break
				if (e.label && s) break
			}
		}
		return i === this.labels.length && this.raise(e.start, 'Unsyntactic ' + t), this.finishNode(e, s ? 'BreakStatement' : 'ContinueStatement')
	}),
	(jc.parseDebuggerStatement = function (e) {
		return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement')
	}),
	(jc.parseDoStatement = function (e) {
		return (
			this.next(),
			this.labels.push(Uc),
			(e.body = this.parseStatement('do')),
			this.labels.pop(),
			this.expect(fc._while),
			(e.test = this.parseParenExpression()),
			this.options.ecmaVersion >= 6 ? this.eat(fc.semi) : this.semicolon(),
			this.finishNode(e, 'DoWhileStatement')
		)
	}),
	(jc.parseForStatement = function (e) {
		this.next()
		var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual('await') ? this.lastTokStart : -1
		if ((this.labels.push(Uc), this.enterScope(0), this.expect(fc.parenL), this.type === fc.semi)) return t > -1 && this.unexpected(t), this.parseFor(e, null)
		var s = this.isLet()
		if (this.type === fc._var || this.type === fc._const || s) {
			var i = this.startNode(),
				n = s ? 'let' : this.value
			return (
				this.next(),
				this.parseVar(i, !0, n),
				this.finishNode(i, 'VariableDeclaration'),
				(this.type === fc._in || (this.options.ecmaVersion >= 6 && this.isContextual('of'))) && 1 === i.declarations.length
					? (this.options.ecmaVersion >= 9 && (this.type === fc._in ? t > -1 && this.unexpected(t) : (e.await = t > -1)), this.parseForIn(e, i))
					: (t > -1 && this.unexpected(t), this.parseFor(e, i))
			)
		}
		var r = this.isContextual('let'),
			o = !1,
			a = new Fc(),
			l = this.parseExpression(!(t > -1) || 'await', a)
		return this.type === fc._in || (o = this.options.ecmaVersion >= 6 && this.isContextual('of'))
			? (this.options.ecmaVersion >= 9 && (this.type === fc._in ? t > -1 && this.unexpected(t) : (e.await = t > -1)),
			  r && o && this.raise(l.start, "The left-hand side of a for-of loop may not start with 'let'."),
			  this.toAssignable(l, !1, a),
			  this.checkLValPattern(l),
			  this.parseForIn(e, l))
			: (this.checkExpressionErrors(a, !0), t > -1 && this.unexpected(t), this.parseFor(e, l))
	}),
	(jc.parseFunctionStatement = function (e, t, s) {
		return this.next(), this.parseFunction(e, qc | (s ? 0 : Hc), !1, t)
	}),
	(jc.parseIfStatement = function (e) {
		return (
			this.next(),
			(e.test = this.parseParenExpression()),
			(e.consequent = this.parseStatement('if')),
			(e.alternate = this.eat(fc._else) ? this.parseStatement('if') : null),
			this.finishNode(e, 'IfStatement')
		)
	}),
	(jc.parseReturnStatement = function (e) {
		return (
			this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"),
			this.next(),
			this.eat(fc.semi) || this.insertSemicolon() ? (e.argument = null) : ((e.argument = this.parseExpression()), this.semicolon()),
			this.finishNode(e, 'ReturnStatement')
		)
	}),
	(jc.parseSwitchStatement = function (e) {
		var t
		this.next(), (e.discriminant = this.parseParenExpression()), (e.cases = []), this.expect(fc.braceL), this.labels.push(Gc), this.enterScope(0)
		for (var s = !1; this.type !== fc.braceR; )
			if (this.type === fc._case || this.type === fc._default) {
				var i = this.type === fc._case
				t && this.finishNode(t, 'SwitchCase'),
					e.cases.push((t = this.startNode())),
					(t.consequent = []),
					this.next(),
					i ? (t.test = this.parseExpression()) : (s && this.raiseRecoverable(this.lastTokStart, 'Multiple default clauses'), (s = !0), (t.test = null)),
					this.expect(fc.colon)
			} else t || this.unexpected(), t.consequent.push(this.parseStatement(null))
		return this.exitScope(), t && this.finishNode(t, 'SwitchCase'), this.next(), this.labels.pop(), this.finishNode(e, 'SwitchStatement')
	}),
	(jc.parseThrowStatement = function (e) {
		return (
			this.next(),
			mc.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, 'Illegal newline after throw'),
			(e.argument = this.parseExpression()),
			this.semicolon(),
			this.finishNode(e, 'ThrowStatement')
		)
	})
var Wc = []
;(jc.parseCatchClauseParam = function () {
	var e = this.parseBindingAtom(),
		t = 'Identifier' === e.type
	return this.enterScope(t ? 32 : 0), this.checkLValPattern(e, t ? 4 : 2), this.expect(fc.parenR), e
}),
	(jc.parseTryStatement = function (e) {
		if ((this.next(), (e.block = this.parseBlock()), (e.handler = null), this.type === fc._catch)) {
			var t = this.startNode()
			this.next(),
				this.eat(fc.parenL) ? (t.param = this.parseCatchClauseParam()) : (this.options.ecmaVersion < 10 && this.unexpected(), (t.param = null), this.enterScope(0)),
				(t.body = this.parseBlock(!1)),
				this.exitScope(),
				(e.handler = this.finishNode(t, 'CatchClause'))
		}
		return (e.finalizer = this.eat(fc._finally) ? this.parseBlock() : null), e.handler || e.finalizer || this.raise(e.start, 'Missing catch or finally clause'), this.finishNode(e, 'TryStatement')
	}),
	(jc.parseVarStatement = function (e, t, s) {
		return this.next(), this.parseVar(e, !1, t, s), this.semicolon(), this.finishNode(e, 'VariableDeclaration')
	}),
	(jc.parseWhileStatement = function (e) {
		return this.next(), (e.test = this.parseParenExpression()), this.labels.push(Uc), (e.body = this.parseStatement('while')), this.labels.pop(), this.finishNode(e, 'WhileStatement')
	}),
	(jc.parseWithStatement = function (e) {
		return (
			this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), (e.object = this.parseParenExpression()), (e.body = this.parseStatement('with')), this.finishNode(e, 'WithStatement')
		)
	}),
	(jc.parseEmptyStatement = function (e) {
		return this.next(), this.finishNode(e, 'EmptyStatement')
	}),
	(jc.parseLabeledStatement = function (e, t, s, i) {
		for (var n = 0, r = this.labels; n < r.length; n += 1) {
			r[n].name === t && this.raise(s.start, "Label '" + t + "' is already declared")
		}
		for (var o = this.type.isLoop ? 'loop' : this.type === fc._switch ? 'switch' : null, a = this.labels.length - 1; a >= 0; a--) {
			var l = this.labels[a]
			if (l.statementStart !== e.start) break
			;(l.statementStart = this.start), (l.kind = o)
		}
		return (
			this.labels.push({ name: t, kind: o, statementStart: this.start }),
			(e.body = this.parseStatement(i ? (-1 === i.indexOf('label') ? i + 'label' : i) : 'label')),
			this.labels.pop(),
			(e.label = s),
			this.finishNode(e, 'LabeledStatement')
		)
	}),
	(jc.parseExpressionStatement = function (e, t) {
		return (e.expression = t), this.semicolon(), this.finishNode(e, 'ExpressionStatement')
	}),
	(jc.parseBlock = function (e, t, s) {
		for (void 0 === e && (e = !0), void 0 === t && (t = this.startNode()), t.body = [], this.expect(fc.braceL), e && this.enterScope(0); this.type !== fc.braceR; ) {
			var i = this.parseStatement(null)
			t.body.push(i)
		}
		return s && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, 'BlockStatement')
	}),
	(jc.parseFor = function (e, t) {
		return (
			(e.init = t),
			this.expect(fc.semi),
			(e.test = this.type === fc.semi ? null : this.parseExpression()),
			this.expect(fc.semi),
			(e.update = this.type === fc.parenR ? null : this.parseExpression()),
			this.expect(fc.parenR),
			(e.body = this.parseStatement('for')),
			this.exitScope(),
			this.labels.pop(),
			this.finishNode(e, 'ForStatement')
		)
	}),
	(jc.parseForIn = function (e, t) {
		var s = this.type === fc._in
		return (
			this.next(),
			'VariableDeclaration' === t.type &&
				null != t.declarations[0].init &&
				(!s || this.options.ecmaVersion < 8 || this.strict || 'var' !== t.kind || 'Identifier' !== t.declarations[0].id.type) &&
				this.raise(t.start, (s ? 'for-in' : 'for-of') + ' loop variable declaration may not have an initializer'),
			(e.left = t),
			(e.right = s ? this.parseExpression() : this.parseMaybeAssign()),
			this.expect(fc.parenR),
			(e.body = this.parseStatement('for')),
			this.exitScope(),
			this.labels.pop(),
			this.finishNode(e, s ? 'ForInStatement' : 'ForOfStatement')
		)
	}),
	(jc.parseVar = function (e, t, s, i) {
		for (e.declarations = [], e.kind = s; ; ) {
			var n = this.startNode()
			if (
				(this.parseVarId(n, s),
				this.eat(fc.eq)
					? (n.init = this.parseMaybeAssign(t))
					: i || 'const' !== s || this.type === fc._in || (this.options.ecmaVersion >= 6 && this.isContextual('of'))
					? i || 'Identifier' === n.id.type || (t && (this.type === fc._in || this.isContextual('of')))
						? (n.init = null)
						: this.raise(this.lastTokEnd, 'Complex binding patterns require an initialization value')
					: this.unexpected(),
				e.declarations.push(this.finishNode(n, 'VariableDeclarator')),
				!this.eat(fc.comma))
			)
				break
		}
		return e
	}),
	(jc.parseVarId = function (e, t) {
		;(e.id = this.parseBindingAtom()), this.checkLValPattern(e.id, 'var' === t ? 1 : 2, !1)
	})
var qc = 1,
	Hc = 2
function Kc(e, t) {
	var s = t.key.name,
		i = e[s],
		n = 'true'
	return (
		'MethodDefinition' !== t.type || ('get' !== t.kind && 'set' !== t.kind) || (n = (t.static ? 's' : 'i') + t.kind),
		('iget' === i && 'iset' === n) || ('iset' === i && 'iget' === n) || ('sget' === i && 'sset' === n) || ('sset' === i && 'sget' === n) ? ((e[s] = 'true'), !1) : !!i || ((e[s] = n), !1)
	)
}
function Yc(e, t) {
	var s = e.computed,
		i = e.key
	return !s && (('Identifier' === i.type && i.name === t) || ('Literal' === i.type && i.value === t))
}
;(jc.parseFunction = function (e, t, s, i, n) {
	this.initFunction(e),
		(this.options.ecmaVersion >= 9 || (this.options.ecmaVersion >= 6 && !i)) && (this.type === fc.star && t & Hc && this.unexpected(), (e.generator = this.eat(fc.star))),
		this.options.ecmaVersion >= 8 && (e.async = !!i),
		t & qc &&
			((e.id = 4 & t && this.type !== fc.name ? null : this.parseIdent()),
			!e.id || t & Hc || this.checkLValSimple(e.id, this.strict || e.generator || e.async ? (this.treatFunctionsAsVar ? 1 : 2) : 3))
	var r = this.yieldPos,
		o = this.awaitPos,
		a = this.awaitIdentPos
	return (
		(this.yieldPos = 0),
		(this.awaitPos = 0),
		(this.awaitIdentPos = 0),
		this.enterScope(Lc(e.async, e.generator)),
		t & qc || (e.id = this.type === fc.name ? this.parseIdent() : null),
		this.parseFunctionParams(e),
		this.parseFunctionBody(e, s, !1, n),
		(this.yieldPos = r),
		(this.awaitPos = o),
		(this.awaitIdentPos = a),
		this.finishNode(e, t & qc ? 'FunctionDeclaration' : 'FunctionExpression')
	)
}),
	(jc.parseFunctionParams = function (e) {
		this.expect(fc.parenL), (e.params = this.parseBindingList(fc.parenR, !1, this.options.ecmaVersion >= 8)), this.checkYieldAwaitInDefaultParams()
	}),
	(jc.parseClass = function (e, t) {
		this.next()
		var s = this.strict
		;(this.strict = !0), this.parseClassId(e, t), this.parseClassSuper(e)
		var i = this.enterClassBody(),
			n = this.startNode(),
			r = !1
		for (n.body = [], this.expect(fc.braceL); this.type !== fc.braceR; ) {
			var o = this.parseClassElement(null !== e.superClass)
			o &&
				(n.body.push(o),
				'MethodDefinition' === o.type && 'constructor' === o.kind
					? (r && this.raiseRecoverable(o.start, 'Duplicate constructor in the same class'), (r = !0))
					: o.key && 'PrivateIdentifier' === o.key.type && Kc(i, o) && this.raiseRecoverable(o.key.start, "Identifier '#" + o.key.name + "' has already been declared"))
		}
		return (this.strict = s), this.next(), (e.body = this.finishNode(n, 'ClassBody')), this.exitClassBody(), this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression')
	}),
	(jc.parseClassElement = function (e) {
		if (this.eat(fc.semi)) return null
		var t = this.options.ecmaVersion,
			s = this.startNode(),
			i = '',
			n = !1,
			r = !1,
			o = 'method',
			a = !1
		if (this.eatContextual('static')) {
			if (t >= 13 && this.eat(fc.braceL)) return this.parseClassStaticBlock(s), s
			this.isClassElementNameStart() || this.type === fc.star ? (a = !0) : (i = 'static')
		}
		if (
			((s.static = a),
			!i && t >= 8 && this.eatContextual('async') && ((!this.isClassElementNameStart() && this.type !== fc.star) || this.canInsertSemicolon() ? (i = 'async') : (r = !0)),
			!i && (t >= 9 || !r) && this.eat(fc.star) && (n = !0),
			!i && !r && !n)
		) {
			var l = this.value
			;(this.eatContextual('get') || this.eatContextual('set')) && (this.isClassElementNameStart() ? (o = l) : (i = l))
		}
		if (
			(i ? ((s.computed = !1), (s.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc)), (s.key.name = i), this.finishNode(s.key, 'Identifier')) : this.parseClassElementName(s),
			t < 13 || this.type === fc.parenL || 'method' !== o || n || r)
		) {
			var c = !s.static && Yc(s, 'constructor'),
				h = c && e
			c && 'method' !== o && this.raise(s.key.start, "Constructor can't have get/set modifier"), (s.kind = c ? 'constructor' : o), this.parseClassMethod(s, n, r, h)
		} else this.parseClassField(s)
		return s
	}),
	(jc.isClassElementNameStart = function () {
		return this.type === fc.name || this.type === fc.privateId || this.type === fc.num || this.type === fc.string || this.type === fc.bracketL || this.type.keyword
	}),
	(jc.parseClassElementName = function (e) {
		this.type === fc.privateId
			? ('constructor' === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), (e.computed = !1), (e.key = this.parsePrivateIdent()))
			: this.parsePropertyName(e)
	}),
	(jc.parseClassMethod = function (e, t, s, i) {
		var n = e.key
		'constructor' === e.kind
			? (t && this.raise(n.start, "Constructor can't be a generator"), s && this.raise(n.start, "Constructor can't be an async method"))
			: e.static && Yc(e, 'prototype') && this.raise(n.start, 'Classes may not have a static property named prototype')
		var r = (e.value = this.parseMethod(t, s, i))
		return (
			'get' === e.kind && 0 !== r.params.length && this.raiseRecoverable(r.start, 'getter should have no params'),
			'set' === e.kind && 1 !== r.params.length && this.raiseRecoverable(r.start, 'setter should have exactly one param'),
			'set' === e.kind && 'RestElement' === r.params[0].type && this.raiseRecoverable(r.params[0].start, 'Setter cannot use rest params'),
			this.finishNode(e, 'MethodDefinition')
		)
	}),
	(jc.parseClassField = function (e) {
		if (
			(Yc(e, 'constructor')
				? this.raise(e.key.start, "Classes can't have a field named 'constructor'")
				: e.static && Yc(e, 'prototype') && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"),
			this.eat(fc.eq))
		) {
			var t = this.currentThisScope(),
				s = t.inClassFieldInit
			;(t.inClassFieldInit = !0), (e.value = this.parseMaybeAssign()), (t.inClassFieldInit = s)
		} else e.value = null
		return this.semicolon(), this.finishNode(e, 'PropertyDefinition')
	}),
	(jc.parseClassStaticBlock = function (e) {
		e.body = []
		var t = this.labels
		for (this.labels = [], this.enterScope(320); this.type !== fc.braceR; ) {
			var s = this.parseStatement(null)
			e.body.push(s)
		}
		return this.next(), this.exitScope(), (this.labels = t), this.finishNode(e, 'StaticBlock')
	}),
	(jc.parseClassId = function (e, t) {
		this.type === fc.name ? ((e.id = this.parseIdent()), t && this.checkLValSimple(e.id, 2, !1)) : (!0 === t && this.unexpected(), (e.id = null))
	}),
	(jc.parseClassSuper = function (e) {
		e.superClass = this.eat(fc._extends) ? this.parseExprSubscripts(null, !1) : null
	}),
	(jc.enterClassBody = function () {
		var e = { declared: Object.create(null), used: [] }
		return this.privateNameStack.push(e), e.declared
	}),
	(jc.exitClassBody = function () {
		var e = this.privateNameStack.pop(),
			t = e.declared,
			s = e.used
		if (this.options.checkPrivateFields)
			for (var i = this.privateNameStack.length, n = 0 === i ? null : this.privateNameStack[i - 1], r = 0; r < s.length; ++r) {
				var o = s[r]
				kc(t, o.name) || (n ? n.used.push(o) : this.raiseRecoverable(o.start, "Private field '#" + o.name + "' must be declared in an enclosing class"))
			}
	}),
	(jc.parseExportAllDeclaration = function (e, t) {
		return (
			this.options.ecmaVersion >= 11 && (this.eatContextual('as') ? ((e.exported = this.parseModuleExportName()), this.checkExport(t, e.exported, this.lastTokStart)) : (e.exported = null)),
			this.expectContextual('from'),
			this.type !== fc.string && this.unexpected(),
			(e.source = this.parseExprAtom()),
			this.semicolon(),
			this.finishNode(e, 'ExportAllDeclaration')
		)
	}),
	(jc.parseExport = function (e, t) {
		if ((this.next(), this.eat(fc.star))) return this.parseExportAllDeclaration(e, t)
		if (this.eat(fc._default)) return this.checkExport(t, 'default', this.lastTokStart), (e.declaration = this.parseExportDefaultDeclaration()), this.finishNode(e, 'ExportDefaultDeclaration')
		if (this.shouldParseExportStatement())
			(e.declaration = this.parseExportDeclaration(e)),
				'VariableDeclaration' === e.declaration.type ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start),
				(e.specifiers = []),
				(e.source = null)
		else {
			if (((e.declaration = null), (e.specifiers = this.parseExportSpecifiers(t)), this.eatContextual('from'))) this.type !== fc.string && this.unexpected(), (e.source = this.parseExprAtom())
			else {
				for (var s = 0, i = e.specifiers; s < i.length; s += 1) {
					var n = i[s]
					this.checkUnreserved(n.local),
						this.checkLocalExport(n.local),
						'Literal' === n.local.type && this.raise(n.local.start, 'A string literal cannot be used as an exported binding without `from`.')
				}
				e.source = null
			}
			this.semicolon()
		}
		return this.finishNode(e, 'ExportNamedDeclaration')
	}),
	(jc.parseExportDeclaration = function (e) {
		return this.parseStatement(null)
	}),
	(jc.parseExportDefaultDeclaration = function () {
		var e
		if (this.type === fc._function || (e = this.isAsyncFunction())) {
			var t = this.startNode()
			return this.next(), e && this.next(), this.parseFunction(t, 4 | qc, !1, e)
		}
		if (this.type === fc._class) {
			var s = this.startNode()
			return this.parseClass(s, 'nullableID')
		}
		var i = this.parseMaybeAssign()
		return this.semicolon(), i
	}),
	(jc.checkExport = function (e, t, s) {
		e && ('string' != typeof t && (t = 'Identifier' === t.type ? t.name : t.value), kc(e, t) && this.raiseRecoverable(s, "Duplicate export '" + t + "'"), (e[t] = !0))
	}),
	(jc.checkPatternExport = function (e, t) {
		var s = t.type
		if ('Identifier' === s) this.checkExport(e, t, t.start)
		else if ('ObjectPattern' === s)
			for (var i = 0, n = t.properties; i < n.length; i += 1) {
				var r = n[i]
				this.checkPatternExport(e, r)
			}
		else if ('ArrayPattern' === s)
			for (var o = 0, a = t.elements; o < a.length; o += 1) {
				var l = a[o]
				l && this.checkPatternExport(e, l)
			}
		else
			'Property' === s
				? this.checkPatternExport(e, t.value)
				: 'AssignmentPattern' === s
				? this.checkPatternExport(e, t.left)
				: 'RestElement' === s
				? this.checkPatternExport(e, t.argument)
				: 'ParenthesizedExpression' === s && this.checkPatternExport(e, t.expression)
	}),
	(jc.checkVariableExport = function (e, t) {
		if (e)
			for (var s = 0, i = t; s < i.length; s += 1) {
				var n = i[s]
				this.checkPatternExport(e, n.id)
			}
	}),
	(jc.shouldParseExportStatement = function () {
		return 'var' === this.type.keyword || 'const' === this.type.keyword || 'class' === this.type.keyword || 'function' === this.type.keyword || this.isLet() || this.isAsyncFunction()
	}),
	(jc.parseExportSpecifier = function (e) {
		var t = this.startNode()
		return (
			(t.local = this.parseModuleExportName()),
			(t.exported = this.eatContextual('as') ? this.parseModuleExportName() : t.local),
			this.checkExport(e, t.exported, t.exported.start),
			this.finishNode(t, 'ExportSpecifier')
		)
	}),
	(jc.parseExportSpecifiers = function (e) {
		var t = [],
			s = !0
		for (this.expect(fc.braceL); !this.eat(fc.braceR); ) {
			if (s) s = !1
			else if ((this.expect(fc.comma), this.afterTrailingComma(fc.braceR))) break
			t.push(this.parseExportSpecifier(e))
		}
		return t
	}),
	(jc.parseImport = function (e) {
		return (
			this.next(),
			this.type === fc.string
				? ((e.specifiers = Wc), (e.source = this.parseExprAtom()))
				: ((e.specifiers = this.parseImportSpecifiers()), this.expectContextual('from'), (e.source = this.type === fc.string ? this.parseExprAtom() : this.unexpected())),
			this.semicolon(),
			this.finishNode(e, 'ImportDeclaration')
		)
	}),
	(jc.parseImportSpecifier = function () {
		var e = this.startNode()
		return (
			(e.imported = this.parseModuleExportName()),
			this.eatContextual('as') ? (e.local = this.parseIdent()) : (this.checkUnreserved(e.imported), (e.local = e.imported)),
			this.checkLValSimple(e.local, 2),
			this.finishNode(e, 'ImportSpecifier')
		)
	}),
	(jc.parseImportDefaultSpecifier = function () {
		var e = this.startNode()
		return (e.local = this.parseIdent()), this.checkLValSimple(e.local, 2), this.finishNode(e, 'ImportDefaultSpecifier')
	}),
	(jc.parseImportNamespaceSpecifier = function () {
		var e = this.startNode()
		return this.next(), this.expectContextual('as'), (e.local = this.parseIdent()), this.checkLValSimple(e.local, 2), this.finishNode(e, 'ImportNamespaceSpecifier')
	}),
	(jc.parseImportSpecifiers = function () {
		var e = [],
			t = !0
		if (this.type === fc.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(fc.comma))) return e
		if (this.type === fc.star) return e.push(this.parseImportNamespaceSpecifier()), e
		for (this.expect(fc.braceL); !this.eat(fc.braceR); ) {
			if (t) t = !1
			else if ((this.expect(fc.comma), this.afterTrailingComma(fc.braceR))) break
			e.push(this.parseImportSpecifier())
		}
		return e
	}),
	(jc.parseModuleExportName = function () {
		if (this.options.ecmaVersion >= 13 && this.type === fc.string) {
			var e = this.parseLiteral(this.value)
			return Cc.test(e.value) && this.raise(e.start, 'An export name cannot include a lone surrogate.'), e
		}
		return this.parseIdent(!0)
	}),
	(jc.adaptDirectivePrologue = function (e) {
		for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t) e[t].directive = e[t].expression.raw.slice(1, -1)
	}),
	(jc.isDirectiveCandidate = function (e) {
		return (
			this.options.ecmaVersion >= 5 &&
			'ExpressionStatement' === e.type &&
			'Literal' === e.expression.type &&
			'string' == typeof e.expression.value &&
			('"' === this.input[e.start] || "'" === this.input[e.start])
		)
	})
var Xc = Tc.prototype
;(Xc.toAssignable = function (e, t, s) {
	if (this.options.ecmaVersion >= 6 && e)
		switch (e.type) {
			case 'Identifier':
				this.inAsync && 'await' === e.name && this.raise(e.start, "Cannot use 'await' as identifier inside an async function")
				break
			case 'ObjectPattern':
			case 'ArrayPattern':
			case 'AssignmentPattern':
			case 'RestElement':
				break
			case 'ObjectExpression':
				;(e.type = 'ObjectPattern'), s && this.checkPatternErrors(s, !0)
				for (var i = 0, n = e.properties; i < n.length; i += 1) {
					var r = n[i]
					this.toAssignable(r, t), 'RestElement' !== r.type || ('ArrayPattern' !== r.argument.type && 'ObjectPattern' !== r.argument.type) || this.raise(r.argument.start, 'Unexpected token')
				}
				break
			case 'Property':
				'init' !== e.kind && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t)
				break
			case 'ArrayExpression':
				;(e.type = 'ArrayPattern'), s && this.checkPatternErrors(s, !0), this.toAssignableList(e.elements, t)
				break
			case 'SpreadElement':
				;(e.type = 'RestElement'), this.toAssignable(e.argument, t), 'AssignmentPattern' === e.argument.type && this.raise(e.argument.start, 'Rest elements cannot have a default value')
				break
			case 'AssignmentExpression':
				'=' !== e.operator && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), (e.type = 'AssignmentPattern'), delete e.operator, this.toAssignable(e.left, t)
				break
			case 'ParenthesizedExpression':
				this.toAssignable(e.expression, t, s)
				break
			case 'ChainExpression':
				this.raiseRecoverable(e.start, 'Optional chaining cannot appear in left-hand side')
				break
			case 'MemberExpression':
				if (!t) break
			default:
				this.raise(e.start, 'Assigning to rvalue')
		}
	else s && this.checkPatternErrors(s, !0)
	return e
}),
	(Xc.toAssignableList = function (e, t) {
		for (var s = e.length, i = 0; i < s; i++) {
			var n = e[i]
			n && this.toAssignable(n, t)
		}
		if (s) {
			var r = e[s - 1]
			6 === this.options.ecmaVersion && t && r && 'RestElement' === r.type && 'Identifier' !== r.argument.type && this.unexpected(r.argument.start)
		}
		return e
	}),
	(Xc.parseSpread = function (e) {
		var t = this.startNode()
		return this.next(), (t.argument = this.parseMaybeAssign(!1, e)), this.finishNode(t, 'SpreadElement')
	}),
	(Xc.parseRestBinding = function () {
		var e = this.startNode()
		return this.next(), 6 === this.options.ecmaVersion && this.type !== fc.name && this.unexpected(), (e.argument = this.parseBindingAtom()), this.finishNode(e, 'RestElement')
	}),
	(Xc.parseBindingAtom = function () {
		if (this.options.ecmaVersion >= 6)
			switch (this.type) {
				case fc.bracketL:
					var e = this.startNode()
					return this.next(), (e.elements = this.parseBindingList(fc.bracketR, !0, !0)), this.finishNode(e, 'ArrayPattern')
				case fc.braceL:
					return this.parseObj(!0)
			}
		return this.parseIdent()
	}),
	(Xc.parseBindingList = function (e, t, s, i) {
		for (var n = [], r = !0; !this.eat(e); )
			if ((r ? (r = !1) : this.expect(fc.comma), t && this.type === fc.comma)) n.push(null)
			else {
				if (s && this.afterTrailingComma(e)) break
				if (this.type === fc.ellipsis) {
					var o = this.parseRestBinding()
					this.parseBindingListItem(o), n.push(o), this.type === fc.comma && this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element'), this.expect(e)
					break
				}
				n.push(this.parseAssignableListItem(i))
			}
		return n
	}),
	(Xc.parseAssignableListItem = function (e) {
		var t = this.parseMaybeDefault(this.start, this.startLoc)
		return this.parseBindingListItem(t), t
	}),
	(Xc.parseBindingListItem = function (e) {
		return e
	}),
	(Xc.parseMaybeDefault = function (e, t, s) {
		if (((s = s || this.parseBindingAtom()), this.options.ecmaVersion < 6 || !this.eat(fc.eq))) return s
		var i = this.startNodeAt(e, t)
		return (i.left = s), (i.right = this.parseMaybeAssign()), this.finishNode(i, 'AssignmentPattern')
	}),
	(Xc.checkLValSimple = function (e, t, s) {
		void 0 === t && (t = 0)
		var i = 0 !== t
		switch (e.type) {
			case 'Identifier':
				this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (i ? 'Binding ' : 'Assigning to ') + e.name + ' in strict mode'),
					i &&
						(2 === t && 'let' === e.name && this.raiseRecoverable(e.start, 'let is disallowed as a lexically bound name'),
						s && (kc(s, e.name) && this.raiseRecoverable(e.start, 'Argument name clash'), (s[e.name] = !0)),
						5 !== t && this.declareName(e.name, t, e.start))
				break
			case 'ChainExpression':
				this.raiseRecoverable(e.start, 'Optional chaining cannot appear in left-hand side')
				break
			case 'MemberExpression':
				i && this.raiseRecoverable(e.start, 'Binding member expression')
				break
			case 'ParenthesizedExpression':
				return i && this.raiseRecoverable(e.start, 'Binding parenthesized expression'), this.checkLValSimple(e.expression, t, s)
			default:
				this.raise(e.start, (i ? 'Binding' : 'Assigning to') + ' rvalue')
		}
	}),
	(Xc.checkLValPattern = function (e, t, s) {
		switch ((void 0 === t && (t = 0), e.type)) {
			case 'ObjectPattern':
				for (var i = 0, n = e.properties; i < n.length; i += 1) {
					var r = n[i]
					this.checkLValInnerPattern(r, t, s)
				}
				break
			case 'ArrayPattern':
				for (var o = 0, a = e.elements; o < a.length; o += 1) {
					var l = a[o]
					l && this.checkLValInnerPattern(l, t, s)
				}
				break
			default:
				this.checkLValSimple(e, t, s)
		}
	}),
	(Xc.checkLValInnerPattern = function (e, t, s) {
		switch ((void 0 === t && (t = 0), e.type)) {
			case 'Property':
				this.checkLValInnerPattern(e.value, t, s)
				break
			case 'AssignmentPattern':
				this.checkLValPattern(e.left, t, s)
				break
			case 'RestElement':
				this.checkLValPattern(e.argument, t, s)
				break
			default:
				this.checkLValPattern(e, t, s)
		}
	})
var Qc = function (e, t, s, i, n) {
		;(this.token = e), (this.isExpr = !!t), (this.preserveSpace = !!s), (this.override = i), (this.generator = !!n)
	},
	Zc = {
		b_stat: new Qc('{', !1),
		b_expr: new Qc('{', !0),
		b_tmpl: new Qc('${', !1),
		p_stat: new Qc('(', !1),
		p_expr: new Qc('(', !0),
		q_tmpl: new Qc('`', !0, !0, function (e) {
			return e.tryReadTemplateToken()
		}),
		f_stat: new Qc('function', !1),
		f_expr: new Qc('function', !0),
		f_expr_gen: new Qc('function', !0, !1, null, !0),
		f_gen: new Qc('function', !1, !1, null, !0)
	},
	Jc = Tc.prototype
;(Jc.initialContext = function () {
	return [Zc.b_stat]
}),
	(Jc.curContext = function () {
		return this.context[this.context.length - 1]
	}),
	(Jc.braceIsBlock = function (e) {
		var t = this.curContext()
		return (
			t === Zc.f_expr ||
			t === Zc.f_stat ||
			(e !== fc.colon || (t !== Zc.b_stat && t !== Zc.b_expr)
				? e === fc._return || (e === fc.name && this.exprAllowed)
					? mc.test(this.input.slice(this.lastTokEnd, this.start))
					: e === fc._else ||
					  e === fc.semi ||
					  e === fc.eof ||
					  e === fc.parenR ||
					  e === fc.arrow ||
					  (e === fc.braceL ? t === Zc.b_stat : e !== fc._var && e !== fc._const && e !== fc.name && !this.exprAllowed)
				: !t.isExpr)
		)
	}),
	(Jc.inGeneratorContext = function () {
		for (var e = this.context.length - 1; e >= 1; e--) {
			var t = this.context[e]
			if ('function' === t.token) return t.generator
		}
		return !1
	}),
	(Jc.updateContext = function (e) {
		var t,
			s = this.type
		s.keyword && e === fc.dot ? (this.exprAllowed = !1) : (t = s.updateContext) ? t.call(this, e) : (this.exprAllowed = s.beforeExpr)
	}),
	(Jc.overrideContext = function (e) {
		this.curContext() !== e && (this.context[this.context.length - 1] = e)
	}),
	(fc.parenR.updateContext = fc.braceR.updateContext =
		function () {
			if (1 !== this.context.length) {
				var e = this.context.pop()
				e === Zc.b_stat && 'function' === this.curContext().token && (e = this.context.pop()), (this.exprAllowed = !e.isExpr)
			} else this.exprAllowed = !0
		}),
	(fc.braceL.updateContext = function (e) {
		this.context.push(this.braceIsBlock(e) ? Zc.b_stat : Zc.b_expr), (this.exprAllowed = !0)
	}),
	(fc.dollarBraceL.updateContext = function () {
		this.context.push(Zc.b_tmpl), (this.exprAllowed = !0)
	}),
	(fc.parenL.updateContext = function (e) {
		var t = e === fc._if || e === fc._for || e === fc._with || e === fc._while
		this.context.push(t ? Zc.p_stat : Zc.p_expr), (this.exprAllowed = !0)
	}),
	(fc.incDec.updateContext = function () {}),
	(fc._function.updateContext = fc._class.updateContext =
		function (e) {
			!e.beforeExpr ||
			e === fc._else ||
			(e === fc.semi && this.curContext() !== Zc.p_stat) ||
			(e === fc._return && mc.test(this.input.slice(this.lastTokEnd, this.start))) ||
			((e === fc.colon || e === fc.braceL) && this.curContext() === Zc.b_stat)
				? this.context.push(Zc.f_stat)
				: this.context.push(Zc.f_expr),
				(this.exprAllowed = !1)
		}),
	(fc.backQuote.updateContext = function () {
		this.curContext() === Zc.q_tmpl ? this.context.pop() : this.context.push(Zc.q_tmpl), (this.exprAllowed = !1)
	}),
	(fc.star.updateContext = function (e) {
		if (e === fc._function) {
			var t = this.context.length - 1
			this.context[t] === Zc.f_expr ? (this.context[t] = Zc.f_expr_gen) : (this.context[t] = Zc.f_gen)
		}
		this.exprAllowed = !0
	}),
	(fc.name.updateContext = function (e) {
		var t = !1
		this.options.ecmaVersion >= 6 && e !== fc.dot && (('of' === this.value && !this.exprAllowed) || ('yield' === this.value && this.inGeneratorContext())) && (t = !0), (this.exprAllowed = t)
	})
var eh = Tc.prototype
function th(e) {
	return ('MemberExpression' === e.type && 'PrivateIdentifier' === e.property.type) || ('ChainExpression' === e.type && th(e.expression))
}
;(eh.checkPropClash = function (e, t, s) {
	if (!((this.options.ecmaVersion >= 9 && 'SpreadElement' === e.type) || (this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand)))) {
		var i,
			n = e.key
		switch (n.type) {
			case 'Identifier':
				i = n.name
				break
			case 'Literal':
				i = String(n.value)
				break
			default:
				return
		}
		var r = e.kind
		if (this.options.ecmaVersion >= 6)
			'__proto__' === i && 'init' === r && (t.proto && (s ? s.doubleProto < 0 && (s.doubleProto = n.start) : this.raiseRecoverable(n.start, 'Redefinition of __proto__ property')), (t.proto = !0))
		else {
			var o = t[(i = '$' + i)]
			if (o) ('init' === r ? (this.strict && o.init) || o.get || o.set : o.init || o[r]) && this.raiseRecoverable(n.start, 'Redefinition of property')
			else o = t[i] = { init: !1, get: !1, set: !1 }
			o[r] = !0
		}
	}
}),
	(eh.parseExpression = function (e, t) {
		var s = this.start,
			i = this.startLoc,
			n = this.parseMaybeAssign(e, t)
		if (this.type === fc.comma) {
			var r = this.startNodeAt(s, i)
			for (r.expressions = [n]; this.eat(fc.comma); ) r.expressions.push(this.parseMaybeAssign(e, t))
			return this.finishNode(r, 'SequenceExpression')
		}
		return n
	}),
	(eh.parseMaybeAssign = function (e, t, s) {
		if (this.isContextual('yield')) {
			if (this.inGenerator) return this.parseYield(e)
			this.exprAllowed = !1
		}
		var i = !1,
			n = -1,
			r = -1,
			o = -1
		t ? ((n = t.parenthesizedAssign), (r = t.trailingComma), (o = t.doubleProto), (t.parenthesizedAssign = t.trailingComma = -1)) : ((t = new Fc()), (i = !0))
		var a = this.start,
			l = this.startLoc
		;(this.type !== fc.parenL && this.type !== fc.name) || ((this.potentialArrowAt = this.start), (this.potentialArrowInForAwait = 'await' === e))
		var c = this.parseMaybeConditional(e, t)
		if ((s && (c = s.call(this, c, a, l)), this.type.isAssign)) {
			var h = this.startNodeAt(a, l)
			return (
				(h.operator = this.value),
				this.type === fc.eq && (c = this.toAssignable(c, !1, t)),
				i || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1),
				t.shorthandAssign >= c.start && (t.shorthandAssign = -1),
				this.type === fc.eq ? this.checkLValPattern(c) : this.checkLValSimple(c),
				(h.left = c),
				this.next(),
				(h.right = this.parseMaybeAssign(e)),
				o > -1 && (t.doubleProto = o),
				this.finishNode(h, 'AssignmentExpression')
			)
		}
		return i && this.checkExpressionErrors(t, !0), n > -1 && (t.parenthesizedAssign = n), r > -1 && (t.trailingComma = r), c
	}),
	(eh.parseMaybeConditional = function (e, t) {
		var s = this.start,
			i = this.startLoc,
			n = this.parseExprOps(e, t)
		if (this.checkExpressionErrors(t)) return n
		if (this.eat(fc.question)) {
			var r = this.startNodeAt(s, i)
			return (r.test = n), (r.consequent = this.parseMaybeAssign()), this.expect(fc.colon), (r.alternate = this.parseMaybeAssign(e)), this.finishNode(r, 'ConditionalExpression')
		}
		return n
	}),
	(eh.parseExprOps = function (e, t) {
		var s = this.start,
			i = this.startLoc,
			n = this.parseMaybeUnary(t, !1, !1, e)
		return this.checkExpressionErrors(t) || (n.start === s && 'ArrowFunctionExpression' === n.type) ? n : this.parseExprOp(n, s, i, -1, e)
	}),
	(eh.parseExprOp = function (e, t, s, i, n) {
		var r = this.type.binop
		if (null != r && (!n || this.type !== fc._in) && r > i) {
			var o = this.type === fc.logicalOR || this.type === fc.logicalAND,
				a = this.type === fc.coalesce
			a && (r = fc.logicalAND.binop)
			var l = this.value
			this.next()
			var c = this.start,
				h = this.startLoc,
				u = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, n), c, h, r, n),
				d = this.buildBinary(t, s, e, u, l, o || a)
			return (
				((o && this.type === fc.coalesce) || (a && (this.type === fc.logicalOR || this.type === fc.logicalAND))) &&
					this.raiseRecoverable(this.start, 'Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses'),
				this.parseExprOp(d, t, s, i, n)
			)
		}
		return e
	}),
	(eh.buildBinary = function (e, t, s, i, n, r) {
		'PrivateIdentifier' === i.type && this.raise(i.start, 'Private identifier can only be left side of binary expression')
		var o = this.startNodeAt(e, t)
		return (o.left = s), (o.operator = n), (o.right = i), this.finishNode(o, r ? 'LogicalExpression' : 'BinaryExpression')
	}),
	(eh.parseMaybeUnary = function (e, t, s, i) {
		var n,
			r = this.start,
			o = this.startLoc
		if (this.isContextual('await') && this.canAwait) (n = this.parseAwait(i)), (t = !0)
		else if (this.type.prefix) {
			var a = this.startNode(),
				l = this.type === fc.incDec
			;(a.operator = this.value),
				(a.prefix = !0),
				this.next(),
				(a.argument = this.parseMaybeUnary(null, !0, l, i)),
				this.checkExpressionErrors(e, !0),
				l
					? this.checkLValSimple(a.argument)
					: this.strict && 'delete' === a.operator && 'Identifier' === a.argument.type
					? this.raiseRecoverable(a.start, 'Deleting local variable in strict mode')
					: 'delete' === a.operator && th(a.argument)
					? this.raiseRecoverable(a.start, 'Private fields can not be deleted')
					: (t = !0),
				(n = this.finishNode(a, l ? 'UpdateExpression' : 'UnaryExpression'))
		} else if (t || this.type !== fc.privateId) {
			if (((n = this.parseExprSubscripts(e, i)), this.checkExpressionErrors(e))) return n
			for (; this.type.postfix && !this.canInsertSemicolon(); ) {
				var c = this.startNodeAt(r, o)
				;(c.operator = this.value), (c.prefix = !1), (c.argument = n), this.checkLValSimple(n), this.next(), (n = this.finishNode(c, 'UpdateExpression'))
			}
		} else (i || 0 === this.privateNameStack.length) && this.options.checkPrivateFields && this.unexpected(), (n = this.parsePrivateIdent()), this.type !== fc._in && this.unexpected()
		return s || !this.eat(fc.starstar) ? n : t ? void this.unexpected(this.lastTokStart) : this.buildBinary(r, o, n, this.parseMaybeUnary(null, !1, !1, i), '**', !1)
	}),
	(eh.parseExprSubscripts = function (e, t) {
		var s = this.start,
			i = this.startLoc,
			n = this.parseExprAtom(e, t)
		if ('ArrowFunctionExpression' === n.type && ')' !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return n
		var r = this.parseSubscripts(n, s, i, !1, t)
		return (
			e &&
				'MemberExpression' === r.type &&
				(e.parenthesizedAssign >= r.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= r.start && (e.parenthesizedBind = -1), e.trailingComma >= r.start && (e.trailingComma = -1)),
			r
		)
	}),
	(eh.parseSubscripts = function (e, t, s, i, n) {
		for (
			var r =
					this.options.ecmaVersion >= 8 &&
					'Identifier' === e.type &&
					'async' === e.name &&
					this.lastTokEnd === e.end &&
					!this.canInsertSemicolon() &&
					e.end - e.start == 5 &&
					this.potentialArrowAt === e.start,
				o = !1;
			;

		) {
			var a = this.parseSubscript(e, t, s, i, r, o, n)
			if ((a.optional && (o = !0), a === e || 'ArrowFunctionExpression' === a.type)) {
				if (o) {
					var l = this.startNodeAt(t, s)
					;(l.expression = a), (a = this.finishNode(l, 'ChainExpression'))
				}
				return a
			}
			e = a
		}
	}),
	(eh.shouldParseAsyncArrow = function () {
		return !this.canInsertSemicolon() && this.eat(fc.arrow)
	}),
	(eh.parseSubscriptAsyncArrow = function (e, t, s, i) {
		return this.parseArrowExpression(this.startNodeAt(e, t), s, !0, i)
	}),
	(eh.parseSubscript = function (e, t, s, i, n, r, o) {
		var a = this.options.ecmaVersion >= 11,
			l = a && this.eat(fc.questionDot)
		i && l && this.raise(this.lastTokStart, 'Optional chaining cannot appear in the callee of new expressions')
		var c = this.eat(fc.bracketL)
		if (c || (l && this.type !== fc.parenL && this.type !== fc.backQuote) || this.eat(fc.dot)) {
			var h = this.startNodeAt(t, s)
			;(h.object = e),
				c
					? ((h.property = this.parseExpression()), this.expect(fc.bracketR))
					: this.type === fc.privateId && 'Super' !== e.type
					? (h.property = this.parsePrivateIdent())
					: (h.property = this.parseIdent('never' !== this.options.allowReserved)),
				(h.computed = !!c),
				a && (h.optional = l),
				(e = this.finishNode(h, 'MemberExpression'))
		} else if (!i && this.eat(fc.parenL)) {
			var u = new Fc(),
				d = this.yieldPos,
				p = this.awaitPos,
				f = this.awaitIdentPos
			;(this.yieldPos = 0), (this.awaitPos = 0), (this.awaitIdentPos = 0)
			var m = this.parseExprList(fc.parenR, this.options.ecmaVersion >= 8, !1, u)
			if (n && !l && this.shouldParseAsyncArrow())
				return (
					this.checkPatternErrors(u, !1),
					this.checkYieldAwaitInDefaultParams(),
					this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"),
					(this.yieldPos = d),
					(this.awaitPos = p),
					(this.awaitIdentPos = f),
					this.parseSubscriptAsyncArrow(t, s, m, o)
				)
			this.checkExpressionErrors(u, !0), (this.yieldPos = d || this.yieldPos), (this.awaitPos = p || this.awaitPos), (this.awaitIdentPos = f || this.awaitIdentPos)
			var g = this.startNodeAt(t, s)
			;(g.callee = e), (g.arguments = m), a && (g.optional = l), (e = this.finishNode(g, 'CallExpression'))
		} else if (this.type === fc.backQuote) {
			;(l || r) && this.raise(this.start, 'Optional chaining cannot appear in the tag of tagged template expressions')
			var y = this.startNodeAt(t, s)
			;(y.tag = e), (y.quasi = this.parseTemplate({ isTagged: !0 })), (e = this.finishNode(y, 'TaggedTemplateExpression'))
		}
		return e
	}),
	(eh.parseExprAtom = function (e, t, s) {
		this.type === fc.slash && this.readRegexp()
		var i,
			n = this.potentialArrowAt === this.start
		switch (this.type) {
			case fc._super:
				return (
					this.allowSuper || this.raise(this.start, "'super' keyword outside a method"),
					(i = this.startNode()),
					this.next(),
					this.type !== fc.parenL || this.allowDirectSuper || this.raise(i.start, 'super() call outside constructor of a subclass'),
					this.type !== fc.dot && this.type !== fc.bracketL && this.type !== fc.parenL && this.unexpected(),
					this.finishNode(i, 'Super')
				)
			case fc._this:
				return (i = this.startNode()), this.next(), this.finishNode(i, 'ThisExpression')
			case fc.name:
				var r = this.start,
					o = this.startLoc,
					a = this.containsEsc,
					l = this.parseIdent(!1)
				if (this.options.ecmaVersion >= 8 && !a && 'async' === l.name && !this.canInsertSemicolon() && this.eat(fc._function))
					return this.overrideContext(Zc.f_expr), this.parseFunction(this.startNodeAt(r, o), 0, !1, !0, t)
				if (n && !this.canInsertSemicolon()) {
					if (this.eat(fc.arrow)) return this.parseArrowExpression(this.startNodeAt(r, o), [l], !1, t)
					if (this.options.ecmaVersion >= 8 && 'async' === l.name && this.type === fc.name && !a && (!this.potentialArrowInForAwait || 'of' !== this.value || this.containsEsc))
						return (l = this.parseIdent(!1)), (!this.canInsertSemicolon() && this.eat(fc.arrow)) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(r, o), [l], !0, t)
				}
				return l
			case fc.regexp:
				var c = this.value
				return ((i = this.parseLiteral(c.value)).regex = { pattern: c.pattern, flags: c.flags }), i
			case fc.num:
			case fc.string:
				return this.parseLiteral(this.value)
			case fc._null:
			case fc._true:
			case fc._false:
				return ((i = this.startNode()).value = this.type === fc._null ? null : this.type === fc._true), (i.raw = this.type.keyword), this.next(), this.finishNode(i, 'Literal')
			case fc.parenL:
				var h = this.start,
					u = this.parseParenAndDistinguishExpression(n, t)
				return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u) && (e.parenthesizedAssign = h), e.parenthesizedBind < 0 && (e.parenthesizedBind = h)), u
			case fc.bracketL:
				return (i = this.startNode()), this.next(), (i.elements = this.parseExprList(fc.bracketR, !0, !0, e)), this.finishNode(i, 'ArrayExpression')
			case fc.braceL:
				return this.overrideContext(Zc.b_expr), this.parseObj(!1, e)
			case fc._function:
				return (i = this.startNode()), this.next(), this.parseFunction(i, 0)
			case fc._class:
				return this.parseClass(this.startNode(), !1)
			case fc._new:
				return this.parseNew()
			case fc.backQuote:
				return this.parseTemplate()
			case fc._import:
				return this.options.ecmaVersion >= 11 ? this.parseExprImport(s) : this.unexpected()
			default:
				return this.parseExprAtomDefault()
		}
	}),
	(eh.parseExprAtomDefault = function () {
		this.unexpected()
	}),
	(eh.parseExprImport = function (e) {
		var t = this.startNode()
		this.containsEsc && this.raiseRecoverable(this.start, 'Escape sequence in keyword import')
		var s = this.parseIdent(!0)
		return this.type !== fc.parenL || e ? (this.type === fc.dot ? ((t.meta = s), this.parseImportMeta(t)) : void this.unexpected()) : this.parseDynamicImport(t)
	}),
	(eh.parseDynamicImport = function (e) {
		if ((this.next(), (e.source = this.parseMaybeAssign()), !this.eat(fc.parenR))) {
			var t = this.start
			this.eat(fc.comma) && this.eat(fc.parenR) ? this.raiseRecoverable(t, 'Trailing comma is not allowed in import()') : this.unexpected(t)
		}
		return this.finishNode(e, 'ImportExpression')
	}),
	(eh.parseImportMeta = function (e) {
		this.next()
		var t = this.containsEsc
		return (
			(e.property = this.parseIdent(!0)),
			'meta' !== e.property.name && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"),
			t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"),
			'module' === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"),
			this.finishNode(e, 'MetaProperty')
		)
	}),
	(eh.parseLiteral = function (e) {
		var t = this.startNode()
		return (
			(t.value = e),
			(t.raw = this.input.slice(this.start, this.end)),
			110 === t.raw.charCodeAt(t.raw.length - 1) && (t.bigint = t.raw.slice(0, -1).replace(/_/g, '')),
			this.next(),
			this.finishNode(t, 'Literal')
		)
	}),
	(eh.parseParenExpression = function () {
		this.expect(fc.parenL)
		var e = this.parseExpression()
		return this.expect(fc.parenR), e
	}),
	(eh.shouldParseArrow = function (e) {
		return !this.canInsertSemicolon()
	}),
	(eh.parseParenAndDistinguishExpression = function (e, t) {
		var s,
			i = this.start,
			n = this.startLoc,
			r = this.options.ecmaVersion >= 8
		if (this.options.ecmaVersion >= 6) {
			this.next()
			var o,
				a = this.start,
				l = this.startLoc,
				c = [],
				h = !0,
				u = !1,
				d = new Fc(),
				p = this.yieldPos,
				f = this.awaitPos
			for (this.yieldPos = 0, this.awaitPos = 0; this.type !== fc.parenR; ) {
				if ((h ? (h = !1) : this.expect(fc.comma), r && this.afterTrailingComma(fc.parenR, !0))) {
					u = !0
					break
				}
				if (this.type === fc.ellipsis) {
					;(o = this.start), c.push(this.parseParenItem(this.parseRestBinding())), this.type === fc.comma && this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element')
					break
				}
				c.push(this.parseMaybeAssign(!1, d, this.parseParenItem))
			}
			var m = this.lastTokEnd,
				g = this.lastTokEndLoc
			if ((this.expect(fc.parenR), e && this.shouldParseArrow(c) && this.eat(fc.arrow)))
				return this.checkPatternErrors(d, !1), this.checkYieldAwaitInDefaultParams(), (this.yieldPos = p), (this.awaitPos = f), this.parseParenArrowList(i, n, c, t)
			;(c.length && !u) || this.unexpected(this.lastTokStart),
				o && this.unexpected(o),
				this.checkExpressionErrors(d, !0),
				(this.yieldPos = p || this.yieldPos),
				(this.awaitPos = f || this.awaitPos),
				c.length > 1 ? (((s = this.startNodeAt(a, l)).expressions = c), this.finishNodeAt(s, 'SequenceExpression', m, g)) : (s = c[0])
		} else s = this.parseParenExpression()
		if (this.options.preserveParens) {
			var y = this.startNodeAt(i, n)
			return (y.expression = s), this.finishNode(y, 'ParenthesizedExpression')
		}
		return s
	}),
	(eh.parseParenItem = function (e) {
		return e
	}),
	(eh.parseParenArrowList = function (e, t, s, i) {
		return this.parseArrowExpression(this.startNodeAt(e, t), s, !1, i)
	})
var sh = []
;(eh.parseNew = function () {
	this.containsEsc && this.raiseRecoverable(this.start, 'Escape sequence in keyword new')
	var e = this.startNode(),
		t = this.parseIdent(!0)
	if (this.options.ecmaVersion >= 6 && this.eat(fc.dot)) {
		e.meta = t
		var s = this.containsEsc
		return (
			(e.property = this.parseIdent(!0)),
			'target' !== e.property.name && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"),
			s && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"),
			this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"),
			this.finishNode(e, 'MetaProperty')
		)
	}
	var i = this.start,
		n = this.startLoc
	return (
		(e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), i, n, !0, !1)),
		this.eat(fc.parenL) ? (e.arguments = this.parseExprList(fc.parenR, this.options.ecmaVersion >= 8, !1)) : (e.arguments = sh),
		this.finishNode(e, 'NewExpression')
	)
}),
	(eh.parseTemplateElement = function (e) {
		var t = e.isTagged,
			s = this.startNode()
		return (
			this.type === fc.invalidTemplate
				? (t || this.raiseRecoverable(this.start, 'Bad escape sequence in untagged template literal'), (s.value = { raw: this.value, cooked: null }))
				: (s.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'), cooked: this.value }),
			this.next(),
			(s.tail = this.type === fc.backQuote),
			this.finishNode(s, 'TemplateElement')
		)
	}),
	(eh.parseTemplate = function (e) {
		void 0 === e && (e = {})
		var t = e.isTagged
		void 0 === t && (t = !1)
		var s = this.startNode()
		this.next(), (s.expressions = [])
		var i = this.parseTemplateElement({ isTagged: t })
		for (s.quasis = [i]; !i.tail; )
			this.type === fc.eof && this.raise(this.pos, 'Unterminated template literal'),
				this.expect(fc.dollarBraceL),
				s.expressions.push(this.parseExpression()),
				this.expect(fc.braceR),
				s.quasis.push((i = this.parseTemplateElement({ isTagged: t })))
		return this.next(), this.finishNode(s, 'TemplateLiteral')
	}),
	(eh.isAsyncProp = function (e) {
		return (
			!e.computed &&
			'Identifier' === e.key.type &&
			'async' === e.key.name &&
			(this.type === fc.name || this.type === fc.num || this.type === fc.string || this.type === fc.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === fc.star)) &&
			!mc.test(this.input.slice(this.lastTokEnd, this.start))
		)
	}),
	(eh.parseObj = function (e, t) {
		var s = this.startNode(),
			i = !0,
			n = {}
		for (s.properties = [], this.next(); !this.eat(fc.braceR); ) {
			if (i) i = !1
			else if ((this.expect(fc.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(fc.braceR))) break
			var r = this.parseProperty(e, t)
			e || this.checkPropClash(r, n, t), s.properties.push(r)
		}
		return this.finishNode(s, e ? 'ObjectPattern' : 'ObjectExpression')
	}),
	(eh.parseProperty = function (e, t) {
		var s,
			i,
			n,
			r,
			o = this.startNode()
		if (this.options.ecmaVersion >= 9 && this.eat(fc.ellipsis))
			return e
				? ((o.argument = this.parseIdent(!1)), this.type === fc.comma && this.raiseRecoverable(this.start, 'Comma is not permitted after the rest element'), this.finishNode(o, 'RestElement'))
				: ((o.argument = this.parseMaybeAssign(!1, t)), this.type === fc.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(o, 'SpreadElement'))
		this.options.ecmaVersion >= 6 && ((o.method = !1), (o.shorthand = !1), (e || t) && ((n = this.start), (r = this.startLoc)), e || (s = this.eat(fc.star)))
		var a = this.containsEsc
		return (
			this.parsePropertyName(o),
			!e && !a && this.options.ecmaVersion >= 8 && !s && this.isAsyncProp(o) ? ((i = !0), (s = this.options.ecmaVersion >= 9 && this.eat(fc.star)), this.parsePropertyName(o)) : (i = !1),
			this.parsePropertyValue(o, e, s, i, n, r, t, a),
			this.finishNode(o, 'Property')
		)
	}),
	(eh.parseGetterSetter = function (e) {
		;(e.kind = e.key.name), this.parsePropertyName(e), (e.value = this.parseMethod(!1))
		var t = 'get' === e.kind ? 0 : 1
		if (e.value.params.length !== t) {
			var s = e.value.start
			'get' === e.kind ? this.raiseRecoverable(s, 'getter should have no params') : this.raiseRecoverable(s, 'setter should have exactly one param')
		} else 'set' === e.kind && 'RestElement' === e.value.params[0].type && this.raiseRecoverable(e.value.params[0].start, 'Setter cannot use rest params')
	}),
	(eh.parsePropertyValue = function (e, t, s, i, n, r, o, a) {
		;(s || i) && this.type === fc.colon && this.unexpected(),
			this.eat(fc.colon)
				? ((e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, o)), (e.kind = 'init'))
				: this.options.ecmaVersion >= 6 && this.type === fc.parenL
				? (t && this.unexpected(), (e.kind = 'init'), (e.method = !0), (e.value = this.parseMethod(s, i)))
				: t ||
				  a ||
				  !(this.options.ecmaVersion >= 5) ||
				  e.computed ||
				  'Identifier' !== e.key.type ||
				  ('get' !== e.key.name && 'set' !== e.key.name) ||
				  this.type === fc.comma ||
				  this.type === fc.braceR ||
				  this.type === fc.eq
				? this.options.ecmaVersion >= 6 && !e.computed && 'Identifier' === e.key.type
					? ((s || i) && this.unexpected(),
					  this.checkUnreserved(e.key),
					  'await' !== e.key.name || this.awaitIdentPos || (this.awaitIdentPos = n),
					  (e.kind = 'init'),
					  t
							? (e.value = this.parseMaybeDefault(n, r, this.copyNode(e.key)))
							: this.type === fc.eq && o
							? (o.shorthandAssign < 0 && (o.shorthandAssign = this.start), (e.value = this.parseMaybeDefault(n, r, this.copyNode(e.key))))
							: (e.value = this.copyNode(e.key)),
					  (e.shorthand = !0))
					: this.unexpected()
				: ((s || i) && this.unexpected(), this.parseGetterSetter(e))
	}),
	(eh.parsePropertyName = function (e) {
		if (this.options.ecmaVersion >= 6) {
			if (this.eat(fc.bracketL)) return (e.computed = !0), (e.key = this.parseMaybeAssign()), this.expect(fc.bracketR), e.key
			e.computed = !1
		}
		return (e.key = this.type === fc.num || this.type === fc.string ? this.parseExprAtom() : this.parseIdent('never' !== this.options.allowReserved))
	}),
	(eh.initFunction = function (e) {
		;(e.id = null), this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1)
	}),
	(eh.parseMethod = function (e, t, s) {
		var i = this.startNode(),
			n = this.yieldPos,
			r = this.awaitPos,
			o = this.awaitIdentPos
		return (
			this.initFunction(i),
			this.options.ecmaVersion >= 6 && (i.generator = e),
			this.options.ecmaVersion >= 8 && (i.async = !!t),
			(this.yieldPos = 0),
			(this.awaitPos = 0),
			(this.awaitIdentPos = 0),
			this.enterScope(64 | Lc(t, i.generator) | (s ? 128 : 0)),
			this.expect(fc.parenL),
			(i.params = this.parseBindingList(fc.parenR, !1, this.options.ecmaVersion >= 8)),
			this.checkYieldAwaitInDefaultParams(),
			this.parseFunctionBody(i, !1, !0, !1),
			(this.yieldPos = n),
			(this.awaitPos = r),
			(this.awaitIdentPos = o),
			this.finishNode(i, 'FunctionExpression')
		)
	}),
	(eh.parseArrowExpression = function (e, t, s, i) {
		var n = this.yieldPos,
			r = this.awaitPos,
			o = this.awaitIdentPos
		return (
			this.enterScope(16 | Lc(s, !1)),
			this.initFunction(e),
			this.options.ecmaVersion >= 8 && (e.async = !!s),
			(this.yieldPos = 0),
			(this.awaitPos = 0),
			(this.awaitIdentPos = 0),
			(e.params = this.toAssignableList(t, !0)),
			this.parseFunctionBody(e, !0, !1, i),
			(this.yieldPos = n),
			(this.awaitPos = r),
			(this.awaitIdentPos = o),
			this.finishNode(e, 'ArrowFunctionExpression')
		)
	}),
	(eh.parseFunctionBody = function (e, t, s, i) {
		var n = t && this.type !== fc.braceL,
			r = this.strict,
			o = !1
		if (n) (e.body = this.parseMaybeAssign(i)), (e.expression = !0), this.checkParams(e, !1)
		else {
			var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params)
			;(r && !a) || ((o = this.strictDirective(this.end)) && a && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"))
			var l = this.labels
			;(this.labels = []),
				o && (this.strict = !0),
				this.checkParams(e, !r && !o && !t && !s && this.isSimpleParamList(e.params)),
				this.strict && e.id && this.checkLValSimple(e.id, 5),
				(e.body = this.parseBlock(!1, void 0, o && !r)),
				(e.expression = !1),
				this.adaptDirectivePrologue(e.body.body),
				(this.labels = l)
		}
		this.exitScope()
	}),
	(eh.isSimpleParamList = function (e) {
		for (var t = 0, s = e; t < s.length; t += 1) {
			if ('Identifier' !== s[t].type) return !1
		}
		return !0
	}),
	(eh.checkParams = function (e, t) {
		for (var s = Object.create(null), i = 0, n = e.params; i < n.length; i += 1) {
			var r = n[i]
			this.checkLValInnerPattern(r, 1, t ? null : s)
		}
	}),
	(eh.parseExprList = function (e, t, s, i) {
		for (var n = [], r = !0; !this.eat(e); ) {
			if (r) r = !1
			else if ((this.expect(fc.comma), t && this.afterTrailingComma(e))) break
			var o = void 0
			s && this.type === fc.comma
				? (o = null)
				: this.type === fc.ellipsis
				? ((o = this.parseSpread(i)), i && this.type === fc.comma && i.trailingComma < 0 && (i.trailingComma = this.start))
				: (o = this.parseMaybeAssign(!1, i)),
				n.push(o)
		}
		return n
	}),
	(eh.checkUnreserved = function (e) {
		var t = e.start,
			s = e.end,
			i = e.name
		;(this.inGenerator && 'yield' === i && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"),
		this.inAsync && 'await' === i && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"),
		this.currentThisScope().inClassFieldInit && 'arguments' === i && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"),
		!this.inClassStaticBlock || ('arguments' !== i && 'await' !== i) || this.raise(t, 'Cannot use ' + i + ' in class static initialization block'),
		this.keywords.test(i) && this.raise(t, "Unexpected keyword '" + i + "'"),
		this.options.ecmaVersion < 6 && -1 !== this.input.slice(t, s).indexOf('\\')) ||
			((this.strict ? this.reservedWordsStrict : this.reservedWords).test(i) &&
				(this.inAsync || 'await' !== i || this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + i + "' is reserved")))
	}),
	(eh.parseIdent = function (e) {
		var t = this.parseIdentNode()
		return this.next(!!e), this.finishNode(t, 'Identifier'), e || (this.checkUnreserved(t), 'await' !== t.name || this.awaitIdentPos || (this.awaitIdentPos = t.start)), t
	}),
	(eh.parseIdentNode = function () {
		var e = this.startNode()
		return (
			this.type === fc.name
				? (e.name = this.value)
				: this.type.keyword
				? ((e.name = this.type.keyword),
				  ('class' !== e.name && 'function' !== e.name) || (this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart)) || this.context.pop())
				: this.unexpected(),
			e
		)
	}),
	(eh.parsePrivateIdent = function () {
		var e = this.startNode()
		return (
			this.type === fc.privateId ? (e.name = this.value) : this.unexpected(),
			this.next(),
			this.finishNode(e, 'PrivateIdentifier'),
			this.options.checkPrivateFields &&
				(0 === this.privateNameStack.length
					? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class")
					: this.privateNameStack[this.privateNameStack.length - 1].used.push(e)),
			e
		)
	}),
	(eh.parseYield = function (e) {
		this.yieldPos || (this.yieldPos = this.start)
		var t = this.startNode()
		return (
			this.next(),
			this.type === fc.semi || this.canInsertSemicolon() || (this.type !== fc.star && !this.type.startsExpr)
				? ((t.delegate = !1), (t.argument = null))
				: ((t.delegate = this.eat(fc.star)), (t.argument = this.parseMaybeAssign(e))),
			this.finishNode(t, 'YieldExpression')
		)
	}),
	(eh.parseAwait = function (e) {
		this.awaitPos || (this.awaitPos = this.start)
		var t = this.startNode()
		return this.next(), (t.argument = this.parseMaybeUnary(null, !0, !1, e)), this.finishNode(t, 'AwaitExpression')
	})
var ih = Tc.prototype
;(ih.raise = function (e, t) {
	var s = _c(this.input, e)
	t += ' (' + s.line + ':' + s.column + ')'
	var i = new SyntaxError(t)
	throw ((i.pos = e), (i.loc = s), (i.raisedAt = this.pos), i)
}),
	(ih.raiseRecoverable = ih.raise),
	(ih.curPosition = function () {
		if (this.options.locations) return new $c(this.curLine, this.pos - this.lineStart)
	})
var nh = Tc.prototype,
	rh = function (e) {
		;(this.flags = e), (this.var = []), (this.lexical = []), (this.functions = []), (this.inClassFieldInit = !1)
	}
;(nh.enterScope = function (e) {
	this.scopeStack.push(new rh(e))
}),
	(nh.exitScope = function () {
		this.scopeStack.pop()
	}),
	(nh.treatFunctionsAsVarInScope = function (e) {
		return 2 & e.flags || (!this.inModule && 1 & e.flags)
	}),
	(nh.declareName = function (e, t, s) {
		var i = !1
		if (2 === t) {
			var n = this.currentScope()
			;(i = n.lexical.indexOf(e) > -1 || n.functions.indexOf(e) > -1 || n.var.indexOf(e) > -1), n.lexical.push(e), this.inModule && 1 & n.flags && delete this.undefinedExports[e]
		} else if (4 === t) {
			this.currentScope().lexical.push(e)
		} else if (3 === t) {
			var r = this.currentScope()
			;(i = this.treatFunctionsAsVar ? r.lexical.indexOf(e) > -1 : r.lexical.indexOf(e) > -1 || r.var.indexOf(e) > -1), r.functions.push(e)
		} else
			for (var o = this.scopeStack.length - 1; o >= 0; --o) {
				var a = this.scopeStack[o]
				if ((a.lexical.indexOf(e) > -1 && !(32 & a.flags && a.lexical[0] === e)) || (!this.treatFunctionsAsVarInScope(a) && a.functions.indexOf(e) > -1)) {
					i = !0
					break
				}
				if ((a.var.push(e), this.inModule && 1 & a.flags && delete this.undefinedExports[e], 259 & a.flags)) break
			}
		i && this.raiseRecoverable(s, "Identifier '" + e + "' has already been declared")
	}),
	(nh.checkLocalExport = function (e) {
		;-1 === this.scopeStack[0].lexical.indexOf(e.name) && -1 === this.scopeStack[0].var.indexOf(e.name) && (this.undefinedExports[e.name] = e)
	}),
	(nh.currentScope = function () {
		return this.scopeStack[this.scopeStack.length - 1]
	}),
	(nh.currentVarScope = function () {
		for (var e = this.scopeStack.length - 1; ; e--) {
			var t = this.scopeStack[e]
			if (259 & t.flags) return t
		}
	}),
	(nh.currentThisScope = function () {
		for (var e = this.scopeStack.length - 1; ; e--) {
			var t = this.scopeStack[e]
			if (259 & t.flags && !(16 & t.flags)) return t
		}
	})
var oh = function (e, t, s) {
		;(this.type = ''),
			(this.start = t),
			(this.end = 0),
			e.options.locations && (this.loc = new Nc(e, s)),
			e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile),
			e.options.ranges && (this.range = [t, 0])
	},
	ah = Tc.prototype
function lh(e, t, s, i) {
	return (e.type = t), (e.end = s), this.options.locations && (e.loc.end = i), this.options.ranges && (e.range[1] = s), e
}
;(ah.startNode = function () {
	return new oh(this, this.start, this.startLoc)
}),
	(ah.startNodeAt = function (e, t) {
		return new oh(this, e, t)
	}),
	(ah.finishNode = function (e, t) {
		return lh.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc)
	}),
	(ah.finishNodeAt = function (e, t, s, i) {
		return lh.call(this, e, t, s, i)
	}),
	(ah.copyNode = function (e) {
		var t = new oh(this, e.start, this.startLoc)
		for (var s in e) t[s] = e[s]
		return t
	})
var ch =
		'ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS',
	hh = ch + ' Extended_Pictographic',
	uh = hh + ' EBase EComp EMod EPres ExtPict',
	dh = { 9: ch, 10: hh, 11: hh, 12: uh, 13: uh, 14: uh },
	ph = { 9: '', 10: '', 11: '', 12: '', 13: '', 14: 'Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji' },
	fh =
		'Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu',
	mh =
		'Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb',
	gh = mh + ' Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd',
	yh = gh + ' Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho',
	xh = yh + ' Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi',
	Eh = xh + ' Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith',
	bh = { 9: mh, 10: gh, 11: yh, 12: xh, 13: Eh, 14: Eh + ' Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz' },
	vh = {}
function Sh(e) {
	var t = (vh[e] = { binary: wc(dh[e] + ' ' + fh), binaryOfStrings: wc(ph[e]), nonBinary: { General_Category: wc(fh), Script: wc(bh[e]) } })
	;(t.nonBinary.Script_Extensions = t.nonBinary.Script), (t.nonBinary.gc = t.nonBinary.General_Category), (t.nonBinary.sc = t.nonBinary.Script), (t.nonBinary.scx = t.nonBinary.Script_Extensions)
}
for (var Ah = 0, kh = [9, 10, 11, 12, 13, 14]; Ah < kh.length; Ah += 1) {
	Sh(kh[Ah])
}
var Ih = Tc.prototype,
	wh = function (e) {
		;(this.parser = e),
			(this.validFlags =
				'gim' + (e.options.ecmaVersion >= 6 ? 'uy' : '') + (e.options.ecmaVersion >= 9 ? 's' : '') + (e.options.ecmaVersion >= 13 ? 'd' : '') + (e.options.ecmaVersion >= 15 ? 'v' : '')),
			(this.unicodeProperties = vh[e.options.ecmaVersion >= 14 ? 14 : e.options.ecmaVersion]),
			(this.source = ''),
			(this.flags = ''),
			(this.start = 0),
			(this.switchU = !1),
			(this.switchV = !1),
			(this.switchN = !1),
			(this.pos = 0),
			(this.lastIntValue = 0),
			(this.lastStringValue = ''),
			(this.lastAssertionIsQuantifiable = !1),
			(this.numCapturingParens = 0),
			(this.maxBackReference = 0),
			(this.groupNames = []),
			(this.backReferenceNames = [])
	}
function Ph(e) {
	return 36 === e || (e >= 40 && e <= 43) || 46 === e || 63 === e || (e >= 91 && e <= 94) || (e >= 123 && e <= 125)
}
function Ch(e) {
	return (e >= 65 && e <= 90) || (e >= 97 && e <= 122)
}
;(wh.prototype.reset = function (e, t, s) {
	var i = -1 !== s.indexOf('v'),
		n = -1 !== s.indexOf('u')
	;(this.start = 0 | e),
		(this.source = t + ''),
		(this.flags = s),
		i && this.parser.options.ecmaVersion >= 15
			? ((this.switchU = !0), (this.switchV = !0), (this.switchN = !0))
			: ((this.switchU = n && this.parser.options.ecmaVersion >= 6), (this.switchV = !1), (this.switchN = n && this.parser.options.ecmaVersion >= 9))
}),
	(wh.prototype.raise = function (e) {
		this.parser.raiseRecoverable(this.start, 'Invalid regular expression: /' + this.source + '/: ' + e)
	}),
	(wh.prototype.at = function (e, t) {
		void 0 === t && (t = !1)
		var s = this.source,
			i = s.length
		if (e >= i) return -1
		var n = s.charCodeAt(e)
		if ((!t && !this.switchU) || n <= 55295 || n >= 57344 || e + 1 >= i) return n
		var r = s.charCodeAt(e + 1)
		return r >= 56320 && r <= 57343 ? (n << 10) + r - 56613888 : n
	}),
	(wh.prototype.nextIndex = function (e, t) {
		void 0 === t && (t = !1)
		var s = this.source,
			i = s.length
		if (e >= i) return i
		var n,
			r = s.charCodeAt(e)
		return (!t && !this.switchU) || r <= 55295 || r >= 57344 || e + 1 >= i || (n = s.charCodeAt(e + 1)) < 56320 || n > 57343 ? e + 1 : e + 2
	}),
	(wh.prototype.current = function (e) {
		return void 0 === e && (e = !1), this.at(this.pos, e)
	}),
	(wh.prototype.lookahead = function (e) {
		return void 0 === e && (e = !1), this.at(this.nextIndex(this.pos, e), e)
	}),
	(wh.prototype.advance = function (e) {
		void 0 === e && (e = !1), (this.pos = this.nextIndex(this.pos, e))
	}),
	(wh.prototype.eat = function (e, t) {
		return void 0 === t && (t = !1), this.current(t) === e && (this.advance(t), !0)
	}),
	(wh.prototype.eatChars = function (e, t) {
		void 0 === t && (t = !1)
		for (var s = this.pos, i = 0, n = e; i < n.length; i += 1) {
			var r = n[i],
				o = this.at(s, t)
			if (-1 === o || o !== r) return !1
			s = this.nextIndex(s, t)
		}
		return (this.pos = s), !0
	}),
	(Ih.validateRegExpFlags = function (e) {
		for (var t = e.validFlags, s = e.flags, i = !1, n = !1, r = 0; r < s.length; r++) {
			var o = s.charAt(r)
			;-1 === t.indexOf(o) && this.raise(e.start, 'Invalid regular expression flag'),
				s.indexOf(o, r + 1) > -1 && this.raise(e.start, 'Duplicate regular expression flag'),
				'u' === o && (i = !0),
				'v' === o && (n = !0)
		}
		this.options.ecmaVersion >= 15 && i && n && this.raise(e.start, 'Invalid regular expression flag')
	}),
	(Ih.validateRegExpPattern = function (e) {
		this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0 && ((e.switchN = !0), this.regexp_pattern(e))
	}),
	(Ih.regexp_pattern = function (e) {
		;(e.pos = 0),
			(e.lastIntValue = 0),
			(e.lastStringValue = ''),
			(e.lastAssertionIsQuantifiable = !1),
			(e.numCapturingParens = 0),
			(e.maxBackReference = 0),
			(e.groupNames.length = 0),
			(e.backReferenceNames.length = 0),
			this.regexp_disjunction(e),
			e.pos !== e.source.length && (e.eat(41) && e.raise("Unmatched ')'"), (e.eat(93) || e.eat(125)) && e.raise('Lone quantifier brackets')),
			e.maxBackReference > e.numCapturingParens && e.raise('Invalid escape')
		for (var t = 0, s = e.backReferenceNames; t < s.length; t += 1) {
			var i = s[t]
			;-1 === e.groupNames.indexOf(i) && e.raise('Invalid named capture referenced')
		}
	}),
	(Ih.regexp_disjunction = function (e) {
		for (this.regexp_alternative(e); e.eat(124); ) this.regexp_alternative(e)
		this.regexp_eatQuantifier(e, !0) && e.raise('Nothing to repeat'), e.eat(123) && e.raise('Lone quantifier brackets')
	}),
	(Ih.regexp_alternative = function (e) {
		for (; e.pos < e.source.length && this.regexp_eatTerm(e); );
	}),
	(Ih.regexp_eatTerm = function (e) {
		return this.regexp_eatAssertion(e)
			? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise('Invalid quantifier'), !0)
			: !!(e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) && (this.regexp_eatQuantifier(e), !0)
	}),
	(Ih.regexp_eatAssertion = function (e) {
		var t = e.pos
		if (((e.lastAssertionIsQuantifiable = !1), e.eat(94) || e.eat(36))) return !0
		if (e.eat(92)) {
			if (e.eat(66) || e.eat(98)) return !0
			e.pos = t
		}
		if (e.eat(40) && e.eat(63)) {
			var s = !1
			if ((this.options.ecmaVersion >= 9 && (s = e.eat(60)), e.eat(61) || e.eat(33)))
				return this.regexp_disjunction(e), e.eat(41) || e.raise('Unterminated group'), (e.lastAssertionIsQuantifiable = !s), !0
		}
		return (e.pos = t), !1
	}),
	(Ih.regexp_eatQuantifier = function (e, t) {
		return void 0 === t && (t = !1), !!this.regexp_eatQuantifierPrefix(e, t) && (e.eat(63), !0)
	}),
	(Ih.regexp_eatQuantifierPrefix = function (e, t) {
		return e.eat(42) || e.eat(43) || e.eat(63) || this.regexp_eatBracedQuantifier(e, t)
	}),
	(Ih.regexp_eatBracedQuantifier = function (e, t) {
		var s = e.pos
		if (e.eat(123)) {
			var i = 0,
				n = -1
			if (this.regexp_eatDecimalDigits(e) && ((i = e.lastIntValue), e.eat(44) && this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue), e.eat(125)))
				return -1 !== n && n < i && !t && e.raise('numbers out of order in {} quantifier'), !0
			e.switchU && !t && e.raise('Incomplete quantifier'), (e.pos = s)
		}
		return !1
	}),
	(Ih.regexp_eatAtom = function (e) {
		return (
			this.regexp_eatPatternCharacters(e) ||
			e.eat(46) ||
			this.regexp_eatReverseSolidusAtomEscape(e) ||
			this.regexp_eatCharacterClass(e) ||
			this.regexp_eatUncapturingGroup(e) ||
			this.regexp_eatCapturingGroup(e)
		)
	}),
	(Ih.regexp_eatReverseSolidusAtomEscape = function (e) {
		var t = e.pos
		if (e.eat(92)) {
			if (this.regexp_eatAtomEscape(e)) return !0
			e.pos = t
		}
		return !1
	}),
	(Ih.regexp_eatUncapturingGroup = function (e) {
		var t = e.pos
		if (e.eat(40)) {
			if (e.eat(63) && e.eat(58)) {
				if ((this.regexp_disjunction(e), e.eat(41))) return !0
				e.raise('Unterminated group')
			}
			e.pos = t
		}
		return !1
	}),
	(Ih.regexp_eatCapturingGroup = function (e) {
		if (e.eat(40)) {
			if ((this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : 63 === e.current() && e.raise('Invalid group'), this.regexp_disjunction(e), e.eat(41)))
				return (e.numCapturingParens += 1), !0
			e.raise('Unterminated group')
		}
		return !1
	}),
	(Ih.regexp_eatExtendedAtom = function (e) {
		return (
			e.eat(46) ||
			this.regexp_eatReverseSolidusAtomEscape(e) ||
			this.regexp_eatCharacterClass(e) ||
			this.regexp_eatUncapturingGroup(e) ||
			this.regexp_eatCapturingGroup(e) ||
			this.regexp_eatInvalidBracedQuantifier(e) ||
			this.regexp_eatExtendedPatternCharacter(e)
		)
	}),
	(Ih.regexp_eatInvalidBracedQuantifier = function (e) {
		return this.regexp_eatBracedQuantifier(e, !0) && e.raise('Nothing to repeat'), !1
	}),
	(Ih.regexp_eatSyntaxCharacter = function (e) {
		var t = e.current()
		return !!Ph(t) && ((e.lastIntValue = t), e.advance(), !0)
	}),
	(Ih.regexp_eatPatternCharacters = function (e) {
		for (var t = e.pos, s = 0; -1 !== (s = e.current()) && !Ph(s); ) e.advance()
		return e.pos !== t
	}),
	(Ih.regexp_eatExtendedPatternCharacter = function (e) {
		var t = e.current()
		return !(-1 === t || 36 === t || (t >= 40 && t <= 43) || 46 === t || 63 === t || 91 === t || 94 === t || 124 === t) && (e.advance(), !0)
	}),
	(Ih.regexp_groupSpecifier = function (e) {
		if (e.eat(63)) {
			if (this.regexp_eatGroupName(e)) return -1 !== e.groupNames.indexOf(e.lastStringValue) && e.raise('Duplicate capture group name'), void e.groupNames.push(e.lastStringValue)
			e.raise('Invalid group')
		}
	}),
	(Ih.regexp_eatGroupName = function (e) {
		if (((e.lastStringValue = ''), e.eat(60))) {
			if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62)) return !0
			e.raise('Invalid capture group name')
		}
		return !1
	}),
	(Ih.regexp_eatRegExpIdentifierName = function (e) {
		if (((e.lastStringValue = ''), this.regexp_eatRegExpIdentifierStart(e))) {
			for (e.lastStringValue += Pc(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); ) e.lastStringValue += Pc(e.lastIntValue)
			return !0
		}
		return !1
	}),
	(Ih.regexp_eatRegExpIdentifierStart = function (e) {
		var t = e.pos,
			s = this.options.ecmaVersion >= 11,
			i = e.current(s)
		return (
			e.advance(s),
			92 === i && this.regexp_eatRegExpUnicodeEscapeSequence(e, s) && (i = e.lastIntValue),
			(function (e) {
				return oc(e, !0) || 36 === e || 95 === e
			})(i)
				? ((e.lastIntValue = i), !0)
				: ((e.pos = t), !1)
		)
	}),
	(Ih.regexp_eatRegExpIdentifierPart = function (e) {
		var t = e.pos,
			s = this.options.ecmaVersion >= 11,
			i = e.current(s)
		return (
			e.advance(s),
			92 === i && this.regexp_eatRegExpUnicodeEscapeSequence(e, s) && (i = e.lastIntValue),
			(function (e) {
				return ac(e, !0) || 36 === e || 95 === e || 8204 === e || 8205 === e
			})(i)
				? ((e.lastIntValue = i), !0)
				: ((e.pos = t), !1)
		)
	}),
	(Ih.regexp_eatAtomEscape = function (e) {
		return (
			!!(this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || (e.switchN && this.regexp_eatKGroupName(e))) ||
			(e.switchU && (99 === e.current() && e.raise('Invalid unicode escape'), e.raise('Invalid escape')), !1)
		)
	}),
	(Ih.regexp_eatBackReference = function (e) {
		var t = e.pos
		if (this.regexp_eatDecimalEscape(e)) {
			var s = e.lastIntValue
			if (e.switchU) return s > e.maxBackReference && (e.maxBackReference = s), !0
			if (s <= e.numCapturingParens) return !0
			e.pos = t
		}
		return !1
	}),
	(Ih.regexp_eatKGroupName = function (e) {
		if (e.eat(107)) {
			if (this.regexp_eatGroupName(e)) return e.backReferenceNames.push(e.lastStringValue), !0
			e.raise('Invalid named reference')
		}
		return !1
	}),
	(Ih.regexp_eatCharacterEscape = function (e) {
		return (
			this.regexp_eatControlEscape(e) ||
			this.regexp_eatCControlLetter(e) ||
			this.regexp_eatZero(e) ||
			this.regexp_eatHexEscapeSequence(e) ||
			this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) ||
			(!e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e)) ||
			this.regexp_eatIdentityEscape(e)
		)
	}),
	(Ih.regexp_eatCControlLetter = function (e) {
		var t = e.pos
		if (e.eat(99)) {
			if (this.regexp_eatControlLetter(e)) return !0
			e.pos = t
		}
		return !1
	}),
	(Ih.regexp_eatZero = function (e) {
		return 48 === e.current() && !_h(e.lookahead()) && ((e.lastIntValue = 0), e.advance(), !0)
	}),
	(Ih.regexp_eatControlEscape = function (e) {
		var t = e.current()
		return 116 === t
			? ((e.lastIntValue = 9), e.advance(), !0)
			: 110 === t
			? ((e.lastIntValue = 10), e.advance(), !0)
			: 118 === t
			? ((e.lastIntValue = 11), e.advance(), !0)
			: 102 === t
			? ((e.lastIntValue = 12), e.advance(), !0)
			: 114 === t && ((e.lastIntValue = 13), e.advance(), !0)
	}),
	(Ih.regexp_eatControlLetter = function (e) {
		var t = e.current()
		return !!Ch(t) && ((e.lastIntValue = t % 32), e.advance(), !0)
	}),
	(Ih.regexp_eatRegExpUnicodeEscapeSequence = function (e, t) {
		void 0 === t && (t = !1)
		var s,
			i = e.pos,
			n = t || e.switchU
		if (e.eat(117)) {
			if (this.regexp_eatFixedHexDigits(e, 4)) {
				var r = e.lastIntValue
				if (n && r >= 55296 && r <= 56319) {
					var o = e.pos
					if (e.eat(92) && e.eat(117) && this.regexp_eatFixedHexDigits(e, 4)) {
						var a = e.lastIntValue
						if (a >= 56320 && a <= 57343) return (e.lastIntValue = 1024 * (r - 55296) + (a - 56320) + 65536), !0
					}
					;(e.pos = o), (e.lastIntValue = r)
				}
				return !0
			}
			if (n && e.eat(123) && this.regexp_eatHexDigits(e) && e.eat(125) && (s = e.lastIntValue) >= 0 && s <= 1114111) return !0
			n && e.raise('Invalid unicode escape'), (e.pos = i)
		}
		return !1
	}),
	(Ih.regexp_eatIdentityEscape = function (e) {
		if (e.switchU) return !!this.regexp_eatSyntaxCharacter(e) || (!!e.eat(47) && ((e.lastIntValue = 47), !0))
		var t = e.current()
		return !(99 === t || (e.switchN && 107 === t)) && ((e.lastIntValue = t), e.advance(), !0)
	}),
	(Ih.regexp_eatDecimalEscape = function (e) {
		e.lastIntValue = 0
		var t = e.current()
		if (t >= 49 && t <= 57) {
			do {
				;(e.lastIntValue = 10 * e.lastIntValue + (t - 48)), e.advance()
			} while ((t = e.current()) >= 48 && t <= 57)
			return !0
		}
		return !1
	})
function $h(e) {
	return Ch(e) || 95 === e
}
function Nh(e) {
	return $h(e) || _h(e)
}
function _h(e) {
	return e >= 48 && e <= 57
}
function Rh(e) {
	return (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102)
}
function Mh(e) {
	return e >= 65 && e <= 70 ? e - 65 + 10 : e >= 97 && e <= 102 ? e - 97 + 10 : e - 48
}
function Oh(e) {
	return e >= 48 && e <= 55
}
;(Ih.regexp_eatCharacterClassEscape = function (e) {
	var t = e.current()
	if (
		(function (e) {
			return 100 === e || 68 === e || 115 === e || 83 === e || 119 === e || 87 === e
		})(t)
	)
		return (e.lastIntValue = -1), e.advance(), 1
	var s = !1
	if (e.switchU && this.options.ecmaVersion >= 9 && ((s = 80 === t) || 112 === t)) {
		var i
		if (((e.lastIntValue = -1), e.advance(), e.eat(123) && (i = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(125))) return s && 2 === i && e.raise('Invalid property name'), i
		e.raise('Invalid property name')
	}
	return 0
}),
	(Ih.regexp_eatUnicodePropertyValueExpression = function (e) {
		var t = e.pos
		if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) {
			var s = e.lastStringValue
			if (this.regexp_eatUnicodePropertyValue(e)) {
				var i = e.lastStringValue
				return this.regexp_validateUnicodePropertyNameAndValue(e, s, i), 1
			}
		}
		if (((e.pos = t), this.regexp_eatLoneUnicodePropertyNameOrValue(e))) {
			var n = e.lastStringValue
			return this.regexp_validateUnicodePropertyNameOrValue(e, n)
		}
		return 0
	}),
	(Ih.regexp_validateUnicodePropertyNameAndValue = function (e, t, s) {
		kc(e.unicodeProperties.nonBinary, t) || e.raise('Invalid property name'), e.unicodeProperties.nonBinary[t].test(s) || e.raise('Invalid property value')
	}),
	(Ih.regexp_validateUnicodePropertyNameOrValue = function (e, t) {
		return e.unicodeProperties.binary.test(t) ? 1 : e.switchV && e.unicodeProperties.binaryOfStrings.test(t) ? 2 : void e.raise('Invalid property name')
	}),
	(Ih.regexp_eatUnicodePropertyName = function (e) {
		var t = 0
		for (e.lastStringValue = ''; $h((t = e.current())); ) (e.lastStringValue += Pc(t)), e.advance()
		return '' !== e.lastStringValue
	}),
	(Ih.regexp_eatUnicodePropertyValue = function (e) {
		var t = 0
		for (e.lastStringValue = ''; Nh((t = e.current())); ) (e.lastStringValue += Pc(t)), e.advance()
		return '' !== e.lastStringValue
	}),
	(Ih.regexp_eatLoneUnicodePropertyNameOrValue = function (e) {
		return this.regexp_eatUnicodePropertyValue(e)
	}),
	(Ih.regexp_eatCharacterClass = function (e) {
		if (e.eat(91)) {
			var t = e.eat(94),
				s = this.regexp_classContents(e)
			return e.eat(93) || e.raise('Unterminated character class'), t && 2 === s && e.raise('Negated character class may contain strings'), !0
		}
		return !1
	}),
	(Ih.regexp_classContents = function (e) {
		return 93 === e.current() ? 1 : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), 1)
	}),
	(Ih.regexp_nonEmptyClassRanges = function (e) {
		for (; this.regexp_eatClassAtom(e); ) {
			var t = e.lastIntValue
			if (e.eat(45) && this.regexp_eatClassAtom(e)) {
				var s = e.lastIntValue
				!e.switchU || (-1 !== t && -1 !== s) || e.raise('Invalid character class'), -1 !== t && -1 !== s && t > s && e.raise('Range out of order in character class')
			}
		}
	}),
	(Ih.regexp_eatClassAtom = function (e) {
		var t = e.pos
		if (e.eat(92)) {
			if (this.regexp_eatClassEscape(e)) return !0
			if (e.switchU) {
				var s = e.current()
				;(99 === s || Oh(s)) && e.raise('Invalid class escape'), e.raise('Invalid escape')
			}
			e.pos = t
		}
		var i = e.current()
		return 93 !== i && ((e.lastIntValue = i), e.advance(), !0)
	}),
	(Ih.regexp_eatClassEscape = function (e) {
		var t = e.pos
		if (e.eat(98)) return (e.lastIntValue = 8), !0
		if (e.switchU && e.eat(45)) return (e.lastIntValue = 45), !0
		if (!e.switchU && e.eat(99)) {
			if (this.regexp_eatClassControlLetter(e)) return !0
			e.pos = t
		}
		return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e)
	}),
	(Ih.regexp_classSetExpression = function (e) {
		var t,
			s = 1
		if (this.regexp_eatClassSetRange(e));
		else if ((t = this.regexp_eatClassSetOperand(e))) {
			2 === t && (s = 2)
			for (var i = e.pos; e.eatChars([38, 38]); ) 38 !== e.current() && (t = this.regexp_eatClassSetOperand(e)) ? 2 !== t && (s = 1) : e.raise('Invalid character in character class')
			if (i !== e.pos) return s
			for (; e.eatChars([45, 45]); ) this.regexp_eatClassSetOperand(e) || e.raise('Invalid character in character class')
			if (i !== e.pos) return s
		} else e.raise('Invalid character in character class')
		for (;;)
			if (!this.regexp_eatClassSetRange(e)) {
				if (!(t = this.regexp_eatClassSetOperand(e))) return s
				2 === t && (s = 2)
			}
	}),
	(Ih.regexp_eatClassSetRange = function (e) {
		var t = e.pos
		if (this.regexp_eatClassSetCharacter(e)) {
			var s = e.lastIntValue
			if (e.eat(45) && this.regexp_eatClassSetCharacter(e)) {
				var i = e.lastIntValue
				return -1 !== s && -1 !== i && s > i && e.raise('Range out of order in character class'), !0
			}
			e.pos = t
		}
		return !1
	}),
	(Ih.regexp_eatClassSetOperand = function (e) {
		return this.regexp_eatClassSetCharacter(e) ? 1 : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e)
	}),
	(Ih.regexp_eatNestedClass = function (e) {
		var t = e.pos
		if (e.eat(91)) {
			var s = e.eat(94),
				i = this.regexp_classContents(e)
			if (e.eat(93)) return s && 2 === i && e.raise('Negated character class may contain strings'), i
			e.pos = t
		}
		if (e.eat(92)) {
			var n = this.regexp_eatCharacterClassEscape(e)
			if (n) return n
			e.pos = t
		}
		return null
	}),
	(Ih.regexp_eatClassStringDisjunction = function (e) {
		var t = e.pos
		if (e.eatChars([92, 113])) {
			if (e.eat(123)) {
				var s = this.regexp_classStringDisjunctionContents(e)
				if (e.eat(125)) return s
			} else e.raise('Invalid escape')
			e.pos = t
		}
		return null
	}),
	(Ih.regexp_classStringDisjunctionContents = function (e) {
		for (var t = this.regexp_classString(e); e.eat(124); ) 2 === this.regexp_classString(e) && (t = 2)
		return t
	}),
	(Ih.regexp_classString = function (e) {
		for (var t = 0; this.regexp_eatClassSetCharacter(e); ) t++
		return 1 === t ? 1 : 2
	}),
	(Ih.regexp_eatClassSetCharacter = function (e) {
		var t = e.pos
		if (e.eat(92)) return !(!this.regexp_eatCharacterEscape(e) && !this.regexp_eatClassSetReservedPunctuator(e)) || (e.eat(98) ? ((e.lastIntValue = 8), !0) : ((e.pos = t), !1))
		var s = e.current()
		return (
			!(
				s < 0 ||
				(s === e.lookahead() &&
					(function (e) {
						return 33 === e || (e >= 35 && e <= 38) || (e >= 42 && e <= 44) || 46 === e || (e >= 58 && e <= 64) || 94 === e || 96 === e || 126 === e
					})(s))
			) &&
			!(function (e) {
				return 40 === e || 41 === e || 45 === e || 47 === e || (e >= 91 && e <= 93) || (e >= 123 && e <= 125)
			})(s) &&
			(e.advance(), (e.lastIntValue = s), !0)
		)
	}),
	(Ih.regexp_eatClassSetReservedPunctuator = function (e) {
		var t = e.current()
		return (
			!!(function (e) {
				return 33 === e || 35 === e || 37 === e || 38 === e || 44 === e || 45 === e || (e >= 58 && e <= 62) || 64 === e || 96 === e || 126 === e
			})(t) && ((e.lastIntValue = t), e.advance(), !0)
		)
	}),
	(Ih.regexp_eatClassControlLetter = function (e) {
		var t = e.current()
		return !(!_h(t) && 95 !== t) && ((e.lastIntValue = t % 32), e.advance(), !0)
	}),
	(Ih.regexp_eatHexEscapeSequence = function (e) {
		var t = e.pos
		if (e.eat(120)) {
			if (this.regexp_eatFixedHexDigits(e, 2)) return !0
			e.switchU && e.raise('Invalid escape'), (e.pos = t)
		}
		return !1
	}),
	(Ih.regexp_eatDecimalDigits = function (e) {
		var t = e.pos,
			s = 0
		for (e.lastIntValue = 0; _h((s = e.current())); ) (e.lastIntValue = 10 * e.lastIntValue + (s - 48)), e.advance()
		return e.pos !== t
	}),
	(Ih.regexp_eatHexDigits = function (e) {
		var t = e.pos,
			s = 0
		for (e.lastIntValue = 0; Rh((s = e.current())); ) (e.lastIntValue = 16 * e.lastIntValue + Mh(s)), e.advance()
		return e.pos !== t
	}),
	(Ih.regexp_eatLegacyOctalEscapeSequence = function (e) {
		if (this.regexp_eatOctalDigit(e)) {
			var t = e.lastIntValue
			if (this.regexp_eatOctalDigit(e)) {
				var s = e.lastIntValue
				t <= 3 && this.regexp_eatOctalDigit(e) ? (e.lastIntValue = 64 * t + 8 * s + e.lastIntValue) : (e.lastIntValue = 8 * t + s)
			} else e.lastIntValue = t
			return !0
		}
		return !1
	}),
	(Ih.regexp_eatOctalDigit = function (e) {
		var t = e.current()
		return Oh(t) ? ((e.lastIntValue = t - 48), e.advance(), !0) : ((e.lastIntValue = 0), !1)
	}),
	(Ih.regexp_eatFixedHexDigits = function (e, t) {
		var s = e.pos
		e.lastIntValue = 0
		for (var i = 0; i < t; ++i) {
			var n = e.current()
			if (!Rh(n)) return (e.pos = s), !1
			;(e.lastIntValue = 16 * e.lastIntValue + Mh(n)), e.advance()
		}
		return !0
	})
var Dh = function (e) {
		;(this.type = e.type),
			(this.value = e.value),
			(this.start = e.start),
			(this.end = e.end),
			e.options.locations && (this.loc = new Nc(e, e.startLoc, e.endLoc)),
			e.options.ranges && (this.range = [e.start, e.end])
	},
	Lh = Tc.prototype
function Th(e) {
	return 'function' != typeof BigInt ? null : BigInt(e.replace(/_/g, ''))
}
;(Lh.next = function (e) {
	!e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, 'Escape sequence in keyword ' + this.type.keyword),
		this.options.onToken && this.options.onToken(new Dh(this)),
		(this.lastTokEnd = this.end),
		(this.lastTokStart = this.start),
		(this.lastTokEndLoc = this.endLoc),
		(this.lastTokStartLoc = this.startLoc),
		this.nextToken()
}),
	(Lh.getToken = function () {
		return this.next(), new Dh(this)
	}),
	'undefined' != typeof Symbol &&
		(Lh[Symbol.iterator] = function () {
			var e = this
			return {
				next: function () {
					var t = e.getToken()
					return { done: t.type === fc.eof, value: t }
				}
			}
		}),
	(Lh.nextToken = function () {
		var e = this.curContext()
		return (
			(e && e.preserveSpace) || this.skipSpace(),
			(this.start = this.pos),
			this.options.locations && (this.startLoc = this.curPosition()),
			this.pos >= this.input.length ? this.finishToken(fc.eof) : e.override ? e.override(this) : void this.readToken(this.fullCharCodeAtPos())
		)
	}),
	(Lh.readToken = function (e) {
		return oc(e, this.options.ecmaVersion >= 6) || 92 === e ? this.readWord() : this.getTokenFromCode(e)
	}),
	(Lh.fullCharCodeAtPos = function () {
		var e = this.input.charCodeAt(this.pos)
		if (e <= 55295 || e >= 56320) return e
		var t = this.input.charCodeAt(this.pos + 1)
		return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888
	}),
	(Lh.skipBlockComment = function () {
		var e = this.options.onComment && this.curPosition(),
			t = this.pos,
			s = this.input.indexOf('*/', (this.pos += 2))
		if ((-1 === s && this.raise(this.pos - 2, 'Unterminated comment'), (this.pos = s + 2), this.options.locations))
			for (var i = void 0, n = t; (i = xc(this.input, n, this.pos)) > -1; ) ++this.curLine, (n = this.lineStart = i)
		this.options.onComment && this.options.onComment(!0, this.input.slice(t + 2, s), t, this.pos, e, this.curPosition())
	}),
	(Lh.skipLineComment = function (e) {
		for (var t = this.pos, s = this.options.onComment && this.curPosition(), i = this.input.charCodeAt((this.pos += e)); this.pos < this.input.length && !yc(i); ) i = this.input.charCodeAt(++this.pos)
		this.options.onComment && this.options.onComment(!1, this.input.slice(t + e, this.pos), t, this.pos, s, this.curPosition())
	}),
	(Lh.skipSpace = function () {
		e: for (; this.pos < this.input.length; ) {
			var e = this.input.charCodeAt(this.pos)
			switch (e) {
				case 32:
				case 160:
					++this.pos
					break
				case 13:
					10 === this.input.charCodeAt(this.pos + 1) && ++this.pos
				case 10:
				case 8232:
				case 8233:
					++this.pos, this.options.locations && (++this.curLine, (this.lineStart = this.pos))
					break
				case 47:
					switch (this.input.charCodeAt(this.pos + 1)) {
						case 42:
							this.skipBlockComment()
							break
						case 47:
							this.skipLineComment(2)
							break
						default:
							break e
					}
					break
				default:
					if (!((e > 8 && e < 14) || (e >= 5760 && Ec.test(String.fromCharCode(e))))) break e
					++this.pos
			}
		}
	}),
	(Lh.finishToken = function (e, t) {
		;(this.end = this.pos), this.options.locations && (this.endLoc = this.curPosition())
		var s = this.type
		;(this.type = e), (this.value = t), this.updateContext(s)
	}),
	(Lh.readToken_dot = function () {
		var e = this.input.charCodeAt(this.pos + 1)
		if (e >= 48 && e <= 57) return this.readNumber(!0)
		var t = this.input.charCodeAt(this.pos + 2)
		return this.options.ecmaVersion >= 6 && 46 === e && 46 === t ? ((this.pos += 3), this.finishToken(fc.ellipsis)) : (++this.pos, this.finishToken(fc.dot))
	}),
	(Lh.readToken_slash = function () {
		var e = this.input.charCodeAt(this.pos + 1)
		return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === e ? this.finishOp(fc.assign, 2) : this.finishOp(fc.slash, 1)
	}),
	(Lh.readToken_mult_modulo_exp = function (e) {
		var t = this.input.charCodeAt(this.pos + 1),
			s = 1,
			i = 42 === e ? fc.star : fc.modulo
		return (
			this.options.ecmaVersion >= 7 && 42 === e && 42 === t && (++s, (i = fc.starstar), (t = this.input.charCodeAt(this.pos + 2))), 61 === t ? this.finishOp(fc.assign, s + 1) : this.finishOp(i, s)
		)
	}),
	(Lh.readToken_pipe_amp = function (e) {
		var t = this.input.charCodeAt(this.pos + 1)
		if (t === e) {
			if (this.options.ecmaVersion >= 12) if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(fc.assign, 3)
			return this.finishOp(124 === e ? fc.logicalOR : fc.logicalAND, 2)
		}
		return 61 === t ? this.finishOp(fc.assign, 2) : this.finishOp(124 === e ? fc.bitwiseOR : fc.bitwiseAND, 1)
	}),
	(Lh.readToken_caret = function () {
		return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(fc.assign, 2) : this.finishOp(fc.bitwiseXOR, 1)
	}),
	(Lh.readToken_plus_min = function (e) {
		var t = this.input.charCodeAt(this.pos + 1)
		return t === e
			? 45 !== t || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || (0 !== this.lastTokEnd && !mc.test(this.input.slice(this.lastTokEnd, this.pos)))
				? this.finishOp(fc.incDec, 2)
				: (this.skipLineComment(3), this.skipSpace(), this.nextToken())
			: 61 === t
			? this.finishOp(fc.assign, 2)
			: this.finishOp(fc.plusMin, 1)
	}),
	(Lh.readToken_lt_gt = function (e) {
		var t = this.input.charCodeAt(this.pos + 1),
			s = 1
		return t === e
			? ((s = 62 === e && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2), 61 === this.input.charCodeAt(this.pos + s) ? this.finishOp(fc.assign, s + 1) : this.finishOp(fc.bitShift, s))
			: 33 !== t || 60 !== e || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3)
			? (61 === t && (s = 2), this.finishOp(fc.relational, s))
			: (this.skipLineComment(4), this.skipSpace(), this.nextToken())
	}),
	(Lh.readToken_eq_excl = function (e) {
		var t = this.input.charCodeAt(this.pos + 1)
		return 61 === t
			? this.finishOp(fc.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2)
			: 61 === e && 62 === t && this.options.ecmaVersion >= 6
			? ((this.pos += 2), this.finishToken(fc.arrow))
			: this.finishOp(61 === e ? fc.eq : fc.prefix, 1)
	}),
	(Lh.readToken_question = function () {
		var e = this.options.ecmaVersion
		if (e >= 11) {
			var t = this.input.charCodeAt(this.pos + 1)
			if (46 === t) {
				var s = this.input.charCodeAt(this.pos + 2)
				if (s < 48 || s > 57) return this.finishOp(fc.questionDot, 2)
			}
			if (63 === t) {
				if (e >= 12) if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(fc.assign, 3)
				return this.finishOp(fc.coalesce, 2)
			}
		}
		return this.finishOp(fc.question, 1)
	}),
	(Lh.readToken_numberSign = function () {
		var e = 35
		if (this.options.ecmaVersion >= 13 && (++this.pos, oc((e = this.fullCharCodeAtPos()), !0) || 92 === e)) return this.finishToken(fc.privateId, this.readWord1())
		this.raise(this.pos, "Unexpected character '" + Pc(e) + "'")
	}),
	(Lh.getTokenFromCode = function (e) {
		switch (e) {
			case 46:
				return this.readToken_dot()
			case 40:
				return ++this.pos, this.finishToken(fc.parenL)
			case 41:
				return ++this.pos, this.finishToken(fc.parenR)
			case 59:
				return ++this.pos, this.finishToken(fc.semi)
			case 44:
				return ++this.pos, this.finishToken(fc.comma)
			case 91:
				return ++this.pos, this.finishToken(fc.bracketL)
			case 93:
				return ++this.pos, this.finishToken(fc.bracketR)
			case 123:
				return ++this.pos, this.finishToken(fc.braceL)
			case 125:
				return ++this.pos, this.finishToken(fc.braceR)
			case 58:
				return ++this.pos, this.finishToken(fc.colon)
			case 96:
				if (this.options.ecmaVersion < 6) break
				return ++this.pos, this.finishToken(fc.backQuote)
			case 48:
				var t = this.input.charCodeAt(this.pos + 1)
				if (120 === t || 88 === t) return this.readRadixNumber(16)
				if (this.options.ecmaVersion >= 6) {
					if (111 === t || 79 === t) return this.readRadixNumber(8)
					if (98 === t || 66 === t) return this.readRadixNumber(2)
				}
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
				return this.readNumber(!1)
			case 34:
			case 39:
				return this.readString(e)
			case 47:
				return this.readToken_slash()
			case 37:
			case 42:
				return this.readToken_mult_modulo_exp(e)
			case 124:
			case 38:
				return this.readToken_pipe_amp(e)
			case 94:
				return this.readToken_caret()
			case 43:
			case 45:
				return this.readToken_plus_min(e)
			case 60:
			case 62:
				return this.readToken_lt_gt(e)
			case 61:
			case 33:
				return this.readToken_eq_excl(e)
			case 63:
				return this.readToken_question()
			case 126:
				return this.finishOp(fc.prefix, 1)
			case 35:
				return this.readToken_numberSign()
		}
		this.raise(this.pos, "Unexpected character '" + Pc(e) + "'")
	}),
	(Lh.finishOp = function (e, t) {
		var s = this.input.slice(this.pos, this.pos + t)
		return (this.pos += t), this.finishToken(e, s)
	}),
	(Lh.readRegexp = function () {
		for (var e, t, s = this.pos; ; ) {
			this.pos >= this.input.length && this.raise(s, 'Unterminated regular expression')
			var i = this.input.charAt(this.pos)
			if ((mc.test(i) && this.raise(s, 'Unterminated regular expression'), e)) e = !1
			else {
				if ('[' === i) t = !0
				else if (']' === i && t) t = !1
				else if ('/' === i && !t) break
				e = '\\' === i
			}
			++this.pos
		}
		var n = this.input.slice(s, this.pos)
		++this.pos
		var r = this.pos,
			o = this.readWord1()
		this.containsEsc && this.unexpected(r)
		var a = this.regexpState || (this.regexpState = new wh(this))
		a.reset(s, n, o), this.validateRegExpFlags(a), this.validateRegExpPattern(a)
		var l = null
		try {
			l = new RegExp(n, o)
		} catch (e) {}
		return this.finishToken(fc.regexp, { pattern: n, flags: o, value: l })
	}),
	(Lh.readInt = function (e, t, s) {
		for (
			var i = this.options.ecmaVersion >= 12 && void 0 === t, n = s && 48 === this.input.charCodeAt(this.pos), r = this.pos, o = 0, a = 0, l = 0, c = null == t ? 1 / 0 : t;
			l < c;
			++l, ++this.pos
		) {
			var h = this.input.charCodeAt(this.pos),
				u = void 0
			if (i && 95 === h)
				n && this.raiseRecoverable(this.pos, 'Numeric separator is not allowed in legacy octal numeric literals'),
					95 === a && this.raiseRecoverable(this.pos, 'Numeric separator must be exactly one underscore'),
					0 === l && this.raiseRecoverable(this.pos, 'Numeric separator is not allowed at the first of digits'),
					(a = h)
			else {
				if ((u = h >= 97 ? h - 97 + 10 : h >= 65 ? h - 65 + 10 : h >= 48 && h <= 57 ? h - 48 : 1 / 0) >= e) break
				;(a = h), (o = o * e + u)
			}
		}
		return i && 95 === a && this.raiseRecoverable(this.pos - 1, 'Numeric separator is not allowed at the last of digits'), this.pos === r || (null != t && this.pos - r !== t) ? null : o
	}),
	(Lh.readRadixNumber = function (e) {
		var t = this.pos
		this.pos += 2
		var s = this.readInt(e)
		return (
			null == s && this.raise(this.start + 2, 'Expected number in radix ' + e),
			this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos)
				? ((s = Th(this.input.slice(t, this.pos))), ++this.pos)
				: oc(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'),
			this.finishToken(fc.num, s)
		)
	}),
	(Lh.readNumber = function (e) {
		var t = this.pos
		e || null !== this.readInt(10, void 0, !0) || this.raise(t, 'Invalid number')
		var s = this.pos - t >= 2 && 48 === this.input.charCodeAt(t)
		s && this.strict && this.raise(t, 'Invalid number')
		var i = this.input.charCodeAt(this.pos)
		if (!s && !e && this.options.ecmaVersion >= 11 && 110 === i) {
			var n = Th(this.input.slice(t, this.pos))
			return ++this.pos, oc(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number'), this.finishToken(fc.num, n)
		}
		s && /[89]/.test(this.input.slice(t, this.pos)) && (s = !1),
			46 !== i || s || (++this.pos, this.readInt(10), (i = this.input.charCodeAt(this.pos))),
			(69 !== i && 101 !== i) || s || ((43 !== (i = this.input.charCodeAt(++this.pos)) && 45 !== i) || ++this.pos, null === this.readInt(10) && this.raise(t, 'Invalid number')),
			oc(this.fullCharCodeAtPos()) && this.raise(this.pos, 'Identifier directly after number')
		var r,
			o = ((r = this.input.slice(t, this.pos)), s ? parseInt(r, 8) : parseFloat(r.replace(/_/g, '')))
		return this.finishToken(fc.num, o)
	}),
	(Lh.readCodePoint = function () {
		var e
		if (123 === this.input.charCodeAt(this.pos)) {
			this.options.ecmaVersion < 6 && this.unexpected()
			var t = ++this.pos
			;(e = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)), ++this.pos, e > 1114111 && this.invalidStringToken(t, 'Code point out of bounds')
		} else e = this.readHexChar(4)
		return e
	}),
	(Lh.readString = function (e) {
		for (var t = '', s = ++this.pos; ; ) {
			this.pos >= this.input.length && this.raise(this.start, 'Unterminated string constant')
			var i = this.input.charCodeAt(this.pos)
			if (i === e) break
			92 === i
				? ((t += this.input.slice(s, this.pos)), (t += this.readEscapedChar(!1)), (s = this.pos))
				: 8232 === i || 8233 === i
				? (this.options.ecmaVersion < 10 && this.raise(this.start, 'Unterminated string constant'), ++this.pos, this.options.locations && (this.curLine++, (this.lineStart = this.pos)))
				: (yc(i) && this.raise(this.start, 'Unterminated string constant'), ++this.pos)
		}
		return (t += this.input.slice(s, this.pos++)), this.finishToken(fc.string, t)
	})
var Vh = {}
;(Lh.tryReadTemplateToken = function () {
	this.inTemplateElement = !0
	try {
		this.readTmplToken()
	} catch (e) {
		if (e !== Vh) throw e
		this.readInvalidTemplateToken()
	}
	this.inTemplateElement = !1
}),
	(Lh.invalidStringToken = function (e, t) {
		if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw Vh
		this.raise(e, t)
	}),
	(Lh.readTmplToken = function () {
		for (var e = '', t = this.pos; ; ) {
			this.pos >= this.input.length && this.raise(this.start, 'Unterminated template')
			var s = this.input.charCodeAt(this.pos)
			if (96 === s || (36 === s && 123 === this.input.charCodeAt(this.pos + 1)))
				return this.pos !== this.start || (this.type !== fc.template && this.type !== fc.invalidTemplate)
					? ((e += this.input.slice(t, this.pos)), this.finishToken(fc.template, e))
					: 36 === s
					? ((this.pos += 2), this.finishToken(fc.dollarBraceL))
					: (++this.pos, this.finishToken(fc.backQuote))
			if (92 === s) (e += this.input.slice(t, this.pos)), (e += this.readEscapedChar(!0)), (t = this.pos)
			else if (yc(s)) {
				switch (((e += this.input.slice(t, this.pos)), ++this.pos, s)) {
					case 13:
						10 === this.input.charCodeAt(this.pos) && ++this.pos
					case 10:
						e += '\n'
						break
					default:
						e += String.fromCharCode(s)
				}
				this.options.locations && (++this.curLine, (this.lineStart = this.pos)), (t = this.pos)
			} else ++this.pos
		}
	}),
	(Lh.readInvalidTemplateToken = function () {
		for (; this.pos < this.input.length; this.pos++)
			switch (this.input[this.pos]) {
				case '\\':
					++this.pos
					break
				case '$':
					if ('{' !== this.input[this.pos + 1]) break
				case '`':
					return this.finishToken(fc.invalidTemplate, this.input.slice(this.start, this.pos))
			}
		this.raise(this.start, 'Unterminated template')
	}),
	(Lh.readEscapedChar = function (e) {
		var t = this.input.charCodeAt(++this.pos)
		switch ((++this.pos, t)) {
			case 110:
				return '\n'
			case 114:
				return '\r'
			case 120:
				return String.fromCharCode(this.readHexChar(2))
			case 117:
				return Pc(this.readCodePoint())
			case 116:
				return '\t'
			case 98:
				return '\b'
			case 118:
				return '\v'
			case 102:
				return '\f'
			case 13:
				10 === this.input.charCodeAt(this.pos) && ++this.pos
			case 10:
				return this.options.locations && ((this.lineStart = this.pos), ++this.curLine), ''
			case 56:
			case 57:
				if ((this.strict && this.invalidStringToken(this.pos - 1, 'Invalid escape sequence'), e)) {
					var s = this.pos - 1
					this.invalidStringToken(s, 'Invalid escape sequence in template string')
				}
			default:
				if (t >= 48 && t <= 55) {
					var i = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],
						n = parseInt(i, 8)
					return (
						n > 255 && ((i = i.slice(0, -1)), (n = parseInt(i, 8))),
						(this.pos += i.length - 1),
						(t = this.input.charCodeAt(this.pos)),
						('0' === i && 56 !== t && 57 !== t) || (!this.strict && !e) || this.invalidStringToken(this.pos - 1 - i.length, e ? 'Octal literal in template string' : 'Octal literal in strict mode'),
						String.fromCharCode(n)
					)
				}
				return yc(t) ? '' : String.fromCharCode(t)
		}
	}),
	(Lh.readHexChar = function (e) {
		var t = this.pos,
			s = this.readInt(16, e)
		return null === s && this.invalidStringToken(t, 'Bad character escape sequence'), s
	}),
	(Lh.readWord1 = function () {
		this.containsEsc = !1
		for (var e = '', t = !0, s = this.pos, i = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
			var n = this.fullCharCodeAtPos()
			if (ac(n, i)) this.pos += n <= 65535 ? 1 : 2
			else {
				if (92 !== n) break
				;(this.containsEsc = !0), (e += this.input.slice(s, this.pos))
				var r = this.pos
				117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, 'Expecting Unicode escape sequence \\uXXXX'), ++this.pos
				var o = this.readCodePoint()
				;(t ? oc : ac)(o, i) || this.invalidStringToken(r, 'Invalid Unicode escape'), (e += Pc(o)), (s = this.pos)
			}
			t = !1
		}
		return e + this.input.slice(s, this.pos)
	}),
	(Lh.readWord = function () {
		var e = this.readWord1(),
			t = fc.name
		return this.keywords.test(e) && (t = dc[e]), this.finishToken(t, e)
	})
var Bh = '8.10.0'
Tc.acorn = {
	Parser: Tc,
	version: Bh,
	defaultOptions: Rc,
	Position: $c,
	SourceLocation: Nc,
	getLineInfo: _c,
	Node: oh,
	TokenType: lc,
	tokTypes: fc,
	keywordTypes: dc,
	TokContext: Qc,
	tokContexts: Zc,
	isIdentifierChar: ac,
	isIdentifierStart: oc,
	Token: Dh,
	isNewLine: yc,
	lineBreak: mc,
	lineBreakG: gc,
	nonASCIIwhitespace: Ec
}
var zh = Object.freeze({
	__proto__: null,
	Node: oh,
	Parser: Tc,
	Position: $c,
	SourceLocation: Nc,
	TokContext: Qc,
	Token: Dh,
	TokenType: lc,
	defaultOptions: Rc,
	getLineInfo: _c,
	isIdentifierChar: ac,
	isIdentifierStart: oc,
	isNewLine: yc,
	keywordTypes: dc,
	lineBreak: mc,
	lineBreakG: gc,
	nonASCIIwhitespace: Ec,
	parse: function (e, t) {
		return Tc.parse(e, t)
	},
	parseExpressionAt: function (e, t, s) {
		return Tc.parseExpressionAt(e, t, s)
	},
	tokContexts: Zc,
	tokTypes: fc,
	tokenizer: function (e, t) {
		return Tc.tokenizer(e, t)
	},
	version: Bh
})
const Fh = (e) => () =>
		Qe(
			(function (e) {
				return {
					code: 'NO_FS_IN_BROWSER',
					message: `Cannot access the file system (via "${e}") when using the browser build of Rollup. Make sure you supply a plugin with custom resolveId and load hooks to Rollup.`,
					url: De('plugin-development/#a-simple-example')
				}
			})(e)
		),
	jh = Fh('fs.mkdir'),
	Uh = Fh('fs.readFile'),
	Gh = Fh('fs.writeFile')
async function Wh(e, t, s, i, n, r, o, a, l) {
	const c = await (function (e, t, s, i, n, r, o, a) {
		let l = null,
			c = null
		if (n) {
			l = new Set()
			for (const s of n) e === s.source && t === s.importer && l.add(s.plugin)
			c = (e, t) => ({ ...e, resolve: (e, s, { assertions: r, custom: o, isEntry: a, skipSelf: l } = me) => i(e, s, o, a, r || ge, l ? [...n, { importer: s, plugin: t, source: e }] : n) })
		}
		return s.hookFirstAndGetPlugin('resolveId', [e, t, { assertions: a, custom: r, isEntry: o }], c, l)
	})(e, t, i, n, r, o, a, l)
	return null == c ? Fh('path.resolve')() : c[0]
}
const qh = 'at position ',
	Hh = 'at output position '
const Kh = { delete: () => !1, get() {}, has: () => !1, set() {} }
function Yh(e) {
	return e.startsWith(qh) || e.startsWith(Hh)
		? Qe({ code: tt, message: 'A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey.' })
		: Qe({
				code: at,
				message: `The plugin name ${e} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).`
		  })
}
const Xh = (e, t, s = tu) => {
		const { onwarn: i, onLog: n } = e,
			r = Qh(s, i)
		if (n) {
			const e = we[t]
			return (t, s) =>
				n(t, Zh(s), (t, s) => {
					if ('error' === t) return Qe(Jh(s))
					we[t] >= e && r(t, Jh(s))
				})
		}
		return r
	},
	Qh = (e, t) =>
		t
			? (s, i) => {
					s === Ae ? t(Zh(i), (t) => e(Ae, Jh(t))) : e(s, i)
			  }
			: e,
	Zh = (e) => (Object.defineProperty(e, 'toString', { value: () => eu(e), writable: !0 }), e),
	Jh = (e) => ('string' == typeof e ? { message: e } : 'function' == typeof e ? Jh(e()) : e),
	eu = (e) => {
		let t = ''
		return e.plugin && (t += `(${e.plugin} plugin) `), e.loc && (t += `${V(e.loc.file)} (${e.loc.line}:${e.loc.column}) `), t + e.message
	},
	tu = (e, t) => {
		const s = eu(t)
		switch (e) {
			case Ae:
				return console.warn(s)
			case Ie:
				return console.debug(s)
			default:
				return console.info(s)
		}
	}
function su(e, t, s, i, n = /$./) {
	const r = new Set(t),
		o = Object.keys(e).filter((e) => !(r.has(e) || n.test(e)))
	o.length > 0 &&
		i(
			Ae,
			(function (e, t, s) {
				return { code: $t, message: `Unknown ${e}: ${t.join(', ')}. Allowed options: ${s.join(', ')}` }
			})(s, o, [...r].sort())
		)
}
const iu = {
		recommended: {
			annotations: !0,
			correctVarValueBeforeDeclaration: !1,
			manualPureFunctions: ye,
			moduleSideEffects: () => !0,
			propertyReadSideEffects: !0,
			tryCatchDeoptimization: !0,
			unknownGlobalSideEffects: !1
		},
		safest: {
			annotations: !0,
			correctVarValueBeforeDeclaration: !0,
			manualPureFunctions: ye,
			moduleSideEffects: () => !0,
			propertyReadSideEffects: !0,
			tryCatchDeoptimization: !0,
			unknownGlobalSideEffects: !0
		},
		smallest: {
			annotations: !0,
			correctVarValueBeforeDeclaration: !1,
			manualPureFunctions: ye,
			moduleSideEffects: () => !1,
			propertyReadSideEffects: !1,
			tryCatchDeoptimization: !1,
			unknownGlobalSideEffects: !1
		}
	},
	nu = {
		es2015: { arrowFunctions: !0, constBindings: !0, objectShorthand: !0, reservedNamesAsProps: !0, symbols: !0 },
		es5: { arrowFunctions: !1, constBindings: !1, objectShorthand: !1, reservedNamesAsProps: !0, symbols: !1 }
	},
	ru = (e, t, s, i, n) => {
		const r = e?.preset
		if (r) {
			const n = t[r]
			if (n) return { ...n, ...e }
			Qe(jt(`${s}.preset`, i, `valid values are ${Oe(Object.keys(t))}`, r))
		}
		return ((e, t, s, i) => (n) => {
			if ('string' == typeof n) {
				const r = e[n]
				if (r) return r
				Qe(jt(t, s, `valid values are ${i}${Oe(Object.keys(e))}. You can also supply an object for more fine-grained control`, n))
			}
			return ((e) => (e && 'object' == typeof e ? e : {}))(n)
		})(
			t,
			s,
			i,
			n
		)(e)
	},
	ou = async (e) =>
		(
			await (async function (e) {
				do {
					e = (await Promise.all(e)).flat(1 / 0)
				} while (e.some((e) => e?.then))
				return e
			})([e])
		).filter(Boolean)
async function au(e, t, s, i) {
	const n = t.id,
		r = []
	let o = null === e.map ? null : Ao(e.map)
	const a = e.code
	let c = e.ast
	const h = [],
		u = []
	let d = !1
	const p = () => (d = !0)
	let f = '',
		m = e.code
	const g = (e) => (t, s) => {
		;(t = Jh(t)), s && Ze(t, s, m, n), (t.id = n), (t.hook = 'transform'), e(t)
	}
	let x
	try {
		x = await s.hookReduceArg0(
			'transform',
			[m, n],
			function (e, s, n) {
				let o, a
				if ('string' == typeof s) o = s
				else {
					if (!s || 'object' != typeof s) return e
					if ((t.updateOptions(s), null == s.code))
						return (
							(s.map || s.ast) &&
								i(
									Ae,
									(function (e) {
										return { code: kt, message: `The plugin "${e}" returned a "map" or "ast" without returning a "code". This will be ignored.` }
									})(n.name)
								),
							e
						)
					;({ code: o, map: a, ast: c } = s)
				}
				return null !== a && r.push(Ao('string' == typeof a ? JSON.parse(a) : a) || { missing: !0, plugin: n.name }), (m = o), o
			},
			(e, t) => {
				return (
					(f = t.name),
					{
						...e,
						addWatchFile(t) {
							h.push(t), e.addWatchFile(t)
						},
						cache: d ? e.cache : ((c = e.cache), (x = p), { delete: (e) => (x(), c.delete(e)), get: (e) => (x(), c.get(e)), has: (e) => (x(), c.has(e)), set: (e, t) => (x(), c.set(e, t)) }),
						debug: g(e.debug),
						emitFile: (e) => (u.push(e), s.emitFile(e)),
						error: (t, s) => ('string' == typeof t && (t = { message: t }), s && Ze(t, s, m, n), (t.id = n), (t.hook = 'transform'), e.error(t)),
						getCombinedSourcemap() {
							const e = (function (e, t, s, i, n) {
								return 0 === i.length ? s : Ao({ version: 3, ...rl(e, t, s, i, nl(n)).traceMappings() })
							})(n, a, o, r, i)
							if (!e) {
								return new y(a).generateMap({ hires: !0, includeContent: !0, source: n })
							}
							return o !== e && ((o = e), (r.length = 0)), new l({ ...e, file: null, sourcesContent: e.sourcesContent })
						},
						info: g(e.info),
						setAssetSource() {
							return this.error({ code: gt, message: 'setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook.' })
						},
						warn: g(e.warn)
					}
				)
				var c, x
			}
		)
	} catch (e) {
		return Qe(qt(e, f, { hook: 'transform', id: n }))
	}
	return !d && u.length > 0 && (t.transformFiles = u), { ast: c, code: x, customTransformCache: d, originalCode: a, originalSourcemap: o, sourcemapChain: r, transformDependencies: h }
}
const lu = 'resolveDependencies'
class cu {
	constructor(e, t, s, i) {
		;(this.graph = e),
			(this.modulesById = t),
			(this.options = s),
			(this.pluginDriver = i),
			(this.implicitEntryModules = new Set()),
			(this.indexedEntryModules = []),
			(this.latestLoadModulesPromise = Promise.resolve()),
			(this.moduleLoadPromises = new Map()),
			(this.modulesWithLoadedDependencies = new Set()),
			(this.nextChunkNamePriority = 0),
			(this.nextEntryModuleIndex = 0),
			(this.resolveId = async (e, t, s, i, n, r = null) =>
				this.getResolvedIdWithDefaults(
					this.getNormalizedResolvedIdWithoutDefaults(
						!this.options.external(e, t, !1) && (await Wh(e, t, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, r, s, 'boolean' == typeof i ? i : !t, n)),
						t,
						e
					),
					n
				)),
			(this.hasModuleSideEffects = s.treeshake ? s.treeshake.moduleSideEffects : () => !0)
	}
	async addAdditionalModules(e, t) {
		const s = this.extendLoadModulesPromise(Promise.all(e.map((e) => this.loadEntryModule(e, !1, void 0, null, t))))
		return await this.awaitLoadModulesPromise(), s
	}
	async addEntryModules(e, t) {
		const s = this.nextEntryModuleIndex
		this.nextEntryModuleIndex += e.length
		const i = this.nextChunkNamePriority
		this.nextChunkNamePriority += e.length
		const n = await this.extendLoadModulesPromise(
			Promise.all(e.map(({ id: e, importer: t }) => this.loadEntryModule(e, !0, t, null))).then((n) => {
				for (const [r, o] of n.entries()) {
					;(o.isUserDefinedEntryPoint = o.isUserDefinedEntryPoint || t), uu(o, e[r], t, i + r)
					const n = this.indexedEntryModules.find((e) => e.module === o)
					n ? (n.index = Math.min(n.index, s + r)) : this.indexedEntryModules.push({ index: s + r, module: o })
				}
				return this.indexedEntryModules.sort(({ index: e }, { index: t }) => (e > t ? 1 : -1)), n
			})
		)
		return await this.awaitLoadModulesPromise(), { entryModules: this.indexedEntryModules.map(({ module: e }) => e), implicitEntryModules: [...this.implicitEntryModules], newEntryModules: n }
	}
	async emitChunk({ fileName: e, id: t, importer: s, name: i, implicitlyLoadedAfterOneOf: n, preserveSignature: r }) {
		const o = { fileName: e || null, id: t, importer: s, name: i || null },
			a = n ? await this.addEntryWithImplicitDependants(o, n) : (await this.addEntryModules([o], !1)).newEntryModules[0]
		return null != r && (a.preserveSignature = r), a
	}
	async preloadModule(e) {
		return (await this.fetchModule(this.getResolvedIdWithDefaults(e, ge), void 0, !1, !e.resolveDependencies || lu)).info
	}
	addEntryWithImplicitDependants(e, t) {
		const s = this.nextChunkNamePriority++
		return this.extendLoadModulesPromise(
			this.loadEntryModule(e.id, !1, e.importer, null).then(async (i) => {
				if ((uu(i, e, !1, s), !i.info.isEntry)) {
					this.implicitEntryModules.add(i)
					const s = await Promise.all(t.map((t) => this.loadEntryModule(t, !1, e.importer, i.id)))
					for (const e of s) i.implicitlyLoadedAfter.add(e)
					for (const e of i.implicitlyLoadedAfter) e.implicitlyLoadedBefore.add(i)
				}
				return i
			})
		)
	}
	async addModuleSource(e, t, s) {
		let i
		try {
			i = await this.graph.fileOperationQueue.run(async () => (await this.pluginDriver.hookFirst('load', [e])) ?? (await Uh(e, 'utf8')))
		} catch (s) {
			let i = `Could not load ${e}`
			throw (t && (i += ` (imported by ${V(t)})`), (i += `: ${s.message}`), (s.message = i), s)
		}
		const n =
				'string' == typeof i
					? { code: i }
					: null != i && 'object' == typeof i && 'string' == typeof i.code
					? i
					: Qe(
							(function (e) {
								return { code: 'BAD_LOADER', message: `Error loading "${V(e)}": plugin load hook should return a string, a { code, map } object, or nothing/null.` }
							})(e)
					  ),
			r = this.graph.cachedModules.get(e)
		if (
			!r ||
			r.customTransformCache ||
			r.originalCode !== n.code ||
			(await this.pluginDriver.hookFirst('shouldTransformCachedModule', [
				{ ast: r.ast, code: r.code, id: r.id, meta: r.meta, moduleSideEffects: r.moduleSideEffects, resolvedSources: r.resolvedIds, syntheticNamedExports: r.syntheticNamedExports }
			]))
		)
			s.updateOptions(n), s.setSource(await au(n, s, this.pluginDriver, this.options.onLog))
		else {
			if (r.transformFiles) for (const e of r.transformFiles) this.pluginDriver.emitFile(e)
			s.setSource(r)
		}
	}
	async awaitLoadModulesPromise() {
		let e
		do {
			;(e = this.latestLoadModulesPromise), await e
		} while (e !== this.latestLoadModulesPromise)
	}
	extendLoadModulesPromise(e) {
		return (this.latestLoadModulesPromise = Promise.all([e, this.latestLoadModulesPromise])), this.latestLoadModulesPromise.catch(() => {}), e
	}
	async fetchDynamicDependencies(e, t) {
		const s = await Promise.all(
			t.map((t) => t.then(async ([t, s]) => (null === s ? null : 'string' == typeof s ? ((t.resolution = s), null) : (t.resolution = await this.fetchResolvedDependency(V(s.id), e.id, s)))))
		)
		for (const t of s) t && (e.dynamicDependencies.add(t), t.dynamicImporters.push(e.id))
	}
	async fetchModule({ assertions: e, id: t, meta: s, moduleSideEffects: i, syntheticNamedExports: n }, r, o, a) {
		const l = this.modulesById.get(t)
		if (l instanceof jo) return r && wo(e, l.info.assertions) && this.options.onLog(Ae, Bt(l.info.assertions, e, t, r)), await this.handleExistingModule(l, o, a), l
		if (l instanceof Jt)
			return Qe({
				code: 'EXTERNAL_MODULES_CANNOT_BE_TRANSFORMED_TO_MODULES',
				message: `${l.id} is resolved as a module now, but it was an external module before. Please check whether there are conflicts in your Rollup options "external" and "manualChunks", manualChunks cannot include external modules.`
			})
		const c = new jo(this.graph, t, this.options, o, i, n, s, e)
		this.modulesById.set(t, c), (this.graph.watchFiles[t] = !0)
		const h = this.addModuleSource(t, r, c).then(() => [this.getResolveStaticDependencyPromises(c), this.getResolveDynamicImportPromises(c), u]),
			u = pu(h).then(() => this.pluginDriver.hookParallel('moduleParsed', [c.info]))
		u.catch(() => {}), this.moduleLoadPromises.set(c, h)
		const d = await h
		return a ? a === lu && (await u) : await this.fetchModuleDependencies(c, ...d), c
	}
	async fetchModuleDependencies(e, t, s, i) {
		this.modulesWithLoadedDependencies.has(e) ||
			(this.modulesWithLoadedDependencies.add(e), await Promise.all([this.fetchStaticDependencies(e, t), this.fetchDynamicDependencies(e, s)]), e.linkImports(), await i)
	}
	fetchResolvedDependency(e, t, s) {
		if (s.external) {
			const { assertions: i, external: n, id: r, moduleSideEffects: o, meta: a } = s
			let l = this.modulesById.get(r)
			if (l) {
				if (!(l instanceof Jt))
					return Qe(
						(function (e, t) {
							return { code: 'INVALID_EXTERNAL_ID', message: `"${e}" is imported as an external by "${V(t)}", but is already an existing non-external module id.` }
						})(e, t)
					)
				wo(l.info.assertions, i) && this.options.onLog(Ae, Bt(l.info.assertions, i, e, t))
			} else (l = new Jt(this.options, r, o, a, 'absolute' !== n && I(r), i)), this.modulesById.set(r, l)
			return Promise.resolve(l)
		}
		return this.fetchModule(s, t, !1, !1)
	}
	async fetchStaticDependencies(e, t) {
		for (const s of await Promise.all(t.map((t) => t.then(([t, s]) => this.fetchResolvedDependency(t, e.id, s))))) e.dependencies.add(s), s.importers.push(e.id)
		if (!this.options.treeshake || 'no-treeshake' === e.info.moduleSideEffects) for (const t of e.dependencies) t instanceof jo && (t.importedFromNotTreeshaken = !0)
	}
	getNormalizedResolvedIdWithoutDefaults(e, t, s) {
		const { makeAbsoluteExternalsRelative: i } = this.options
		if (e) {
			if ('object' == typeof e) {
				const n = e.external || this.options.external(e.id, t, !0)
				return { ...e, external: n && ('relative' === n || !I(e.id) || (!0 === n && du(e.id, s, i)) || 'absolute') }
			}
			const n = this.options.external(e, t, !0)
			return { external: n && (du(e, s, i) || 'absolute'), id: n && i ? hu(e, t) : e }
		}
		const n = i ? hu(s, t) : s
		return !1 === e || this.options.external(n, t, !0) ? { external: du(n, s, i) || 'absolute', id: n } : null
	}
	getResolveDynamicImportPromises(e) {
		return e.dynamicImports.map(async (t) => {
			const s = await this.resolveDynamicImport(
				e,
				'string' == typeof t.argument ? t.argument : t.argument.esTreeNode,
				e.id,
				(function (e) {
					const t = e.arguments?.[0]?.properties.find((e) => 'assert' === Io(e))?.value
					if (!t) return ge
					const s = t.properties
						.map((e) => {
							const t = Io(e)
							return 'string' == typeof t && 'string' == typeof e.value.value ? [t, e.value.value] : null
						})
						.filter((e) => !!e)
					return s.length > 0 ? Object.fromEntries(s) : ge
				})(t.node)
			)
			return s && 'object' == typeof s && (t.id = s.id), [t, s]
		})
	}
	getResolveStaticDependencyPromises(e) {
		return Array.from(e.sourcesWithAssertions, async ([t, s]) => [t, (e.resolvedIds[t] = e.resolvedIds[t] || this.handleInvalidResolvedId(await this.resolveId(t, e.id, ge, !1, s), t, e.id, s))])
	}
	getResolvedIdWithDefaults(e, t) {
		if (!e) return null
		const s = e.external || !1
		return {
			assertions: e.assertions || t,
			external: s,
			id: e.id,
			meta: e.meta || {},
			moduleSideEffects: e.moduleSideEffects ?? this.hasModuleSideEffects(e.id, !!s),
			resolvedBy: e.resolvedBy ?? 'rollup',
			syntheticNamedExports: e.syntheticNamedExports ?? !1
		}
	}
	async handleExistingModule(e, t, s) {
		const i = this.moduleLoadPromises.get(e)
		if (s) return s === lu ? pu(i) : i
		if (t) {
			;(e.info.isEntry = !0), this.implicitEntryModules.delete(e)
			for (const t of e.implicitlyLoadedAfter) t.implicitlyLoadedBefore.delete(e)
			e.implicitlyLoadedAfter.clear()
		}
		return this.fetchModuleDependencies(e, ...(await i))
	}
	handleInvalidResolvedId(e, t, s, i) {
		return null === e
			? w(t)
				? Qe(
						(function (e, t) {
							return { code: _t, exporter: e, id: t, message: `Could not resolve "${e}" from "${V(t)}"` }
						})(t, s)
				  )
				: (this.options.onLog(
						Ae,
						(function (e, t) {
							return {
								code: _t,
								exporter: e,
								id: t,
								message: `"${e}" is imported by "${V(t)}", but could not be resolved – treating it as an external dependency.`,
								url: De('troubleshooting/#warning-treating-module-as-external-dependency')
							}
						})(t, s)
				  ),
				  { assertions: i, external: !0, id: t, meta: {}, moduleSideEffects: this.hasModuleSideEffects(t, !0), resolvedBy: 'rollup', syntheticNamedExports: !1 })
			: (e.external &&
					e.syntheticNamedExports &&
					this.options.onLog(
						Ae,
						(function (e, t) {
							return { code: 'EXTERNAL_SYNTHETIC_EXPORTS', exporter: e, message: `External "${e}" cannot have "syntheticNamedExports" enabled (imported by "${V(t)}").` }
						})(t, s)
					),
			  e)
	}
	async loadEntryModule(e, t, s, i, n = !1) {
		const r = await Wh(e, s, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, ge, !0, ge)
		if (null == r)
			return Qe(
				null === i
					? (function (e) {
							return { code: Nt, message: `Could not resolve entry module "${V(e)}".` }
					  })(e)
					: (function (e, t) {
							return { code: Et, message: `Module "${V(e)}" that should be implicitly loaded before "${V(t)}" could not be resolved.` }
					  })(e, i)
			)
		const o = 'object' == typeof r && r.external
		return !1 === r || o
			? Qe(
					null === i
						? o && n
							? {
									code: 'EXTERNAL_MODULES_CANNOT_BE_INCLUDED_IN_MANUAL_CHUNKS',
									message: `"${e}" cannot be included in manualChunks because it is resolved as an external module by the "external" option or plugins.`
							  }
							: (function (e) {
									return { code: Nt, message: `Entry module "${V(e)}" cannot be external.` }
							  })(e)
						: (function (e, t) {
								return { code: Et, message: `Module "${V(e)}" that should be implicitly loaded before "${V(t)}" cannot be external.` }
						  })(e, i)
			  )
			: this.fetchModule(this.getResolvedIdWithDefaults('object' == typeof r ? r : { id: r }, ge), void 0, t, !1)
	}
	async resolveDynamicImport(e, t, s, i) {
		const n = await this.pluginDriver.hookFirst('resolveDynamicImport', [t, s, { assertions: i }])
		if ('string' != typeof t) return 'string' == typeof n ? n : n ? this.getResolvedIdWithDefaults(n, i) : null
		if (null == n) {
			const n = e.resolvedIds[t]
			return n ? (wo(n.assertions, i) && this.options.onLog(Ae, Bt(n.assertions, i, t, s)), n) : (e.resolvedIds[t] = this.handleInvalidResolvedId(await this.resolveId(t, e.id, ge, !1, i), t, e.id, i))
		}
		return this.handleInvalidResolvedId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(n, s, t), i), t, s, i)
	}
}
function hu(e, t) {
	return w(e) ? (t ? R(t, '..', e) : R(e)) : e
}
function uu(e, { fileName: t, name: s }, i, n) {
	if (null !== t) e.chunkFileNames.add(t)
	else if (null !== s) {
		let t = 0
		for (; e.chunkNames[t]?.priority < n; ) t++
		e.chunkNames.splice(t, 0, { isUserDefined: i, name: s, priority: n })
	}
}
function du(e, t, s) {
	return !0 === s || ('ifRelativeSource' === s && w(t)) || !I(e)
}
async function pu(e) {
	const [t, s] = await e
	return Promise.all([...t, ...s])
}
class fu extends Ti {
	constructor() {
		super(), (this.parent = null), this.variables.set('undefined', new co())
	}
	findVariable(e) {
		let t = this.variables.get(e)
		return t || ((t = new ln(e)), this.variables.set(e, t)), t
	}
}
function mu(e) {
	return Gl().update(e).digest('hex')
}
function gu(e, t, s, i, n) {
	const r = i.sanitizeFileName(e || 'asset')
	return Ma(
		Ra('function' == typeof i.assetFileNames ? i.assetFileNames({ name: e, source: t, type: 'asset' }) : i.assetFileNames, 'output.assetFileNames', {
			ext: () => N(r).slice(1),
			extname: () => N(r),
			hash: (e) => s.slice(0, Math.max(0, e || 8)),
			name: () => r.slice(0, Math.max(0, r.length - N(r).length))
		}),
		n
	)
}
function yu(e, { bundle: t }, s) {
	t[Na].has(e.toLowerCase())
		? s(
				Ae,
				(function (e) {
					return { code: lt, message: `The emitted file "${e}" overwrites a previously emitted file of the same name.` }
				})(e)
		  )
		: (t[e] = _a)
}
const xu = new Set(['chunk', 'asset', 'prebuilt-chunk'])
function Eu(e, t, s) {
	if (!('string' == typeof e || e instanceof Uint8Array)) {
		const e = t.fileName || t.name || s
		return Qe(Xt(`Could not set source for ${'string' == typeof e ? `asset "${e}"` : 'unnamed asset'}, asset source needs to be a string, Uint8Array or Buffer.`))
	}
	return e
}
function bu(e, t) {
	return 'string' != typeof e.fileName
		? Qe(
				((s = e.name || t),
				{
					code: st,
					message: `Plugin error - Unable to get file name for asset "${s}". Ensure that the source is set and that generate is called first. If you reference assets via import.meta.ROLLUP_FILE_URL_<referenceId>, you need to either have set their source after "renderStart" or need to provide an explicit "fileName" when emitting them.`
				})
		  )
		: e.fileName
	var s
}
function vu(e, t) {
	return e.fileName
		? e.fileName
		: t
		? t.get(e.module).getFileName()
		: Qe(
				((s = e.fileName || e.name),
				{ code: nt, message: `Plugin error - Unable to get file name for emitted chunk "${s}". You can only get file names once chunks have been generated after the "renderStart" hook.` })
		  )
	var s
}
class Su {
	constructor(e, t, s) {
		;(this.graph = e),
			(this.options = t),
			(this.facadeChunkByModule = null),
			(this.nextIdBase = 1),
			(this.output = null),
			(this.outputFileEmitters = []),
			(this.emitFile = (e) =>
				(function (e) {
					return Boolean(e && xu.has(e.type))
				})(e)
					? 'prebuilt-chunk' === e.type
						? this.emitPrebuiltChunk(e)
						: (function (e) {
								const t = e.fileName || e.name
								return !t || ('string' == typeof t && !B(t))
						  })(e)
						? 'chunk' === e.type
							? this.emitChunk(e)
							: this.emitAsset(e)
						: Qe(Xt(`The "fileName" or "name" properties of emitted chunks and assets must be strings that are neither absolute nor relative paths, received "${e.fileName || e.name}".`))
					: Qe(Xt(`Emitted files must be of type "asset", "chunk" or "prebuilt-chunk", received "${e && e.type}".`))),
			(this.finaliseAssets = () => {
				for (const [e, t] of this.filesByReferenceId)
					if ('asset' === t.type && 'string' != typeof t.fileName) return Qe({ code: 'ASSET_SOURCE_MISSING', message: `Plugin error creating asset "${t.name || e}" - no asset source set.` })
			}),
			(this.getFileName = (e) => {
				const t = this.filesByReferenceId.get(e)
				return t
					? 'chunk' === t.type
						? vu(t, this.facadeChunkByModule)
						: 'prebuilt-chunk' === t.type
						? t.fileName
						: bu(t, e)
					: Qe({ code: 'FILE_NOT_FOUND', message: `Plugin error - Unable to get file name for unknown file "${e}".` })
			}),
			(this.setAssetSource = (e, t) => {
				const s = this.filesByReferenceId.get(e)
				if (!s) return Qe({ code: 'ASSET_NOT_FOUND', message: `Plugin error - Unable to set the source for unknown asset "${e}".` })
				if ('asset' !== s.type) return Qe(Xt(`Asset sources can only be set for emitted assets but "${e}" is an emitted chunk.`))
				if (void 0 !== s.source) return Qe({ code: 'ASSET_SOURCE_ALREADY_SET', message: `Unable to set the source for asset "${s.name || e}", source already set.` })
				const i = Eu(t, s, e)
				if (this.output) this.finalizeAdditionalAsset(s, i, this.output)
				else {
					s.source = i
					for (const e of this.outputFileEmitters) e.finalizeAdditionalAsset(s, i, e.output)
				}
			}),
			(this.setChunkInformation = (e) => {
				this.facadeChunkByModule = e
			}),
			(this.setOutputBundle = (e, t) => {
				const s = (this.output = { bundle: e, fileNamesBySource: new Map(), outputOptions: t })
				for (const e of this.filesByReferenceId.values()) e.fileName && yu(e.fileName, s, this.options.onLog)
				const i = new Map()
				for (const e of this.filesByReferenceId.values())
					if ('asset' === e.type && void 0 !== e.source)
						if (e.fileName) this.finalizeAdditionalAsset(e, e.source, s)
						else {
							U(i, mu(e.source), () => []).push(e)
						}
					else 'prebuilt-chunk' === e.type && (this.output.bundle[e.fileName] = this.createPrebuiltChunk(e))
				for (const [e, t] of i) this.finalizeAssetsWithSameSource(t, e, s)
			}),
			(this.filesByReferenceId = s ? new Map(s.filesByReferenceId) : new Map()),
			s?.addOutputFileEmitter(this)
	}
	addOutputFileEmitter(e) {
		this.outputFileEmitters.push(e)
	}
	assignReferenceId(e, t) {
		let s = t
		do {
			s = Gl().update(s).digest('hex').slice(0, 8)
		} while (this.filesByReferenceId.has(s) || this.outputFileEmitters.some(({ filesByReferenceId: e }) => e.has(s)))
		;(e.referenceId = s), this.filesByReferenceId.set(s, e)
		for (const { filesByReferenceId: t } of this.outputFileEmitters) t.set(s, e)
		return s
	}
	createPrebuiltChunk(e) {
		return {
			code: e.code,
			dynamicImports: [],
			exports: e.exports || [],
			facadeModuleId: null,
			fileName: e.fileName,
			implicitlyLoadedBefore: [],
			importedBindings: {},
			imports: [],
			isDynamicEntry: !1,
			isEntry: !1,
			isImplicitEntry: !1,
			map: e.map || null,
			moduleIds: [],
			modules: {},
			name: e.fileName,
			preliminaryFileName: e.fileName,
			referencedFiles: [],
			sourcemapFileName: e.sourcemapFileName || null,
			type: 'chunk'
		}
	}
	emitAsset(e) {
		const t = void 0 === e.source ? void 0 : Eu(e.source, e, null),
			s = { fileName: e.fileName, name: e.name, needsCodeReference: !!e.needsCodeReference, referenceId: '', source: t, type: 'asset' },
			i = this.assignReferenceId(s, e.fileName || e.name || String(this.nextIdBase++))
		if (this.output) this.emitAssetWithReferenceId(s, this.output)
		else for (const e of this.outputFileEmitters) e.emitAssetWithReferenceId(s, e.output)
		return i
	}
	emitAssetWithReferenceId(e, t) {
		const { fileName: s, source: i } = e
		s && yu(s, t, this.options.onLog), void 0 !== i && this.finalizeAdditionalAsset(e, i, t)
	}
	emitChunk(e) {
		if (this.graph.phase > bo.LOAD_AND_PARSE) return Qe({ code: mt, message: 'Cannot emit chunks after module loading has finished.' })
		if ('string' != typeof e.id) return Qe(Xt(`Emitted chunks need to have a valid string id, received "${e.id}"`))
		const t = { fileName: e.fileName, module: null, name: e.name || e.id, referenceId: '', type: 'chunk' }
		return (
			this.graph.moduleLoader
				.emitChunk(e)
				.then((e) => (t.module = e))
				.catch(() => {}),
			this.assignReferenceId(t, e.id)
		)
	}
	emitPrebuiltChunk(e) {
		if ('string' != typeof e.code) return Qe(Xt(`Emitted prebuilt chunks need to have a valid string code, received "${e.code}".`))
		if ('string' != typeof e.fileName || B(e.fileName))
			return Qe(Xt(`The "fileName" property of emitted prebuilt chunks must be strings that are neither absolute nor relative paths, received "${e.fileName}".`))
		const t = { code: e.code, exports: e.exports, fileName: e.fileName, map: e.map, referenceId: '', type: 'prebuilt-chunk' },
			s = this.assignReferenceId(t, t.fileName)
		return this.output && (this.output.bundle[t.fileName] = this.createPrebuiltChunk(t)), s
	}
	finalizeAdditionalAsset(e, t, { bundle: s, fileNamesBySource: i, outputOptions: n }) {
		let { fileName: r, needsCodeReference: o, referenceId: a } = e
		if (!r) {
			const o = mu(t)
			;(r = i.get(o)), r || ((r = gu(e.name, t, o, n, s)), i.set(o, r))
		}
		const l = { ...e, fileName: r, source: t }
		this.filesByReferenceId.set(a, l)
		const c = s[r]
		'asset' === c?.type ? c.needsCodeReference && (c.needsCodeReference = o) : (s[r] = { fileName: r, name: e.name, needsCodeReference: o, source: t, type: 'asset' })
	}
	finalizeAssetsWithSameSource(e, t, { bundle: s, fileNamesBySource: i, outputOptions: n }) {
		let r,
			o = '',
			a = !0
		for (const i of e) {
			a && (a = i.needsCodeReference)
			const e = gu(i.name, i.source, t, n, s)
			;(!o || e.length < o.length || (e.length === o.length && e < o)) && ((o = e), (r = i))
		}
		i.set(t, o)
		for (const t of e) {
			const e = { ...t, fileName: o }
			this.filesByReferenceId.set(t.referenceId, e)
		}
		s[o] = { fileName: o, name: r.name, needsCodeReference: a, source: r.source, type: 'asset' }
	}
}
function Au(e, t, s, i, n) {
	return we[e] < we[n]
		? Ui
		: (n, r) => {
				null != r && s(Ae, { code: dt, message: `Plugin "${i}" tried to add a file position to a log or warning. This is only supported in the "transform" hook at the moment and will be ignored.` }),
					(n = Jh(n)).code && !n.pluginCode && (n.pluginCode = n.code),
					(n.code = t),
					(n.plugin = i),
					s(e, n)
		  }
}
function ku(t, s, i, n, r, o) {
	const { logLevel: a, onLog: l } = n
	let c,
		h = !0
	if (('string' != typeof t.cacheKey && (t.name.startsWith(qh) || t.name.startsWith(Hh) || o.has(t.name) ? (h = !1) : o.add(t.name)), s))
		if (h) {
			const e = t.cacheKey || t.name
			;(d = s[e] || (s[e] = Object.create(null))),
				(c = {
					delete: (e) => delete d[e],
					get(e) {
						const t = d[e]
						if (t) return (t[0] = 0), t[1]
					},
					has(e) {
						const t = d[e]
						return !!t && ((t[0] = 0), !0)
					},
					set(e, t) {
						d[e] = [0, t]
					}
				})
		} else (u = t.name), (c = { delete: () => Yh(u), get: () => Yh(u), has: () => Yh(u), set: () => Yh(u) })
	else c = Kh
	var u, d
	return {
		addWatchFile(e) {
			if (i.phase >= bo.GENERATE) return this.error({ code: mt, message: 'Cannot call "addWatchFile" after the build has finished.' })
			i.watchFiles[e] = !0
		},
		cache: c,
		debug: Au(Ie, 'PLUGIN_LOG', l, t.name, a),
		emitFile: r.emitFile.bind(r),
		error: (e) => Qe(qt(Jh(e), t.name)),
		getFileName: r.getFileName,
		getModuleIds: () => i.modulesById.keys(),
		getModuleInfo: i.getModuleInfo,
		getWatchFiles: () => Object.keys(i.watchFiles),
		info: Au(ke, 'PLUGIN_LOG', l, t.name, a),
		load: (e) => i.moduleLoader.preloadModule(e),
		meta: { rollupVersion: e, watchMode: i.watchMode },
		get moduleIds() {
			const e = i.modulesById.keys()
			return (function* () {
				Qt(
					`Accessing "this.moduleIds" on the plugin context by plugin ${t.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`,
					'plugin-development/#this-getmoduleids',
					!0,
					n,
					t.name
				),
					yield* e
			})()
		},
		parse: i.contextParse.bind(i),
		resolve: (e, s, { assertions: n, custom: r, isEntry: o, skipSelf: a } = me) => i.moduleLoader.resolveId(e, s, r, o, n || ge, a ? [{ importer: s, plugin: t, source: e }] : null),
		setAssetSource: r.setAssetSource,
		warn: Au(Ae, 'PLUGIN_WARNING', l, t.name, a)
	}
}
const Iu = Object.keys({
	buildEnd: 1,
	buildStart: 1,
	closeBundle: 1,
	closeWatcher: 1,
	load: 1,
	moduleParsed: 1,
	onLog: 1,
	options: 1,
	resolveDynamicImport: 1,
	resolveId: 1,
	shouldTransformCachedModule: 1,
	transform: 1,
	watchChange: 1
})
class wu {
	constructor(e, t, s, i, n) {
		;(this.graph = e),
			(this.options = t),
			(this.pluginCache = i),
			(this.sortedPlugins = new Map()),
			(this.unfulfilledActions = new Set()),
			(this.fileEmitter = new Su(e, t, n && n.fileEmitter)),
			(this.emitFile = this.fileEmitter.emitFile.bind(this.fileEmitter)),
			(this.getFileName = this.fileEmitter.getFileName.bind(this.fileEmitter)),
			(this.finaliseAssets = this.fileEmitter.finaliseAssets.bind(this.fileEmitter)),
			(this.setChunkInformation = this.fileEmitter.setChunkInformation.bind(this.fileEmitter)),
			(this.setOutputBundle = this.fileEmitter.setOutputBundle.bind(this.fileEmitter)),
			(this.plugins = [...(n ? n.plugins : []), ...s])
		const r = new Set()
		if (((this.pluginContexts = new Map(this.plugins.map((s) => [s, ku(s, i, e, t, this.fileEmitter, r)]))), n))
			for (const e of s)
				for (const s of Iu)
					s in e &&
						t.onLog(
							Ae,
							((o = e.name),
							{
								code: 'INPUT_HOOK_IN_OUTPUT_PLUGIN',
								message: `The "${s}" hook used by the output plugin ${o} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.`
							})
						)
		var o
	}
	createOutputPluginDriver(e) {
		return new wu(this.graph, this.options, e, this.pluginCache, this)
	}
	getUnfulfilledHookActions() {
		return this.unfulfilledActions
	}
	hookFirst(e, t, s, i) {
		return this.hookFirstAndGetPlugin(e, t, s, i).then((e) => e && e[0])
	}
	async hookFirstAndGetPlugin(e, t, s, i) {
		for (const n of this.getSortedPlugins(e)) {
			if (i?.has(n)) continue
			const r = await this.runHook(e, t, n, s)
			if (null != r) return [r, n]
		}
		return null
	}
	hookFirstSync(e, t, s) {
		for (const i of this.getSortedPlugins(e)) {
			const n = this.runHookSync(e, t, i, s)
			if (null != n) return n
		}
		return null
	}
	async hookParallel(e, t, s) {
		const i = []
		for (const n of this.getSortedPlugins(e)) n[e].sequential ? (await Promise.all(i), (i.length = 0), await this.runHook(e, t, n, s)) : i.push(this.runHook(e, t, n, s))
		await Promise.all(i)
	}
	hookReduceArg0(e, [t, ...s], i, n) {
		let r = Promise.resolve(t)
		for (const t of this.getSortedPlugins(e)) r = r.then((r) => this.runHook(e, [r, ...s], t, n).then((e) => i.call(this.pluginContexts.get(t), r, e, t)))
		return r
	}
	hookReduceArg0Sync(e, [t, ...s], i, n) {
		for (const r of this.getSortedPlugins(e)) {
			const o = [t, ...s],
				a = this.runHookSync(e, o, r, n)
			t = i.call(this.pluginContexts.get(r), t, a, r)
		}
		return t
	}
	async hookReduceValue(e, t, s, i) {
		const n = [],
			r = []
		for (const t of this.getSortedPlugins(e, $u)) t[e].sequential ? (n.push(...(await Promise.all(r))), (r.length = 0), n.push(await this.runHook(e, s, t))) : r.push(this.runHook(e, s, t))
		return n.push(...(await Promise.all(r))), n.reduce(i, await t)
	}
	hookReduceValueSync(e, t, s, i, n) {
		let r = t
		for (const t of this.getSortedPlugins(e)) {
			const o = this.runHookSync(e, s, t, n)
			r = i.call(this.pluginContexts.get(t), r, o, t)
		}
		return r
	}
	hookSeq(e, t, s) {
		let i = Promise.resolve()
		for (const n of this.getSortedPlugins(e)) i = i.then(() => this.runHook(e, t, n, s))
		return i.then(Nu)
	}
	getSortedPlugins(e, t) {
		return U(this.sortedPlugins, e, () => Pu(e, this.plugins, t))
	}
	runHook(e, t, s, i) {
		const n = s[e],
			r = 'object' == typeof n ? n.handler : n
		let o = this.pluginContexts.get(s)
		i && (o = i(o, s))
		let a = null
		return Promise.resolve()
			.then(() => {
				if ('function' != typeof r) return r
				const i = r.apply(o, t)
				return i?.then ? ((a = [s.name, e, t]), this.unfulfilledActions.add(a), Promise.resolve(i).then((e) => (this.unfulfilledActions.delete(a), e))) : i
			})
			.catch((t) => (null !== a && this.unfulfilledActions.delete(a), Qe(qt(t, s.name, { hook: e }))))
	}
	runHookSync(e, t, s, i) {
		const n = s[e],
			r = 'object' == typeof n ? n.handler : n
		let o = this.pluginContexts.get(s)
		i && (o = i(o, s))
		try {
			return r.apply(o, t)
		} catch (t) {
			return Qe(qt(t, s.name, { hook: e }))
		}
	}
}
function Pu(e, t, s = Cu) {
	const i = [],
		n = [],
		r = []
	for (const o of t) {
		const t = o[e]
		if (t) {
			if ('object' == typeof t) {
				if ((s(t.handler, e, o), 'pre' === t.order)) {
					i.push(o)
					continue
				}
				if ('post' === t.order) {
					r.push(o)
					continue
				}
			} else s(t, e, o)
			n.push(o)
		}
	}
	return [...i, ...n, ...r]
}
function Cu(e, t, s) {
	'function' != typeof e &&
		Qe(
			(function (e, t) {
				return { code: ft, hook: e, message: `Error running plugin hook "${e}" for plugin "${t}", expected a function hook or an object with a "handler" function.`, plugin: t }
			})(t, s.name)
		)
}
function $u(e, t, s) {
	if ('string' != typeof e && 'function' != typeof e)
		return Qe(
			(function (e, t) {
				return { code: ft, hook: e, message: `Error running plugin hook "${e}" for plugin "${t}", expected a string, a function hook or an object with a "handler" string or function.`, plugin: t }
			})(t, s.name)
		)
}
function Nu() {}
class _u {
	constructor(e) {
		;(this.maxParallel = e), (this.queue = []), (this.workerCount = 0)
	}
	run(e) {
		return new Promise((t, s) => {
			this.queue.push({ reject: s, resolve: t, task: e }), this.work()
		})
	}
	async work() {
		if (this.workerCount >= this.maxParallel) return
		let e
		for (this.workerCount++; (e = this.queue.shift()); ) {
			const { reject: t, resolve: s, task: i } = e
			try {
				s(await i())
			} catch (e) {
				t(e)
			}
		}
		this.workerCount--
	}
}
class Ru {
	constructor(e, t) {
		if (
			((this.options = e),
			(this.astLru = (function (e) {
				var t,
					s,
					i,
					n = e || 1
				function r(e, r) {
					++t > n && ((i = s), o(1), ++t), (s[e] = r)
				}
				function o(e) {
					;(t = 0), (s = Object.create(null)), e || (i = Object.create(null))
				}
				return (
					o(),
					{
						clear: o,
						has: function (e) {
							return void 0 !== s[e] || void 0 !== i[e]
						},
						get: function (e) {
							var t = s[e]
							return void 0 !== t ? t : void 0 !== (t = i[e]) ? (r(e, t), t) : void 0
						},
						set: function (e, t) {
							void 0 !== s[e] ? (s[e] = t) : r(e, t)
						}
					}
				)
			})(5)),
			(this.cachedModules = new Map()),
			(this.deoptimizationTracker = new te()),
			(this.entryModules = []),
			(this.modulesById = new Map()),
			(this.needsTreeshakingPass = !1),
			(this.phase = bo.LOAD_AND_PARSE),
			(this.scope = new fu()),
			(this.watchFiles = Object.create(null)),
			(this.watchMode = !1),
			(this.externalModules = []),
			(this.implicitEntryModules = []),
			(this.modules = []),
			(this.getModuleInfo = (e) => {
				const t = this.modulesById.get(e)
				return t ? t.info : null
			}),
			!1 !== e.cache)
		) {
			if (e.cache?.modules) for (const t of e.cache.modules) this.cachedModules.set(t.id, t)
			this.pluginCache = e.cache?.plugins || Object.create(null)
			for (const e in this.pluginCache) {
				const t = this.pluginCache[e]
				for (const e of Object.values(t)) e[0]++
			}
		}
		if (t) {
			this.watchMode = !0
			const e = (...e) => this.pluginDriver.hookParallel('watchChange', e),
				s = () => this.pluginDriver.hookParallel('closeWatcher', [])
			t.onCurrentRun('change', e), t.onCurrentRun('close', s)
		}
		;(this.pluginDriver = new wu(this, e, e.plugins, this.pluginCache)),
			(this.acornParser = Tc.extend(...e.acornInjectPlugins)),
			(this.moduleLoader = new cu(this, this.modulesById, this.options, this.pluginDriver)),
			(this.fileOperationQueue = new _u(e.maxParallelFileOps)),
			(this.pureFunctions = (({ treeshake: e }) => {
				const t = Object.create(null)
				for (const s of e ? e.manualPureFunctions : []) {
					let e = t
					for (const t of s.split('.')) e = e[t] || (e[t] = Object.create(null))
					e[ji] = !0
				}
				return t
			})(e))
	}
	async build() {
		Oo('generate module graph', 2),
			await this.generateModuleGraph(),
			Do('generate module graph', 2),
			Oo('sort and bind modules', 2),
			(this.phase = bo.ANALYSE),
			this.sortModules(),
			Do('sort and bind modules', 2),
			Oo('mark included statements', 2),
			this.includeStatements(),
			Do('mark included statements', 2),
			(this.phase = bo.GENERATE)
	}
	contextParse(e, t = {}) {
		const s = t.onComment,
			i = []
		t.onComment = s && 'function' == typeof s ? (e, n, r, o, ...a) => (i.push({ end: o, start: r, type: e ? 'Block' : 'Line', value: n }), s.call(t, e, n, r, o, ...a)) : i
		const n = this.acornParser.parse(e, { ...this.options.acorn, ...t })
		return (
			'object' == typeof s && s.push(...i),
			(t.onComment = s),
			(function (e, t, s) {
				const i = [],
					n = []
				for (const t of e) {
					for (const [e, s] of Xs) s.test(t.value) && i.push({ ...t, annotationType: e })
					js.test(t.value) && n.push(t)
				}
				for (const e of n) Qs(t, e, !1)
				Ws(t, { annotationIndex: 0, annotations: i, code: s })
			})(i, n, e),
			n
		)
	}
	getCache() {
		for (const e in this.pluginCache) {
			const t = this.pluginCache[e]
			let s = !0
			for (const [e, i] of Object.entries(t)) i[0] >= this.options.experimentalCacheExpiry ? delete t[e] : (s = !1)
			s && delete this.pluginCache[e]
		}
		return { modules: this.modules.map((e) => e.toJSON()), plugins: this.pluginCache }
	}
	async generateModuleGraph() {
		var e
		if (
			(({ entryModules: this.entryModules, implicitEntryModules: this.implicitEntryModules } = await this.moduleLoader.addEntryModules(
				((e = this.options.input),
				Array.isArray(e)
					? e.map((e) => ({ fileName: null, id: e, implicitlyLoadedAfter: [], importer: void 0, name: null }))
					: Object.entries(e).map(([e, t]) => ({ fileName: null, id: t, implicitlyLoadedAfter: [], importer: void 0, name: e }))),
				!0
			)),
			0 === this.entryModules.length)
		)
			throw new Error('You must supply options.input to rollup')
		for (const e of this.modulesById.values()) e instanceof jo ? this.modules.push(e) : this.externalModules.push(e)
	}
	includeStatements() {
		const e = [...this.entryModules, ...this.implicitEntryModules]
		for (const t of e) Vo(t)
		if (this.options.treeshake) {
			let t = 1
			do {
				Oo(`treeshaking pass ${t}`, 3), (this.needsTreeshakingPass = !1)
				for (const e of this.modules) e.isExecuted && ('no-treeshake' === e.info.moduleSideEffects ? e.includeAllInBundle() : e.include())
				if (1 === t) for (const t of e) !1 !== t.preserveSignature && (t.includeAllExports(!1), (this.needsTreeshakingPass = !0))
				Do('treeshaking pass ' + t++, 3)
			} while (this.needsTreeshakingPass)
		} else for (const e of this.modules) e.includeAllInBundle()
		for (const e of this.externalModules) e.warnUnusedImports()
		for (const e of this.implicitEntryModules) for (const t of e.implicitlyLoadedAfter) t.info.isEntry || t.isIncluded() || Qe(Gt(t))
	}
	sortModules() {
		const { orderedModules: e, cyclePaths: t } = (function (e) {
			let t = 0
			const s = [],
				i = new Set(),
				n = new Set(),
				r = new Map(),
				o = [],
				a = (e) => {
					if (e instanceof jo) {
						for (const t of e.dependencies) r.has(t) ? i.has(t) || s.push(Ja(t, e, r)) : (r.set(t, e), a(t))
						for (const t of e.implicitlyLoadedBefore) n.add(t)
						for (const { resolution: t } of e.dynamicImports) t instanceof jo && n.add(t)
						o.push(e)
					}
					;(e.execIndex = t++), i.add(e)
				}
			for (const t of e) r.has(t) || (r.set(t, null), a(t))
			for (const e of n) r.has(e) || (r.set(e, null), a(e))
			return { cyclePaths: s, orderedModules: o }
		})(this.entryModules)
		for (const e of t) this.options.onLog(Ae, Lt(e))
		this.modules = e
		for (const e of this.modules) e.bindReferences()
		this.warnForMissingExports()
	}
	warnForMissingExports() {
		for (const e of this.modules) for (const t of e.importDescriptions.values()) '*' === t.name || t.module.getVariableForExportName(t.name)[0] || e.log(Ae, Ut(t.name, e.id, t.module.id), t.start)
	}
}
function Mu(e, t) {
	return t()
}
function Ou(t, s, i, n) {
	t = Pu('onLog', t)
	const r = we[n],
		o = (n, a, l = xe) => {
			if (!(we[n] < r)) {
				for (const s of t) {
					if (l.has(s)) continue
					const { onLog: t } = s,
						c = (e) => (we[e] < r ? Ui : (t) => o(e, Jh(t), new Set(l).add(s)))
					if (!1 === ('handler' in t ? t.handler : t).call({ debug: c(Ie), error: (e) => Qe(Jh(e)), info: c(ke), meta: { rollupVersion: e, watchMode: i }, warn: c(Ae) }, n, a)) return
				}
				s(n, a)
			}
		}
	return o
}
const Du = '{'.charCodeAt(0),
	Lu = ' '.charCodeAt(0),
	Tu = 'assert'
function Vu(e) {
	const t = e.acorn || zh,
		{ tokTypes: s, TokenType: i } = t
	return class extends e {
		constructor(...e) {
			super(...e), (this.assertToken = new i(Tu))
		}
		_codeAt(e) {
			return this.input.charCodeAt(e)
		}
		_eat(e) {
			this.type !== e && this.unexpected(), this.next()
		}
		readToken(e) {
			let t = 0
			for (; t < 6; t++) if (this._codeAt(this.pos + t) !== Tu.charCodeAt(t)) return super.readToken(e)
			for (; this._codeAt(this.pos + t) !== Du; t++) if (this._codeAt(this.pos + t) !== Lu) return super.readToken(e)
			return '{' === this.type.label ? super.readToken(e) : ((this.pos += 6), this.finishToken(this.assertToken))
		}
		parseDynamicImport(e) {
			if ((this.next(), (e.source = this.parseMaybeAssign()), this.eat(s.comma))) {
				const t = this.parseObj(!1)
				e.arguments = [t]
			}
			return this._eat(s.parenR), this.finishNode(e, 'ImportExpression')
		}
		parseExport(e, t) {
			if ((this.next(), this.eat(s.star))) {
				if (
					(this.options.ecmaVersion >= 11 && (this.eatContextual('as') ? ((e.exported = this.parseIdent(!0)), this.checkExport(t, e.exported.name, this.lastTokStart)) : (e.exported = null)),
					this.expectContextual('from'),
					this.type !== s.string && this.unexpected(),
					(e.source = this.parseExprAtom()),
					this.type === this.assertToken || this.type === s._with)
				) {
					this.next()
					const t = this.parseImportAssertions()
					t && (e.assertions = t)
				}
				return this.semicolon(), this.finishNode(e, 'ExportAllDeclaration')
			}
			if (this.eat(s._default)) {
				var i
				if ((this.checkExport(t, 'default', this.lastTokStart), this.type === s._function || (i = this.isAsyncFunction()))) {
					var n = this.startNode()
					this.next(), i && this.next(), (e.declaration = this.parseFunction(n, 5, !1, i))
				} else if (this.type === s._class) {
					var r = this.startNode()
					e.declaration = this.parseClass(r, 'nullableID')
				} else (e.declaration = this.parseMaybeAssign()), this.semicolon()
				return this.finishNode(e, 'ExportDefaultDeclaration')
			}
			if (this.shouldParseExportStatement())
				(e.declaration = this.parseStatement(null)),
					'VariableDeclaration' === e.declaration.type ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id.name, e.declaration.id.start),
					(e.specifiers = []),
					(e.source = null)
			else {
				if (((e.declaration = null), (e.specifiers = this.parseExportSpecifiers(t)), this.eatContextual('from'))) {
					if ((this.type !== s.string && this.unexpected(), (e.source = this.parseExprAtom()), this.type === this.assertToken || this.type === s._with)) {
						this.next()
						const t = this.parseImportAssertions()
						t && (e.assertions = t)
					}
				} else {
					for (var o = 0, a = e.specifiers; o < a.length; o += 1) {
						var l = a[o]
						this.checkUnreserved(l.local), this.checkLocalExport(l.local)
					}
					e.source = null
				}
				this.semicolon()
			}
			return this.finishNode(e, 'ExportNamedDeclaration')
		}
		parseImport(e) {
			if (
				(this.next(),
				this.type === s.string
					? ((e.specifiers = []), (e.source = this.parseExprAtom()))
					: ((e.specifiers = this.parseImportSpecifiers()), this.expectContextual('from'), (e.source = this.type === s.string ? this.parseExprAtom() : this.unexpected())),
				this.type === this.assertToken || this.type == s._with)
			) {
				this.next()
				const t = this.parseImportAssertions()
				t && (e.assertions = t)
			}
			return this.semicolon(), this.finishNode(e, 'ImportDeclaration')
		}
		parseImportAssertions() {
			this._eat(s.braceL)
			const e = this.parseAssertEntries()
			return this._eat(s.braceR), e
		}
		parseAssertEntries() {
			const e = [],
				t = new Set()
			do {
				if (this.type === s.braceR) break
				const i = this.startNode()
				let n
				;(n = this.type === s.string ? this.parseLiteral(this.value) : this.parseIdent(!0)),
					this.next(),
					(i.key = n),
					t.has(i.key.name) && this.raise(this.pos, 'Duplicated key in assertions'),
					t.add(i.key.name),
					this.type !== s.string && this.raise(this.pos, 'Only string is supported as an assertion value'),
					(i.value = this.parseLiteral(this.value)),
					e.push(this.finishNode(i, 'ImportAttribute'))
			} while (this.eat(s.comma))
			return e
		}
	}
}
function Bu(e) {
	return Array.isArray(e) ? e.filter(Boolean) : e ? [e] : []
}
const zu = (e) => ({ ecmaVersion: 'latest', sourceType: 'module', ...e.acorn }),
	Fu = (e) => [Vu, ...Bu(e.acornInjectPlugins)],
	ju = (e) => (!0 === e.cache ? void 0 : e.cache?.cache || e.cache),
	Uu = (e) => {
		if (!0 === e) return () => !0
		if ('function' == typeof e) return (t, ...s) => (!t.startsWith('\0') && e(t, ...s)) || !1
		if (e) {
			const t = new Set(),
				s = []
			for (const i of Bu(e)) i instanceof RegExp ? s.push(i) : t.add(i)
			return (e, ...i) => t.has(e) || s.some((t) => t.test(e))
		}
		return () => !1
	},
	Gu = (e, t, s) => {
		const i = e.inlineDynamicImports
		return i && Zt('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.', We, !0, t, s), i
	},
	Wu = (e) => {
		const t = e.input
		return null == t ? [] : 'string' == typeof t ? [t] : t
	},
	qu = (e, t, s) => {
		const i = e.manualChunks
		return i && Zt('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.', He, !0, t, s), i
	},
	Hu = (e, t, s) => {
		const i = e.maxParallelFileReads
		'number' == typeof i && Zt('The "maxParallelFileReads" option is deprecated. Use the "maxParallelFileOps" option instead.', 'configuration-options/#maxparallelfileops', !0, t, s)
		const n = e.maxParallelFileOps ?? i
		return 'number' == typeof n ? (n <= 0 ? 1 / 0 : n) : 20
	},
	Ku = (e, t) => {
		const s = e.moduleContext
		if ('function' == typeof s) return (e) => s(e) ?? t
		if (s) {
			const e = Object.create(null)
			for (const [t, i] of Object.entries(s)) e[R(t)] = i
			return (s) => e[s] ?? t
		}
		return () => t
	},
	Yu = (e, t, s) => {
		const i = e.preserveModules
		return i && Zt('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.', 'configuration-options/#output-preservemodules', !0, t, s), i
	},
	Xu = (e) => {
		if (!1 === e.treeshake) return !1
		const t = ru(e.treeshake, iu, 'treeshake', 'configuration-options/#treeshake', 'false, true, ')
		return {
			annotations: !1 !== t.annotations,
			correctVarValueBeforeDeclaration: !0 === t.correctVarValueBeforeDeclaration,
			manualPureFunctions: t.manualPureFunctions ?? ye,
			moduleSideEffects: Qu(t.moduleSideEffects),
			propertyReadSideEffects: 'always' === t.propertyReadSideEffects ? 'always' : !1 !== t.propertyReadSideEffects,
			tryCatchDeoptimization: !1 !== t.tryCatchDeoptimization,
			unknownGlobalSideEffects: !1 !== t.unknownGlobalSideEffects
		}
	},
	Qu = (e) => {
		if ('boolean' == typeof e) return () => e
		if ('no-external' === e) return (e, t) => !t
		if ('function' == typeof e) return (t, s) => !!t.startsWith('\0') || !1 !== e(t, s)
		if (Array.isArray(e)) {
			const t = new Set(e)
			return (e) => t.has(e)
		}
		return e && Qe(jt('treeshake.moduleSideEffects', 'configuration-options/#treeshake-modulesideeffects', 'please use one of false, "no-external", a function or an array')), () => !0
	},
	Zu = /[\u0000-\u001F"#$&*+,:;<=>?[\]^`{|}\u007F]/g,
	Ju = /^[a-z]:/i
function ed(e) {
	const t = Ju.exec(e),
		s = t ? t[0] : ''
	return s + e.slice(s.length).replace(Zu, '_')
}
const td = (e, t, s) => {
		const { file: i } = e
		if ('string' == typeof i) {
			if (t) return Qe(jt('output.file', Be, 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'))
			if (!Array.isArray(s.input)) return Qe(jt('output.file', Be, 'you must set "output.dir" instead of "output.file" when providing named inputs'))
		}
		return i
	},
	sd = (e) => {
		const t = e.format
		switch (t) {
			case void 0:
			case 'es':
			case 'esm':
			case 'module':
				return 'es'
			case 'cjs':
			case 'commonjs':
				return 'cjs'
			case 'system':
			case 'systemjs':
				return 'system'
			case 'amd':
			case 'iife':
			case 'umd':
				return t
			default:
				return Qe(jt('output.format', je, 'Valid values are "amd", "cjs", "system", "es", "iife" or "umd"', t))
		}
	},
	id = (e, t) => {
		const s = (e.inlineDynamicImports ?? t.inlineDynamicImports) || !1,
			{ input: i } = t
		return s && (Array.isArray(i) ? i : Object.keys(i)).length > 1 ? Qe(jt('output.inlineDynamicImports', We, 'multiple inputs are not supported when "output.inlineDynamicImports" is true')) : s
	},
	nd = (e, t, s) => {
		const i = (e.preserveModules ?? s.preserveModules) || !1
		if (i) {
			if (t) return Qe(jt('output.inlineDynamicImports', We, 'this option is not supported for "output.preserveModules"'))
			if (!1 === s.preserveEntrySignatures)
				return Qe(jt('preserveEntrySignatures', 'configuration-options/#preserveentrysignatures', 'setting this option to false is not supported for "output.preserveModules"'))
		}
		return i
	},
	rd = (e, t) => {
		const s = e.preferConst
		return (
			null != s &&
				Qt('The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.', 'configuration-options/#output-generatedcode-constbindings', !0, t),
			!!s
		)
	},
	od = (e) => {
		const { preserveModulesRoot: t } = e
		if (null != t) return R(t)
	},
	ad = (e) => {
		const t = { autoId: !1, basePath: '', define: 'define', forceJsExtensionForImports: !1, ...e.amd }
		return (t.autoId || t.basePath) && t.id
			? Qe(jt('output.amd.id', Ve, 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'))
			: t.basePath && !t.autoId
			? Qe(jt('output.amd.basePath', 'configuration-options/#output-amd-basepath', 'this option only works with "output.amd.autoId"'))
			: t.autoId
			? { autoId: !0, basePath: t.basePath, define: t.define, forceJsExtensionForImports: t.forceJsExtensionForImports }
			: { autoId: !1, define: t.define, forceJsExtensionForImports: t.forceJsExtensionForImports, id: t.id }
	},
	ld = (e, t) => {
		const s = e[t]
		return 'function' == typeof s ? s : () => s || ''
	},
	cd = (e, t) => {
		const { dir: s } = e
		return 'string' == typeof s && 'string' == typeof t ? Qe(jt('output.dir', Be, 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks')) : s
	},
	hd = (e, t, s) => {
		const i = e.dynamicImportFunction
		return (
			i &&
				(Qt('The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.', 'plugin-development/#renderdynamicimport', !0, t),
				'es' !== s && t.onLog(Ae, jt('output.dynamicImportFunction', 'configuration-options/#output-dynamicimportfunction', 'this option is ignored for formats other than "es"'))),
			i
		)
	},
	ud = (e, t) => {
		const s = e.entryFileNames
		return null == s && t.add('entryFileNames'), s ?? '[name].js'
	}
function dd(e, t) {
	const s = e.experimentalDeepDynamicChunkOptimization
	return (
		null != s && Qt('The "output.experimentalDeepDynamicChunkOptimization" option is deprecated as Rollup always runs the full chunking algorithm now. The option should be removed.', Ue, !0, t),
		s || !1
	)
}
function pd(e, t) {
	const s = e.exports
	if (null == s) t.add('exports')
	else if (!['default', 'named', 'none', 'auto'].includes(s))
		return Qe({ code: ut, message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${s}".`, url: De(ze) })
	return s || 'auto'
}
const fd = (e, t) => {
		const s = ru(e.generatedCode, nu, 'output.generatedCode', 'configuration-options/#output-generatedcode', '')
		return {
			arrowFunctions: !0 === s.arrowFunctions,
			constBindings: !0 === s.constBindings || t,
			objectShorthand: !0 === s.objectShorthand,
			reservedNamesAsProps: !1 !== s.reservedNamesAsProps,
			symbols: !0 === s.symbols
		}
	},
	md = (e, t) => {
		if (t) return ''
		const s = e.indent
		return !1 === s ? '' : s ?? !0
	},
	gd = new Set(['compat', 'auto', 'esModule', 'default', 'defaultOnly']),
	yd = (e) => {
		const t = e.interop
		if ('function' == typeof t) {
			const e = Object.create(null)
			let s = null
			return (i) => (null === i ? s || xd((s = t(i))) : i in e ? e[i] : xd((e[i] = t(i))))
		}
		return void 0 === t ? () => 'default' : () => xd(t)
	},
	xd = (e) => (gd.has(e) ? e : Qe(jt('output.interop', qe, `use one of ${Array.from(gd, (e) => JSON.stringify(e)).join(', ')}`, e))),
	Ed = (e, t, s, i) => {
		const n = e.manualChunks || i.manualChunks
		if (n) {
			if (t) return Qe(jt('output.manualChunks', He, 'this option is not supported for "output.inlineDynamicImports"'))
			if (s) return Qe(jt('output.manualChunks', He, 'this option is not supported for "output.preserveModules"'))
		}
		return n || {}
	},
	bd = (e, t, s) => e.minifyInternalExports ?? (s || 'es' === t || 'system' === t),
	vd = (e, t, s) => {
		const i = e.namespaceToStringTag
		return null != i
			? (Qt('The "output.namespaceToStringTag" option is deprecated. Use the "output.generatedCode.symbols" option instead.', 'configuration-options/#output-generatedcode-symbols', !0, s), i)
			: t.symbols || !1
	},
	Sd = (e, t) => {
		const s = e.sourcemapFileNames
		return null == s && t.add('sourcemapFileNames'), s
	},
	Ad = (e) => {
		const { sourcemapBaseUrl: t } = e
		if (t)
			return (function (e) {
				try {
					new URL(e)
				} catch {
					return !1
				}
				return !0
			})(t)
				? (s = t).endsWith('/')
					? s
					: s + '/'
				: Qe(jt('output.sourcemapBaseUrl', 'configuration-options/#output-sourcemapbaseurl', `must be a valid URL, received ${JSON.stringify(t)}`))
		var s
	}
function kd(t) {
	return (async function (t, s) {
		const { options: i, unsetOptions: n } = await (async function (t, s) {
			if (!t) throw new Error('You must supply an options object to rollup')
			const i = await (async function (t, s) {
					const i = Pu('options', await ou(t.plugins)),
						n = t.logLevel || ke,
						r = Ou(i, Xh(t, n), s, n)
					for (const o of i) {
						const { name: i, options: a } = o,
							l = 'handler' in a ? a.handler : a,
							c = await l.call(
								{
									debug: Au(Ie, 'PLUGIN_LOG', r, i, n),
									error: (e) => Qe(qt(Jh(e), i, { hook: 'onLog' })),
									info: Au(ke, 'PLUGIN_LOG', r, i, n),
									meta: { rollupVersion: e, watchMode: s },
									warn: Au(Ae, 'PLUGIN_WARNING', r, i, n)
								},
								t
							)
						c && (t = c)
					}
					return t
				})(t, s),
				{ options: n, unsetOptions: r } = await (async function (e, t) {
					const s = new Set(),
						i = e.context ?? 'undefined',
						n = await ou(e.plugins),
						r = e.logLevel || ke,
						o = Ou(n, Xh(e, r), t, r),
						a = e.strictDeprecations || !1,
						l = Hu(e, o, a),
						c = {
							acorn: zu(e),
							acornInjectPlugins: Fu(e),
							cache: ju(e),
							context: i,
							experimentalCacheExpiry: e.experimentalCacheExpiry ?? 10,
							experimentalLogSideEffects: e.experimentalLogSideEffects || !1,
							external: Uu(e.external),
							inlineDynamicImports: Gu(e, o, a),
							input: Wu(e),
							logLevel: r,
							makeAbsoluteExternalsRelative: e.makeAbsoluteExternalsRelative ?? 'ifRelativeSource',
							manualChunks: qu(e, o, a),
							maxParallelFileOps: l,
							maxParallelFileReads: l,
							moduleContext: Ku(e, i),
							onLog: o,
							onwarn: (e) => o(Ae, e),
							perf: e.perf || !1,
							plugins: n,
							preserveEntrySignatures: e.preserveEntrySignatures ?? 'exports-only',
							preserveModules: Yu(e, o, a),
							preserveSymlinks: e.preserveSymlinks || !1,
							shimMissingExports: e.shimMissingExports || !1,
							strictDeprecations: a,
							treeshake: Xu(e)
						}
					return su(e, [...Object.keys(c), 'watch'], 'input options', o, /^(output)$/), { options: c, unsetOptions: s }
				})(i, s)
			return Id(n.plugins, qh), { options: n, unsetOptions: r }
		})(t, null !== s)
		!(function (e) {
			e.perf ? (($o = new Map()), (Oo = _o), (Do = Ro), (e.plugins = e.plugins.map(To))) : ((Oo = Ui), (Do = Ui))
		})(i)
		const r = new Ru(i, s),
			o = !1 !== t.cache
		t.cache && ((i.cache = void 0), (t.cache = void 0))
		Oo('BUILD', 1),
			await Mu(r.pluginDriver, async () => {
				try {
					Oo('initialize', 2), await r.pluginDriver.hookParallel('buildStart', [i]), Do('initialize', 2), await r.build()
				} catch (e) {
					const t = Object.keys(r.watchFiles)
					throw (t.length > 0 && (e.watchFiles = t), await r.pluginDriver.hookParallel('buildEnd', [e]), await r.pluginDriver.hookParallel('closeBundle', []), e)
				}
				await r.pluginDriver.hookParallel('buildEnd', [])
			}),
			Do('BUILD', 1)
		const a = {
			cache: o ? r.getCache() : void 0,
			async close() {
				a.closed || ((a.closed = !0), await r.pluginDriver.hookParallel('closeBundle', []))
			},
			closed: !1,
			generate: async (e) => (a.closed ? Qe(Mt()) : wd(!1, i, n, e, r)),
			watchFiles: Object.keys(r.watchFiles),
			write: async (e) => (a.closed ? Qe(Mt()) : wd(!0, i, n, e, r))
		}
		i.perf && (a.getTimings = Mo)
		return a
	})(t, null)
}
function Id(e, t) {
	for (const [s, i] of e.entries()) i.name || (i.name = `${t}${s + 1}`)
}
async function wd(e, t, s, i, n) {
	const {
		options: r,
		outputPluginDriver: o,
		unsetOptions: a
	} = await (async function (e, t, s, i) {
		if (!e) throw new Error('You must supply an options object')
		const n = await ou(e.plugins)
		Id(n, Hh)
		const r = t.createOutputPluginDriver(n)
		return { ...(await Pd(s, i, e, r)), outputPluginDriver: r }
	})(i, n.pluginDriver, t, s)
	return Mu(0, async () => {
		const s = new Kl(r, a, t, o, n),
			i = await s.generate(e)
		if (e) {
			if ((Oo('WRITE', 1), !r.dir && !r.file)) return Qe({ code: St, message: 'You must specify "output.file" or "output.dir" for the build.', url: De(Be) })
			await Promise.all(
				Object.values(i).map((e) =>
					n.fileOperationQueue.run(() =>
						(async function (e, t) {
							const s = R(t.dir || $(t.file), e.fileName)
							return await jh($(s), { recursive: !0 }), Gh(s, 'asset' === e.type ? e.source : e.code)
						})(e, r)
					)
				)
			),
				await o.hookParallel('writeBundle', [r, i]),
				Do('WRITE', 1)
		}
		return (
			(l = i),
			{
				output: Object.values(l)
					.filter((e) => Object.keys(e).length > 0)
					.sort((e, t) => $d(e) - $d(t))
			}
		)
		var l
	})
}
function Pd(e, t, s, i) {
	return (async function (e, t, s) {
		const i = new Set(s),
			n = e.compact || !1,
			r = sd(e),
			o = id(e, t),
			a = nd(e, o, t),
			l = td(e, a, t),
			c = rd(e, t),
			h = fd(e, c),
			u = {
				amd: ad(e),
				assetFileNames: e.assetFileNames ?? 'assets/[name]-[hash][extname]',
				banner: ld(e, 'banner'),
				chunkFileNames: e.chunkFileNames ?? '[name]-[hash].js',
				compact: n,
				dir: cd(e, l),
				dynamicImportFunction: hd(e, t, r),
				dynamicImportInCjs: e.dynamicImportInCjs ?? !0,
				entryFileNames: ud(e, i),
				esModule: e.esModule ?? 'if-default-prop',
				experimentalDeepDynamicChunkOptimization: dd(e, t),
				experimentalMinChunkSize: e.experimentalMinChunkSize ?? 1,
				exports: pd(e, i),
				extend: e.extend || !1,
				externalImportAssertions: e.externalImportAssertions ?? !0,
				externalLiveBindings: e.externalLiveBindings ?? !0,
				file: l,
				footer: ld(e, 'footer'),
				format: r,
				freeze: e.freeze ?? !0,
				generatedCode: h,
				globals: e.globals || {},
				hoistTransitiveImports: e.hoistTransitiveImports ?? !0,
				indent: md(e, n),
				inlineDynamicImports: o,
				interop: yd(e),
				intro: ld(e, 'intro'),
				manualChunks: Ed(e, o, a, t),
				minifyInternalExports: bd(e, r, n),
				name: e.name,
				namespaceToStringTag: vd(e, h, t),
				noConflict: e.noConflict || !1,
				outro: ld(e, 'outro'),
				paths: e.paths || {},
				plugins: await ou(e.plugins),
				preferConst: c,
				preserveModules: a,
				preserveModulesRoot: od(e),
				sanitizeFileName: 'function' == typeof e.sanitizeFileName ? e.sanitizeFileName : !1 === e.sanitizeFileName ? (e) => e : ed,
				sourcemap: e.sourcemap || !1,
				sourcemapBaseUrl: Ad(e),
				sourcemapExcludeSources: e.sourcemapExcludeSources || !1,
				sourcemapFile: e.sourcemapFile,
				sourcemapFileNames: Sd(e, i),
				sourcemapIgnoreList: 'function' == typeof e.sourcemapIgnoreList ? e.sourcemapIgnoreList : !1 === e.sourcemapIgnoreList ? () => !1 : (e) => e.includes('node_modules'),
				sourcemapPathTransform: e.sourcemapPathTransform,
				strict: e.strict ?? !0,
				systemNullSetters: e.systemNullSetters ?? !0,
				validate: e.validate || !1
			}
		return su(e, Object.keys(u), 'output options', t.onLog), { options: u, unsetOptions: i }
	})(
		i.hookReduceArg0Sync(
			'outputOptions',
			[s],
			(e, t) => t || e,
			(e) => {
				const t = () => e.error({ code: it, message: 'Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.' })
				return { ...e, emitFile: t, setAssetSource: t }
			}
		),
		e,
		t
	)
}
var Cd
function $d(e) {
	return 'asset' === e.type ? Cd.ASSET : e.isEntry ? Cd.ENTRY_CHUNK : Cd.SECONDARY_CHUNK
}
function Nd(e) {
	return e
}
!(function (e) {
	;(e[(e.ENTRY_CHUNK = 0)] = 'ENTRY_CHUNK'), (e[(e.SECONDARY_CHUNK = 1)] = 'SECONDARY_CHUNK'), (e[(e.ASSET = 2)] = 'ASSET')
})(Cd || (Cd = {}))
export { e as VERSION, Nd as defineConfig, kd as rollup }
